-*- mode: org; fill-column: 100; org-tags-column: 0; line-spacing: 0 -*-
#+author: James Dyer
#+html_head: <link rel="stylesheet" type="text/css" href="custom-styles_001.css" />
#+options: toc:nil author:t title:t date:nil tex:t tags:nil todo:t
#+startup: noinlineimages overview
#+hugo_base_dir: .
#+latex_class_options: [a4paper,portrait,11pt,twocolumn]
#+setupfile: latex/latex--common.org
#+latex_header: \fancyhead[C]{Emacs Blog}
#+exclude_tags: noexport
#+filetags: :@emacs:@linux:

* DONE Spent a bit of free time polishing ollama-buddy - github Copilot is now onboard! :ollama_buddy:ollama:emacs:2026:
:PROPERTIES:
:EXPORT_FILE_NAME: 20260204100913-emacs--ollama-buddy-updates---github-copilot-integration-plus-others
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2026-02-04 10:40>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg
:END:

I've had a little free time recently (figuring out this baby stuff!) and thought I would spend time revisiting and refining my AI assistant [[https://github.com/captainflasmr/ollama-buddy][ollama-buddy]]

I've been playing around with agentic coding and keeping up-to-date on the rapid development of the Emacs AI package landscape and I think I have refined in my own mind my idea of what I would like to see in an Emacs AI assistant.

The headline change regarding the latest release of ollama-buddy is GitHub Copilot integration;  the rest of the work is about smoothing the UI and simplifying day-to-day use.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg]]

What’s new - the Copilot addition (v1.2)

- GitHub Copilot Chat API support via a new file, ollama-buddy-copilot.el, so Copilot models can be used alongside your existing providers.
- Authentication uses GitHub’s device flow (OAuth). No API key required: M-x ollama-buddy-copilot-login opens a browser and guides you through secure authentication.
- Copilot models are identified with a "p:" prefix (for example, p:gpt-4o). The header line shows a "p" indicator when the Copilot provider is loaded so you always know it’s available.
- Copilot access exposes a broad set of models from multiple vendors through the Copilot interface: OpenAI (gpt-4o, gpt-5), Anthropic (claude-sonnet-4, claude-opus-4.5), Google (gemini-2.5-pro), and xAI models.
- Quick usage notes:
  1. Ensure you have an active GitHub Copilot subscription.
  2. Run M-x ollama-buddy-copilot-login.
  3. Enter the device code in your browser at github.com/login/device when prompted.
  4. Select a Copilot model with C-c m (e.g., p:gpt-4o).
- Example config to load Copilot support:
#+begin_src
(use-package ollama-buddy
  :bind
  ("C-c o" . ollama-buddy-menu)
  ("C-c O" . ollama-buddy-transient-menu-wrapper)
  :config
  (require 'ollama-buddy-copilot nil t))
#+end_src

Other notable updates in this release series
- *v1.2.1 (2026-02-02)*
  - Attachment count indicator on the header line so you get a constant visual reminder that the session has attachments.
- *v1.1.5 (2026-01-31)*
  - Global system prompt feature (enabled by default): sets a baseline set of instructions (for example, to prefer plain prose and avoid markdown tables) that is prepended to session-specific system prompts. This helps keep responses consistent across providers and things like malformed markdown tables for example, which seems to be common. There’s a toggle (ollama-buddy-global-system-prompt-enabled) and a quick command to flip it (ollama-buddy-toggle-global-system-prompt), plus a transient-menu entry.
  - Consolidated model management: streamlined into a single model management buffer (C-c W) and the welcome screen now points to that buffer for model tasks.
- *v1.1.4 (2026-01-31)*
  - Header-line and keybinding cleanup: C-c RET to send prompts (matches gptel, as I feel this seems intuitive), removed a redundant backend indicator, shortened the markdown indicator to "MD", and fixed markdown → org heading conversion to keep structure sane.
- *v1.1.3 (2026-01-31)*
  - Chat UX improvements and simplification: added ollama-buddy-auto-scroll (default nil — don’t auto-scroll so you can read while streaming) and ollama-buddy-pulse-response (flashes the response on completion, taking from gptel again, as if there is no autoscrolling it is useful to visually see when the response has completed). Removed the model name coloring feature and related toggles to simplify code and improve org-mode performance.
- *v1.1.2 (2026-01-30)*
  - Streamlined welcome screen and model selection, clearer provider indicators in the header line and an improved list of enabled online LLM providers.

* DONE Ollama buddy now supports cloud models! :ollama_buddy:ollama:emacs:2026:
:PROPERTIES:
:EXPORT_FILE_NAME: 20260128082917-emacs--Ollama-buddy-now-supports-cloud-models
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2026-01-28 08:29>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg
:END:

Having another look at my AI assistant - ollama-buddy, its been a while and it seems ollama has moved on since I started creating this package last year, so I have developed a new roadmap and the first step is to add ollama cloud models!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg]]

Here are some references to the project, including a youtube channel where I upload ollama-buddy demonstrations:

https://melpa.org/#/ollama-buddy

https://github.com/captainflasmr/ollama-buddy

Here is the changelog for the cloud model implementation:

** <2026-01-28 Tue> *1.1*

Added Ollama Cloud Models support

- Cloud models (running on ollama.com infrastructure) now work seamlessly
- =ollama-buddy-cloud-signin= to automatically open browser for authentication
- Cloud models are proxied through the local Ollama server which handles authentication
- Use =C-u C-c m= or transient menu "Model > Cloud" to select cloud models
- Status line shows ☁ indicator when using a cloud model
- Available cloud models include: qwen3-coder:480b-cloud, deepseek-v3.1:671b-cloud, gpt-oss:120b-cloud, minimax-m2.1:cloud, and more

* DONE Auto-Populating Weekly Dates in Org-Mode Tables :emacs:2026:org:
:PROPERTIES:
:EXPORT_FILE_NAME: 20260126101317-emacs--Auto-Populating-Weekly-Dates-in-Org-Mode-Tables
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2026-01-26 10:13>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20260126101317-emacs--Auto-Populating-Weekly-Dates-in-Org-Mode-Tables.jpg
:END:

Here is just a quick one, I was working with an org-mode table for tracking work weeks and needed to auto-populate a Date column where each row increments by exactly one week. The table structure looked like this:

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20260126101317-emacs--Auto-Populating-Weekly-Dates-in-Org-Mode-Tables.jpg]]

The first row has a base date (2026-01-05), and I wanted subsequent rows to automatically calculate as weekly increments: 2026-01-12, 2026-01-19, and so on.

Initially, I tried several approaches that seemed logical but encountered =#ERROR= results and eventually settled on a working solution which is to hardcode the base date directly in the formula:

#+begin_src org
#+TBLFM: $3='(format-time-string "%Y-%m-%d" (time-add (date-to-time "2026-01-05") (* (- @# 2) 7 24 3600)))
#+end_src

which gave:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20260126101317-emacs--Auto-Populating-Weekly-Dates-in-Org-Mode-Tables2.jpg]]

and I can now of course extend the table for all the weeks in the year and I don't have to fill in manually any more!

Here's how it works:

   - =(date-to-time "2026-01-05")= - Convert the hardcoded base date to Emacs time format
   - =(- @# 2)= - Calculate the offset from the base row
   - =(* (- @# 2) 7 24 3600)= - Convert the offset to seconds (weeks × days × hours × seconds)
   - =time-add= - Add the offset to the base date
   - =format-time-string "%Y-%m-%d"= - Format back to ISO date string

* DONE Speed Reading in Emacs: Building an RSVP Reader :emacs:2026:
:PROPERTIES:
:EXPORT_FILE_NAME: 20260116182841-emacs--Speed-Reading-in-Emacs:-Building-an-RSVP-Reader
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2026-01-18 10:30>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20260116182841-emacs--Speed-Reading-in-Emacs:-Building-an-RSVP-Reader.jpg
:END:

I recently came across a fascinating video titled "How Fast Can You Read? - Speed Reading Challenge" that demonstrated the power of RSVP (Rapid Serial Visual Presentation) for speed reading. The concept  is quite nice and simple and I vaguely remember seeing something about it a few years back.  Instead of your eyes scanning across lines of text, words are presented one at a time in a fixed position. This eliminates the mechanical overhead of eye movements and can dramatically increase reading speed!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20260116182841-emacs--Speed-Reading-in-Emacs:-Building-an-RSVP-Reader.jpg]]

So, I immediately wondered, could I build this into Emacs?, actually no, firstly I thought, are there any packages for Emacs that can do this?, of course there are!, the *spray* package from MELPA is a more mature, feature-rich option if you're looking for production-ready RSVP reading in Emacs, and also there is *speedread*.  However, there's something satisfying about having a compact, single-function solution that does exactly what you need, so lets see if I can build one!

RSVP works by displaying words sequentially in the same location on screen. Your eyes remain stationary, focused on a single point, while words flash by at a controlled pace. This technique can boost reading speeds to 300-600+ words per minute, compared to typical reading speeds of 200-300 WPM.

The key innovation is the *Optimal Recognition Point (ORP)* - typically positioned about one-third into each word. This is where your eye naturally fixates when reading. By aligning each word's ORP at the same screen position, RSVP creates an optimal visual flow.

Given Emacs' extensive text processing capabilities, this sounds something that Emacs could eat for breakfast. Here is what I came up with:

Here is a quick video of my implementation:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20260118100321--screen-recording.gif]]

and the defun:

#+begin_src elisp
(defun rsvp-minibuffer ()
  "Display words from point (or mark to point) in minibuffer using RSVP.
Use f/s for speed, [/] for size, b/n to skip, SPC to pause, q to quit."
  (interactive)
  (let* ((start (if (region-active-p) (region-beginning) (point)))
         (end (if (region-active-p) (region-end) (point-max)))
         (text (buffer-substring-no-properties start end))
         (wpm 350) (font-size 200) (orp-column 20)
         (word-positions '()) (pos 0) (i 0)
         (message-log-max nil))  ; Disable message logging
    ;; Build word positions list
    (dolist (word (split-string text))
      (unless (string-blank-p word)
        (when-let ((word-start (string-match (regexp-quote word) text pos)))
          (push (cons word (+ start word-start)) word-positions)
          (setq pos (+ word-start (length word))))))
    (setq word-positions (nreverse word-positions))
    ;; Display loop
    (while (< i (length word-positions))
      (let* ((word (car (nth i word-positions)))
             (word-pos (cdr (nth i word-positions)))
             (word-len (length word))
             (delay (* (/ 60.0 wpm)
                      (cond ((< word-len 3) 0.8) ((> word-len 8) 1.3) (t 1.0))
                      (if (string-match-p "[.!?]$" word) 1.5 1.0)))
             (orp-pos (/ word-len 3))
             (face-mono `(:height ,font-size :family "monospace"))
             (face-orp `(:foreground "red" :weight normal ,@face-mono))
             (padded-word (concat 
                          (propertize (make-string (max 0 (- orp-column orp-pos)) ?\s) 'face face-mono)
                          (propertize (substring word 0 orp-pos) 'face face-mono)
                          (propertize (substring word orp-pos (1+ orp-pos)) 'face face-orp)
                          (propertize (substring word (1+ orp-pos)) 'face face-mono))))
        (goto-char (+ word-pos word-len))
        (message "%s" padded-word)
        (pcase (read-event nil nil delay)
          (?f (setq wpm (min 1000 (+ wpm 50))))
          (?s (setq wpm (max 50 (- wpm 50))))
          (?\[ (setq font-size (max 100 (- font-size 20))))
          (?\] (setq font-size (min 400 (+ font-size 20))))
          (?b (setq i (max 0 (- i 10))))
          (?n (setq i (min (1- (length word-positions)) (+ i 10))))
          (?\s (read-event (format "%s [PAUSED - WPM: %d]" padded-word wpm)))
          (?q (setq i (length word-positions)))
          (_ (setq i (1+ i))))))))
#+end_src

The function calculates the ORP as one-third through each word and highlights it in red. By padding each word with spaces, the ORP character stays perfectly aligned in the same column, creating that crucial stationary focal point.

To ensure pixel-perfect alignment, the function explicitly sets a monospace font family for all displayed text. Without this, proportional fonts would cause the ORP to drift slightly between words, although I think at times there is a little waddle, but it is good enough.

Also, Not all words are created equal:

- Short words (< 3 characters) display 20% faster
- Long words (> 8 characters) display 30% slower
- Words ending in punctuation (=.!?=) get 50% more time

This mimics natural reading rhythms where you'd naturally pause at sentence boundaries.

While reading, you can try these keybindings: (which I borrowed off *spray*)

- =f= / =s= - Speed up or slow down (±50 WPM)
- =[= / =]= - Decrease or increase font size
- =b= / =n= - Skip backward or forward by 10 words
- =SPC= - Pause (press any key to resume)
- =q= - Quit
- =C-g= - Emergency quit

Also The function tracks each word's position in the original buffer and updates =point= as you read. This means:

- You can see where you are in the text
- When you quit, your cursor is at the last word you read
- You can resume reading by running the function again

To use it, simply:

1. Position your cursor where you want to start reading (or select a region)
2. Run =M-x rsvp-minibuffer=
3. Watch the words flow in the minibuffer

The function works from point to end of buffer, or if you have an active region, it only processes the selected text.

If you're curious about RSVP reading, drop this function into your Emacs config and give it a try. Start at 300-350 WPM and see how it feels. You might be surprised at how much faster you can consume text when your eyes aren't constantly moving across the page.

The code is simple enough to customize - adjust the default WPM, change the ORP colour, modify the timing multipliers, or add new controls. That's the beauty of Emacs, if you can imagine it, you can build it.

* DONE A single function ripgrep alternative to rgrep :emacs:2026:
:PROPERTIES:
:EXPORT_FILE_NAME: 20260109094340-emacs--A-Single-Function-ripgrep-Alternative-to-rgrep
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2026-01-09 09:43>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20260109094340-emacs--A-Single-Function-ripgrep-Alternative-to-rgrep.jpg
:END:

For years, =rgrep= has been the go-to solution for searching codebases in Emacs. It's built-in, reliable, and works everywhere. But it's slow on large projects and uses the aging =find= and =grep= commands.

Packages like =deadgrep= and =rg.el= provide ripgrep integration, and for years I used =deadgrep= and really liked it. But what if you could get ripgrep's speed with just a single function you paste into your config?

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20260109094340-emacs--A-Single-Function-ripgrep-Alternative-to-rgrep.jpg]]

This post introduces a ~100 line =defun= that replaces rgrep, no packages, no dependencies, just pure Elisp. It's fast, asynchronous, works offline, and mimics rgrep's familiar interface so it can leverage =grep-mode=

So, why not just use rgrep?

I think that rgrep has three main limitations:

Firstly, speed. On a project with 10,000+ files, rgrep can take 15-30 seconds. Ripgrep completes the same search in under a second.

Secondly, file ignoring, rgrep requires manually configuring =grep-find-ignored-directories= or =grep-find-ignored-files=, I had the following typical configuration for rgrep, but it wasn't as flexible as I would like it to be:

#+begin_src elisp
(eval-after-load 'grep
  '(progn
     (dolist (dir '("nas" ".cache" "cache" "elpa" "chromium" ".local/share" "syncthing" ".mozilla" ".local/lib" "Games"))
       (push dir grep-find-ignored-directories))
     (dolist (file '(".cache" "*cache*" "*.iso" "*.xmp" "*.jpg" "*.mp4"))
       (push file grep-find-ignored-files))
     ))
#+end_src

Ripgrep automatically respects an =.ignore= file. Just create an =.ignore= file in your project root and list patterns to exclude, this is just a simple text file, universally applied across all searches and any changes can be easily applied.

Thirdly, modern features. Ripgrep includes smart-case search, better regex support, and automatic binary file detection. Of course, there is a context that can be displayed around the found line, but in order to get ripgrep to work with grep-mode, this is not really doable, and it's not something I need anyway.

-----

Here is the complete ripgrep implementation that you can paste directly into your =init.el=:

#+begin_src elisp
(defun my/grep (search-term &optional directory glob)
  "Run ripgrep (rg) with SEARCH-TERM and optionally DIRECTORY and GLOB.
If ripgrep is unavailable, fall back to Emacs's rgrep command. Highlights SEARCH-TERM in results.
By default, only the SEARCH-TERM needs to be provided. If called with a
universal argument, DIRECTORY and GLOB are prompted for as well."
  (interactive
   (let* ((univ-arg current-prefix-arg)
          (default-search-term
           (cond
            ((use-region-p)
             (buffer-substring-no-properties (region-beginning) (region-end)))
            ((thing-at-point 'symbol t))
            ((thing-at-point 'word t))
            (t ""))))
     (list
      (read-string (if (string-empty-p default-search-term)
                       "Search for: "
                     (format "Search for (default `%s`): " default-search-term))
                   nil nil default-search-term)
      (when univ-arg (read-directory-name "Directory: "))
      (when univ-arg (read-string "File pattern (glob, default: ): " nil nil "")))))
  (let* ((directory (expand-file-name (or directory default-directory)))
         (glob (or glob ""))
         (buffer-name "*grep*"))
    (if (executable-find "rg")
        (let ((buffer (get-buffer-create buffer-name)))
          (with-current-buffer buffer
            (setq default-directory directory)
            (let ((inhibit-read-only t))
              (erase-buffer)
              (insert (format "-*- mode: grep; default-directory: \"%s\" -*-\n\n" directory))
              (if (not (string= "" glob))
                  (insert (format "[o] Glob: %s\n\n" glob)))
              (insert "Searching...\n\n"))
            (grep-mode)
            (setq-local my/grep-search-term search-term)
            (setq-local my/grep-directory directory)
            (setq-local my/grep-glob glob))
          
          (pop-to-buffer buffer)
          (goto-char (point-min))
          
          (make-process
           :name "ripgrep"
           :buffer buffer
           :command `("rg" "--color=never" "--max-columns=500" 
                      "--column" "--line-number" "--no-heading" 
                      "--smart-case" "-e" ,search-term
                      "--glob" ,glob ,directory)
           :filter (lambda (proc string)
                     (when (buffer-live-p (process-buffer proc))
                       (with-current-buffer (process-buffer proc)
                         (let ((inhibit-read-only t)
                               (moving (= (point) (process-mark proc))))
                           (setq string (replace-regexp-in-string "[\r\0\x01-\x08\x0B-\x0C\x0E-\x1F]" "" string))
                           ;; Replace full directory path with ./ in the incoming output
                           (setq string (replace-regexp-in-string 
                                         (concat "^" (regexp-quote directory))
                                         "./"
                                         string))
                           (save-excursion
                             (goto-char (process-mark proc))
                             (insert string)
                             (set-marker (process-mark proc) (point)))
                           (if moving (goto-char (process-mark proc)))))))
           :sentinel
           (lambda (proc _event)
             (when (memq (process-status proc) '(exit signal))
               (with-current-buffer (process-buffer proc)
                 (let ((inhibit-read-only t))
                   ;; Remove "Searching..." line
                   (goto-char (point-min))
                   (while (re-search-forward "Searching\\.\\.\\.\n\n" nil t)
                     (replace-match "" nil t))

                   ;; Clean up the output - replace full paths with ./
                   (goto-char (point-min))
                   (forward-line 3)
                   (let ((start-pos (point)))
                     (while (re-search-forward (concat "^" (regexp-quote directory)) nil t)
                       (replace-match "./" t t))
                     
                     ;; Check if any results were found
                     (goto-char start-pos)
                     (when (= (point) (point-max))
                       (insert "No results found.\n")))
                   
                   (goto-char (point-max))
                   (insert "\nRipgrep finished\n")

                   ;; Highlight search terms using grep's match face
                   (goto-char (point-min))
                   (forward-line 3)
                   (save-excursion
                     (while (re-search-forward (regexp-quote search-term) nil t)
                       (put-text-property (match-beginning 0) (match-end 0)
                                          'face 'match)
                       (put-text-property (match-beginning 0) (match-end 0)
                                          'font-lock-face 'match))))
                 
                 ;; Set up keybindings
                 (local-set-key (kbd "D") 
                                (lambda () 
                                  (interactive)
                                  (my/grep my/grep-search-term 
                                           (read-directory-name "New search directory: ")
                                           my/grep-glob)))
                 (local-set-key (kbd "S") 
                                (lambda () 
                                  (interactive)
                                  (my/grep (read-string "New search term: "
                                                        nil nil my/grep-search-term)
                                           my/grep-directory
                                           my/grep-glob)))
                 (local-set-key (kbd "o") 
                                (lambda () 
                                  (interactive)
                                  (my/grep my/grep-search-term
                                           my/grep-directory
                                           (read-string "New glob: "))))
                 (local-set-key (kbd "g") 
                                (lambda () 
                                  (interactive)
                                  (my/grep my/grep-search-term my/grep-directory my/grep-glob)))
                 
                 (goto-char (point-min))
                 (message "ripgrep finished."))))
           )
          (message "ripgrep started..."))
      ;; Fallback to rgrep
      (progn
        (setq default-directory directory)
        (message (format "%s : %s : %s" search-term glob directory))
        (rgrep search-term (if (string= "" glob) "*" glob) directory)))))
#+end_src

That's it. ~100 lines. No dependencies. No packages to manage! (well except ripgrep of course)

Now that I have complete control over this function, I have added further improvements over rgrep, inspired by =deadgrep=

- *=S=* - New search term
- *=D=* - New directory
- *=o=* - New glob pattern
- *=g=* - Re-run current search

and a universal argument can be passed through to set these up on the initial grep

I have tried to make the output as similar as possible to rgrep, to be compatible with =grep-mode= and for familiarity, so it will be something like:

#+begin_src 
-*- mode: grep; default-directory: "~/project/" -*-

[o] Glob: *.el

./init.el:42:10:(defun my-function ()
./config.el:156:5:  (my-function)
./helpers.el:89:12:;; Helper for my-function

Ripgrep finished
#+end_src

and if a glob is applied it will display the glob pattern.

Its perfect for offline environments, and yes, I'm banging on about this again!, no network, no package manager, no dependencies (except ripgrep of course!)

* DONE New package dired-video-thumbnail added to MELPA! :emacs:2025:melpa:
:PROPERTIES:
:EXPORT_FILE_NAME: 20251231183401-emacs--dired-video-thumbnail
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-12-31 18:34>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20251231183401-emacs--dired-video-thumbnail.jpg
:END:

I have created another package!, this time something that I thought was missing from the mighty Emacs and that is the ability to show video thumbnails in a grid and to be able to filter, sort e.t.c.  Basically like an enhanced =image-dired=.  I have been increasingly using =image-dired= for my image editing and management needs and am always adding little improvements, to such an extent I decided to create a video thumb grid package, enjoy!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20251231183401-emacs--dired-video-thumbnail.jpg]]

** Introduction

=dired-video-thumbnail= is an Emacs package that provides =image-dired= style thumbnail viewing for video files. It extracts thumbnails from videos using =ffmpeg= and displays them in a grid layout, allowing you to visually browse and manage video collections directly from Emacs.

** Features

- *Thumbnail grid display* - View video thumbnails in a configurable grid layout
- *Persistent caching* - Thumbnails are cached and only regenerated when the source file changes
- *Async generation* - Emacs remains responsive while thumbnails are generated in the background
- *Dired integration* - Marks sync bidirectionally with the associated dired buffer
- *Visual mark indication* - Marked thumbnails display a coloured border (like =image-dired=)
- *Dynamic header line* - Shows filename, dimensions, duration, and file size for the current video
- *Click to play* - Open videos in your preferred external player
- *Cross-platform* - Works on Linux, macOS, and Windows
- *Resizable thumbnails* - Adjust thumbnail size on the fly
- *Sorting* - Sort videos by name, date, size, or duration
- *Filtering* - Filter videos by name pattern, duration range, or file size
- *Recursive search* - Browse videos across subdirectories with optional auto-recursive mode
- *Transient menu* - Comprehensive command menu accessible via =.= or =C-c .=

** Whats New

*** <2025-12-15 Mon> 0.3.0

Added transient menu interface

Introduced a comprehensive transient menu (=dired-video-thumbnail-transient=) providing quick access to all commands via =.= or =C-c .= in the thumbnail buffer. The menu displays current state (sort order, filters, video count, recursive/wrap mode) and organises commands into logical groups: Navigation, Playback, Sorting, Filtering, Marking, Delete, Display, and Other.

*** <2025-12-15 Mon> 0.2.0

Enhanced package with sorting, filtering, and docs

Added sorting and filtering features to =dired-video-thumbnail=. Introduced customizable options for sorting and filtering criteria, and implement interactive commands for toggling these settings. Included comprehensive documentation in Texinfo format, covering installation, usage, and customization.

** Requirements

- Emacs 28.1 or later
- [[https://ffmpeg.org/][ffmpeg]] and =ffprobe= installed and available in your PATH
- [[https://github.com/magit/transient][transient]] 0.4.0 or later (for the transient menu)

** Installation

*** Manual

Download =dired-video-thumbnail.el= and place it in your load-path:

#+begin_src emacs-lisp
(add-to-list 'load-path "/path/to/dired-video-thumbnail/")
(require 'dired-video-thumbnail)
#+end_src

*** use-package

#+begin_src emacs-lisp
(use-package dired-video-thumbnail
  :load-path "/path/to/dired-video-thumbnail/"
  :bind (:map dired-mode-map
         ("C-t v" . dired-video-thumbnail)))
#+end_src

*** straight.el

#+begin_src emacs-lisp
(straight-use-package
 '(dired-video-thumbnail :type git :host github :repo "captainflasmr/dired-video-thumbnail"))
#+end_src

** Usage

*** Basic Usage

1. Open a directory containing video files in dired
2. Run =M-x dired-video-thumbnail=
3. A new buffer opens displaying thumbnails for all videos in the directory
4. The cursor automatically moves to the first thumbnail

*** With Marked Files

1. In dired, mark specific video files with =m=
2. Run =M-x dired-video-thumbnail=
3. Only thumbnails for the marked videos are displayed

*** Recursive Mode

To include videos from subdirectories:

- Use =C-u M-x dired-video-thumbnail= (with prefix argument)
- Or run =M-x dired-video-thumbnail-recursive=
- Or press =R= in the thumbnail buffer to toggle recursive mode

When =dired-video-thumbnail-auto-recursive= is enabled (the default), the package automatically searches subdirectories if the current directory contains no video files.

*** Suggested Keybinding

Add a keybinding in dired for quick access:

#+begin_src emacs-lisp
(with-eval-after-load 'dired
  (define-key dired-mode-map (kbd "C-t v") #'dired-video-thumbnail))
#+end_src

** Transient Menu

Press =.= or =C-c .= in the thumbnail buffer to open the transient menu. This provides a comprehensive interface to all commands with a live status display.

#+begin_example
State: Sort: name ↑ | Videos: 42 | Recursive: OFF | Wrap: ON

Navigation            Playback       Sorting              Filtering
n Next                RET Play video s Sort menu...       / Filter menu...
p Previous            o Play video   S Interactive sort   \ Interactive filter
C-n Next row                         r Reverse order      c Clear filters
C-p Previous row
d Go to dired

Marking               Delete         Display              Other
m Mark menu...        D Delete       v Display menu...    g Regenerate thumbnail
M Mark all            x Delete marked+ Larger thumbnails  G Regenerate all
U Unmark all                         - Smaller thumbnails C Clear cache
t Toggle all marks                   w Toggle wrap        ? Help
                                     R Toggle recursive   q Quit menu
                                                          Q Quit buffer
#+end_example

The status line at the top shows:
- Current sort criteria and direction (e.g., =name ↑=)
- Number of videos displayed (and total if filtered)
- Recursive mode status
- Wrap display mode status
- Active filters (if any)

*** Submenus

Several keys open submenus with additional options:

- =s= - *Sort menu*: Sort by name, date, size, or duration; reverse order
- =/= - *Filter menu*: Filter by name regexp, duration range, or size range; clear filters
- =m= - *Mark menu*: Mark/unmark current, toggle current, mark/unmark/toggle all
- =v= - *Display menu*: Adjust size, toggle wrap/recursive, refresh, regenerate thumbnails

** Header Line

As you navigate between thumbnails, the header line dynamically displays information about the current video:

- *Mark indicator* - A red =*= if the video is marked
- *Filename* - The video filename in bold
- *Dimensions* - Video resolution (e.g., =1920x1080=)
- *Duration* - Video length (e.g., =5:32= or =1:23:45=)
- *File size* - Size in MB (e.g., =45.2 MB=)

The header also shows current sort settings (e.g., =[name ↑]=), active filters, and a =[recursive]= indicator when browsing subdirectories.

** Keybindings

In the =*Video Thumbnails*= buffer:

*** Transient Menu

| Key     | Command                          | Description              |
|---------+----------------------------------+--------------------------|
| =.=     | ~dired-video-thumbnail-transient~ | Open transient menu     |
| =C-c .= | ~dired-video-thumbnail-transient~ | Open transient menu     |

*** Navigation

| Key       | Command                              | Description                       |
|-----------+--------------------------------------+-----------------------------------|
| =n=       | ~dired-video-thumbnail-next~         | Move to next thumbnail            |
| =p=       | ~dired-video-thumbnail-previous~     | Move to previous thumbnail        |
| =SPC=     | ~dired-video-thumbnail-play~         | Play video at point               |
| =C-f=     | ~dired-video-thumbnail-forward~      | Move to next thumbnail            |
| =C-b=     | ~dired-video-thumbnail-backward~     | Move to previous thumbnail        |
| =<right>= | ~dired-video-thumbnail-forward~      | Move to next thumbnail            |
| =<left>=  | ~dired-video-thumbnail-backward~     | Move to previous thumbnail        |
| =<up>=    | ~dired-video-thumbnail-previous-row~ | Move up one row                   |
| =<down>=  | ~dired-video-thumbnail-next-row~     | Move down one row                 |
| =d=       | ~dired-video-thumbnail-goto-dired~   | Switch to associated dired buffer |
| =q=       | ~quit-window~                        | Close the thumbnail buffer        |
| =Q=       | ~dired-video-thumbnail-quit-and-kill~| Quit and kill the buffer          |

*** Playback

| Key       | Command                      | Description         |
|-----------+------------------------------+---------------------|
| =RET=     | ~dired-video-thumbnail-play~ | Play video at point |
| =o=       | ~dired-video-thumbnail-play~ | Play video at point |
| =mouse-1= | ~dired-video-thumbnail-play~ | Play video (click)  |

On Linux, videos open with =xdg-open=. On macOS, they open with =open=. On Windows, they open with the system default player. You can also specify a custom player.

*** Marking

Marks are synchronised with the associated dired buffer, so marking a video in the thumbnail view also marks it in dired, and vice versa.

| Key       | Command                                  | Description                   |
|-----------+------------------------------------------+-------------------------------|
| =m=       | ~dired-video-thumbnail-mark~             | Mark video and move to next   |
| =u=       | ~dired-video-thumbnail-unmark~           | Unmark video and move to next |
| =mouse-3= | ~dired-video-thumbnail-toggle-mark~      | Toggle mark (right-click)     |
| =M=       | ~dired-video-thumbnail-mark-all~         | Mark all videos               |
| =U=       | ~dired-video-thumbnail-unmark-all~       | Unmark all videos             |
| =t=       | ~dired-video-thumbnail-toggle-all-marks~ | Invert all marks              |

*** Deletion

| Key | Command                               | Description                               |
|-----+---------------------------------------+-------------------------------------------|
| =D= | ~dired-video-thumbnail-delete~        | Delete video at point (with confirmation) |
| =x= | ~dired-video-thumbnail-delete-marked~ | Delete marked videos (with confirmation)  |

*** Display

| Key | Command                                | Description                            |
|-----+----------------------------------------+----------------------------------------|
| =+= | ~dired-video-thumbnail-increase-size~  | Increase thumbnail size                |
| =-= | ~dired-video-thumbnail-decrease-size~  | Decrease thumbnail size                |
| =r= | ~dired-video-thumbnail-refresh~        | Refresh the display                    |
| =w= | ~dired-video-thumbnail-toggle-wrap~    | Toggle wrap mode (flow vs fixed cols)  |
| =R= | ~dired-video-thumbnail-toggle-recursive~ | Toggle recursive directory search    |
| =g= | ~dired-video-thumbnail-regenerate~     | Regenerate thumbnail at point          |
| =G= | ~dired-video-thumbnail-regenerate-all~ | Regenerate all thumbnails              |

*** Sorting

| Key  | Command                               | Description              |
|------+---------------------------------------+--------------------------|
| =S=  | ~dired-video-thumbnail-sort~          | Interactive sort menu    |
| =sn= | ~dired-video-thumbnail-sort-by-name~  | Sort by filename         |
| =sd= | ~dired-video-thumbnail-sort-by-date~  | Sort by modification date|
| =ss= | ~dired-video-thumbnail-sort-by-size~  | Sort by file size        |
| =sD= | ~dired-video-thumbnail-sort-by-duration~ | Sort by video duration|
| =sr= | ~dired-video-thumbnail-sort-reverse~  | Reverse sort order       |

*** Filtering

| Key  | Command                                  | Description              |
|------+------------------------------------------+--------------------------|
| =\=  | ~dired-video-thumbnail-filter~           | Interactive filter menu  |
| =/n= | ~dired-video-thumbnail-filter-by-name~   | Filter by name regexp    |
| =/d= | ~dired-video-thumbnail-filter-by-duration~ | Filter by duration range |
| =/s= | ~dired-video-thumbnail-filter-by-size~   | Filter by size range     |
| =/c= | ~dired-video-thumbnail-filter-clear~     | Clear all filters        |
| =//= | ~dired-video-thumbnail-filter-clear~     | Clear all filters        |

*** Help

| Key | Command                       | Description |
|-----+-------------------------------+-------------|
| =h= | ~dired-video-thumbnail-help~  | Show help   |
| =?= | ~dired-video-thumbnail-help~  | Show help   |

** Customisation

All customisation options are in the =dired-video-thumbnail= group. Use =M-x customize-group RET dired-video-thumbnail RET= to browse them interactively.

*** Thumbnail Cache Location

Thumbnails are stored in =~/.emacs.d/dired-video-thumbnails/= by default:

#+begin_src emacs-lisp
(setq dired-video-thumbnail-cache-dir "~/path/to/cache/")
#+end_src

*** Thumbnail Size

Control the generated thumbnail size and display height:

#+begin_src emacs-lisp
(setq dired-video-thumbnail-size 200)           ;; Generated thumbnail size (pixels)
(setq dired-video-thumbnail-display-height 150) ;; Display height in buffer
#+end_src

Thumbnails are generated as squares to ensure consistent grid alignment regardless of video aspect ratio.

*** Grid Layout

Set the number of columns in the thumbnail grid:

#+begin_src emacs-lisp
(setq dired-video-thumbnail-columns 4)
#+end_src

*** Wrap Display

Control whether thumbnails wrap to fill the window width:

#+begin_src emacs-lisp
(setq dired-video-thumbnail-wrap-display t)   ;; Wrap to window width (default)
(setq dired-video-thumbnail-wrap-display nil) ;; Use fixed columns
(setq dired-video-thumbnail-spacing 4)        ;; Spacing between thumbnails (pixels)
#+end_src

*** Thumbnail Timestamp

By default, thumbnails are extracted at 5 seconds into the video. Change this to get a more representative frame:

#+begin_src emacs-lisp
(setq dired-video-thumbnail-timestamp "00:00:10")  ;; 10 seconds in
(setq dired-video-thumbnail-timestamp "00:01:00")  ;; 1 minute in
(setq dired-video-thumbnail-timestamp nil)         ;; Let ffmpeg choose
#+end_src

*** Video Player

Set your preferred video player:

#+begin_src emacs-lisp
(setq dired-video-thumbnail-video-player "mpv")
(setq dired-video-thumbnail-video-player "vlc")
(setq dired-video-thumbnail-video-player nil)  ;; Use system default
#+end_src

When set to =nil= (the default), videos open with:
- Linux: =xdg-open=
- macOS: =open=
- Windows: System default player (e.g., Films & TV)

*** Video Extensions

Add or modify recognised video file extensions:

#+begin_src emacs-lisp
(setq dired-video-thumbnail-video-extensions
      '("mp4" "mkv" "avi" "mov" "webm" "m4v" "wmv" "flv" "mpeg" "mpg" "ogv" "3gp"))
#+end_src

*** Mark Border Appearance

Marked thumbnails are indicated with a coloured border. Customise the border width and colour:

#+begin_src emacs-lisp
(setq dired-video-thumbnail-mark-border-width 4)  ;; Border width in pixels

;; Change border colour via the face
(set-face-foreground 'dired-video-thumbnail-mark "blue")
#+end_src

*** Default Sorting

Set the default sort criteria and order:

#+begin_src emacs-lisp
(setq dired-video-thumbnail-sort-by 'name)       ;; Options: name, date, size, duration
(setq dired-video-thumbnail-sort-order 'ascending) ;; Options: ascending, descending
#+end_src

*** Recursive Search

Control recursive directory searching behaviour:

#+begin_src emacs-lisp
(setq dired-video-thumbnail-recursive nil)       ;; Always search recursively
(setq dired-video-thumbnail-auto-recursive t)    ;; Auto-recursive when no local videos (default)
#+end_src

When =dired-video-thumbnail-auto-recursive= is enabled and the current directory has no video files but has subdirectories, the package automatically searches recursively.

*** ffmpeg Path

If ffmpeg/ffprobe are not in your PATH:

#+begin_src emacs-lisp
(setq dired-video-thumbnail-ffmpeg-program "/usr/local/bin/ffmpeg")
(setq dired-video-thumbnail-ffprobe-program "/usr/local/bin/ffprobe")
#+end_src

** Example Configuration

#+begin_src emacs-lisp
(use-package dired-video-thumbnail
  :load-path "/path/to/dired-video-thumbnail/"
  :bind (:map dired-mode-map
         ("C-t v" . dired-video-thumbnail))
  :custom
  (dired-video-thumbnail-size 250)
  (dired-video-thumbnail-display-height 180)
  (dired-video-thumbnail-columns 5)
  (dired-video-thumbnail-timestamp "00:00:10")
  (dired-video-thumbnail-video-player nil)  ;; Use system default
  (dired-video-thumbnail-mark-border-width 5)
  (dired-video-thumbnail-sort-by 'date)
  (dired-video-thumbnail-sort-order 'descending)
  (dired-video-thumbnail-auto-recursive t)
  :custom-face
  (dired-video-thumbnail-mark ((t (:foreground "orange")))))
#+end_src

** Cache Management

Thumbnails are cached based on the file path and modification time. If you modify a video file, the thumbnail will be automatically regenerated on next view.

Video metadata (dimensions, duration) is also cached in memory to avoid repeated calls to =ffprobe=.

To manually clear the thumbnail cache:

#+begin_src emacs-lisp
M-x dired-video-thumbnail-clear-cache
#+end_src

** Workflow Examples

*** Reviewing and Deleting Unwanted Videos

1. Open a directory with videos in dired
2. =C-t v= to open thumbnail view
3. Browse thumbnails with =n=, =p=, =SPC=, or arrow keys
4. Press =D= to delete individual videos, or mark with =m= and delete with =x=

*** Selecting Videos for Processing

1. Open thumbnail view with =C-t v=
2. Mark videos you want to process with =m=
3. Press =d= to switch to dired
4. Your marked videos are already selected in dired
5. Use any dired command (=C=, =R=, =!=, etc.) on marked files

*** Quick Video Preview

1. In dired, position cursor on a video file
2. =C-t v= opens thumbnail view
3. =RET= to play the video
4. =q= to return to dired

*** Finding Large Videos

1. Open thumbnail view with =C-t v=
2. Press =.= to open the transient menu
3. Press =s= then =s= to sort by size
4. Press =r= to reverse order (largest first)
5. Or use =/= then =s= to filter by size range

*** Finding Long Videos

1. Press =.= to open the transient menu
2. Press =s= then =D= to sort by duration
3. Or use =/= then =d= to filter by duration range (e.g., =5:00= to =30:00=)

*** Searching by Name

1. Press =.= to open the transient menu
2. Press =/= then =n= and enter a regexp pattern
3. Only matching videos are shown
4. Press =c= to clear the filter

** Troubleshooting

*** Thumbnails not generating

1. Ensure ffmpeg is installed: =ffmpeg -version=
2. Check that ffmpeg is in your PATH or set =dired-video-thumbnail-ffmpeg-program=
3. Try regenerating with =g= on a specific thumbnail

*** Placeholder showing instead of thumbnail

Some videos may fail to generate thumbnails if:
- The video is corrupted
- The timestamp is beyond the video duration (try setting =dired-video-thumbnail-timestamp= to =nil=)
- ffmpeg doesn't support the codec

Press =g= on the thumbnail to retry generation.

*** Video info not showing in header line

Ensure =ffprobe= is installed (it comes with ffmpeg). Set =dired-video-thumbnail-ffprobe-program= if it's not in your PATH.

*** Marks not syncing with dired

Run =M-x dired-video-thumbnail-debug= to check if the dired buffer is properly associated. The output should show a live dired buffer reference.

*** Performance with many videos

The package processes up to 4 videos concurrently by default. For directories with hundreds of videos, initial thumbnail generation may take some time, but Emacs remains responsive and thumbnails appear as they complete.

** Related Packages

- [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Image_002dDired.html][image-dired]] - Built-in image thumbnail browser for dired
- [[https://github.com/alexluigit/dirvish][dirvish]] - A modern file manager for Emacs with preview support

* DONE Setting Up Emacs for C# Development on Windows :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20251216082551-emacs--Setting-Up-Emacs-for-C#-Development-on-Windows
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-12-16 08:25>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20251216082551-emacs--Setting-Up-Emacs-for-Csharp-Development-on-Windows.jpg
:END:

** Introduction

I have been developing C# with .NET 9.0 for the last year on Windows and I thought it was probably time to write down my current setup, and maybe someone might even find this useful!

So, this guide documents my setup for running Emacs 30.1 on Windows with full C# development support, including LSP, debugging (through DAPE), and all the ancillary tools you'd expect from a modern development environment. The setup is designed to be portable and self-contained, which is particularly useful in air-gapped or restricted environments.

A version of this can be found at https://github.com/captainflasmr/Emacs-on-windows which will be a living continually updated version!

#+hugo: more 

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20251216082551-emacs--Setting-Up-Emacs-for-Csharp-Development-on-Windows.jpg]]

** Prerequisites

Before we begin, you'll need:

- *Windows 10 or 11* (64-bit)
- *.NET 9.0 SDK* - Required for csharp-ls and building .NET projects
- *Visual Studio 2022* (optional) - Useful for MSBuild and if you need the full IDE occasionally
- *Administrator access* - For initial setup only

You can verify your .NET installation by opening a command prompt and running:

#+begin_src shell
dotnet --version
#+end_src

If you see version 9.0.x or later, you're ready to proceed.

** The Big Picture

Here's what we're building:

#+begin_example
D:\source\emacs-30.1\
├── bin\
│   ├── emacs.exe, runemacs.exe, etc.
│   ├── PortableGit\          # Git for version control
│   ├── Apache-Subversion\    # SVN (if needed)
│   ├── csharp-ls\            # C# Language Server
│   ├── netcoredbg\           # .NET debugger
│   ├── omnisharp-win-x64\    # Alternative C# LSP
│   ├── hunspell\             # Spell checking
│   ├── find\                 # ripgrep for fast searching
│   ├── ffmpeg-7.1.1-.../     # Video processing
│   └── ImageMagick-.../      # Image processing
└── share\
    └── emacs\...
#+end_example

The key insight here is keeping everything within the Emacs installation directory. This makes the whole setup portable—you can copy it to another machine or keep it on a USB drive.

** Step 1: Installing Emacs

Download Emacs 30.1 from the [[https://www.gnu.org/software/emacs/download.html][GNU Emacs download page]]. For Windows, grab the installer or the zip archive.

I install to an external drive =D:\source\emacs-30.1= rather than Program Files—it avoids permission issues and keeps everything in one place.

Test your installation by running =bin\runemacs.exe=. You should see a fresh Emacs frame.

** Step 2: Setting Up csharp-ls (The C# Language Server)

This is the heart of the C# development experience. =csharp-ls= provides code completion, go-to-definition, find references, diagnostics, and more through the Language Server Protocol (LSP).

*** Option A: Installing via dotnet tool (Recommended for Internet Access)

If you have internet access, the easiest way to install csharp-ls is as a .NET global tool:

#+begin_src shell
# Install the latest version globally
dotnet tool install --global csharp-ls

# Or install a specific version
dotnet tool install --global csharp-ls --version 0.20.0

# Verify installation
csharp-ls --version
#+end_src

By default, global tools are installed to:
- Windows: =%USERPROFILE%\.dotnet\tools=

The executable will be =csharp-ls.exe= and can be called directly once the tools directory is in your PATH.

*** Option B: Offline Installation via NuGet Package

For air-gapped environments, you can download the NuGet package and extract it manually:

1. On a machine with internet, download the package:
   #+begin_src shell
   # Download the nupkg file
   nuget install csharp-ls -Version 0.20.0 -OutputDirectory ./packages
   
   # Or download directly from NuGet Gallery:
   # https://www.nuget.org/packages/csharp-ls/
   # Click "Download package" on the right side
   #+end_src

2. The =.nupkg= file is just a ZIP archive. Extract it:
   #+begin_src shell
   # Rename to .zip and extract, or use 7-Zip
   # The DLLs are in tools/net9.0/any/
   #+end_src

3. Copy the =tools/net9.0/any/= directory to your Emacs bin:
   #+begin_src shell
   xcopy /E packages\csharp-ls.0.20.0\tools\net9.0\any D:\source\emacs-30.1\bin\csharp-ls\
   #+end_src

4. The language server is now at:
   =D:\source\emacs-30.1\bin\csharp-ls\CSharpLanguageServer.dll=

*** Configuring Eglot for csharp-ls

In your =init.el=, configure Eglot to use csharp-ls:

#+begin_src emacs-lisp
(require 'eglot)

;; Option A: If installed as a global tool
(setq eglot-server-programs
      '((csharp-mode . ("csharp-ls"))))

;; Option B: If running from extracted DLL
(setq eglot-server-programs
      '((csharp-mode . ("dotnet" 
                        "D:/source/emacs-30.1/bin/csharp-ls/CSharpLanguageServer.dll"))))
#+end_src

I also have the following commented out if there are some eglot functions that causes slowdowns or I just think I don't need:

#+begin_src elisp
(setq eglot-ignored-server-capabilities
      '(
        ;; :hoverProvider                    ; Documentation on hover
        ;; :completionProvider               ; Code completion
        ;; :signatureHelpProvider            ; Function signature help
        ;; :definitionProvider               ; Go to definition
        ;; :typeDefinitionProvider           ; Go to type definition
        ;; :implementationProvider           ; Go to implementation
        ;; :declarationProvider              ; Go to declaration
        ;; :referencesProvider               ; Find references
        ;; :documentHighlightProvider        ; Highlight symbols automatically
        ;; :documentSymbolProvider           ; List symbols in buffer
        ;; :workspaceSymbolProvider          ; List symbols in workspace
        ;; :codeActionProvider               ; Execute code actions
        ;; :codeLensProvider                 ; Code lens
        ;; :documentFormattingProvider       ; Format buffer
        ;; :documentRangeFormattingProvider  ; Format portion of buffer
        ;; :documentOnTypeFormattingProvider ; On-type formatting
        ;; :renameProvider                   ; Rename symbol
        ;; :documentLinkProvider             ; Highlight links in document
        ;; :colorProvider                    ; Decorate color references
        ;; :foldingRangeProvider             ; Fold regions of buffer
        ;; :executeCommandProvider           ; Execute custom commands
        ;; :inlayHintProvider                ; Inlay hints
        ))
#+end_src

** Step 3: Setting Up the Debugger (netcoredbg)

For debugging .NET applications, we'll use =netcoredbg=, which implements the Debug Adapter Protocol (DAP).

*** Installing netcoredbg

1. Download from [[https://github.com/Samsung/netcoredbg/releases][Samsung's GitHub releases]]
2. Extract to =D:\source\emacs-30.1\bin\netcoredbg\=
3. Verify: =netcoredbg.exe --version=

*** Configuring dape for Debugging

=dape= is an excellent DAP client for Emacs. Here's my configuration:

#+begin_src emacs-lisp
(use-package dape
  :load-path "z:/SharedVM/source/dape-master"
  :init
  ;; Set key prefix BEFORE loading dape
  (setq dape-key-prefix (kbd "C-c d"))
  :config
  ;; Define common configuration
  (defvar project-netcoredbg-path "d:/source/emacs-30.1/bin/netcoredbg/netcoredbg.exe"
    "Path to netcoredbg executable.")
  (defvar project-netcoredbg-log "d:/source/emacs-30.1/bin/netcoredbg/netcoredbg.log"
    "Path to netcoredbg log file.")
  (defvar project-project-root "d:/source/PROJECT"
    "Root directory of PROJECT project.")
  (defvar project-build-config "Debug"
    "Build configuration (Debug or Release).")
  (defvar project-target-arch "x64"
    "Target architecture (x64, x86, or AnyCPU).")

  ;; Helper function to create component configs
  (defun project-dape-config (component-name dll-name &optional stop-at-entry)
    "Create a dape configuration for a component.
COMPONENT-NAME is the component directory name
DLL-NAME is the DLL filename without extension.
STOP-AT-ENTRY if non-nil, stops at program entry point."
    (let* ((component-dir (format "%s/%s" project-project-root component-name))
           (bin-path (format "%s/bin/%s/%s/net9.0"
                             component-dir
                             project-target-arch
                             project-build-config))
           (dll-path (format "%s/%s.dll" bin-path dll-name))
           (config-name (intern (format "netcoredbg-launch-%s" 
                                        (downcase component-name)))))
      `(,config-name
        modes (csharp-mode csharp-ts-mode)
        command ,project-netcoredbg-path
        command-args (,(format "--interpreter=vscode")
                      ,(format "--engineLogging=%s" project-netcoredbg-log))
        normalize-path-separator 'windows
        :type "coreclr"
        :request "launch"
        :program ,dll-path
        :cwd ,component-dir
        :console "externalTerminal"
        :internalConsoleOptions "neverOpen"
        :suppressJITOptimizations t
        :requireExactSource nil
        :justMyCode t
        :stopAtEntry ,(if stop-at-entry t :json-false))))

  ;; Register all component configurations
  (dolist (config (list
                   (project-dape-config "DM" "DM.MSS" t)
                   (project-dape-config "Demo" "Demo.MSS" t)
                   (project-dape-config "Test_001" "Test" t)))
    (add-to-list 'dape-configs config))
  
  ;; Set buffer arrangement and other options
  (setq dape-buffer-window-arrangement 'gud)
  (setq dape-debug t)
  (setq dape-repl-echo-shell-output t))
#+end_src

Now you can start debugging with =M-x dape= and selecting your configuration.

** Step 4: Installing Supporting Tools

*** Portable Git

1. Download =PortableGit-2.50.0-64-bit.7z.exe= from [[https://git-scm.com/download/win][git-scm.com]]
2. Run and extract to =D:\source\emacs-30.1\bin\PortableGit\=

This gives you =git.exe=, =bash.exe=, and a whole Unix-like environment.

*** ripgrep (Fast Searching)

1. Download from [[https://github.com/BurntSushi/ripgrep/releases][ripgrep releases]]
2. Extract =rg.exe= to =D:\source\emacs-30.1\bin\find\=

ripgrep is dramatically faster than grep for searching codebases.

*** Hunspell (Spell Checking)

1. Download =hunspell-1.3.2-3-w32-bin.zip=
2. Extract to =D:\source\emacs-30.1\bin\hunspell\=
3. Download dictionary files (=en_GB.dic= and =en_GB.aff=) and place in =hunspell\share\hunspell\=

*** ImageMagick (Image Processing)

1. Download the portable Q16 x64 version from [[https://imagemagick.org/script/download.php][imagemagick.org]]
2. Extract to =D:\source\emacs-30.1\bin\ImageMagick-7.1.2-9-portable-Q16-x64\=

This enables =image-dired= thumbnail generation.

*** FFmpeg (Video Processing)

1. Download from [[https://ffmpeg.org/download.html][ffmpeg.org]] (essentials build is fine)
2. Extract to =D:\source\emacs-30.1\bin\ffmpeg-7.1.1-essentials_build\=

Useful for video thumbnails in dired and media processing.

** Step 5: Configuring the PATH

This is crucial—Emacs needs to find all these tools. Here's the PATH configuration from my =init.el=:

#+begin_src emacs-lisp
(when (eq system-type 'windows-nt)
  (let* ((emacs-bin "d:/source/emacs-30.1/bin")
         (xPaths
          `(,emacs-bin
            ,(concat emacs-bin "/PortableGit/bin")
            ,(concat emacs-bin "/PortableGit/usr/bin")
            ,(concat emacs-bin "/hunspell/bin")
            ,(concat emacs-bin "/find")
            ,(concat emacs-bin "/netcoredbg")
            ,(concat emacs-bin "/csharp-ls/tools/net9.0/any")
            ,(concat emacs-bin "/ffmpeg-7.1.1-essentials_build/bin")
            ,(concat emacs-bin "/ImageMagick-7.1.2-9-portable-Q16-x64")))
         (winPaths (getenv "PATH")))
    (setenv "PATH" (concat (mapconcat 'identity xPaths ";") ";" winPaths))
    (setq exec-path (append xPaths (parse-colon-path winPaths)))))
#+end_src

** Step 6: Installing Emacs Packages

Extract these to a shared location or download from MELPA

| Package                   | Purpose                       |
|---------------------------+-------------------------------|
| corfu                     | Modern completion UI          |
| dape                      | Debug Adapter Protocol client |
| highlight-indent-guides   | Visual indentation guides     |
| ztree                     | Directory tree comparison     |
| web-mode                  | Web template editing          |

Example package configuration:

#+begin_src emacs-lisp
(use-package corfu
  :load-path "z:/SharedVM/source/corfu-main"
  :custom
  (corfu-auto nil)         ; Manual completion trigger
  (corfu-cycle t)          ; Cycle through candidates
  (corfu-preselect 'first))

(use-package ztree
  :load-path "z:/SharedVM/source/ztree"
  :config
  (setq ztree-diff-filter-list
        '("build" "\\.dll" "\\.git" "bin" "obj"))
  (global-set-key (kbd "C-c z d") 'ztree-diff))

(use-package web-mode
  :load-path "z:/SharedVM/source/web-mode-master"
  :mode "\\.cshtml?\\'"
  :hook (html-mode . web-mode)
  :bind (:map web-mode-map ("M-;" . nil)))
#+end_src

Note that I turn off autocomplete for corfu and complete using =complete-symbol= manually, otherwise the LSP is constantly accessed with slowdown.

I often use =Meld= but am currently am looking to adapt =ztree= to perform better for directory comparisons.

Web-mode is the best package I have found for html type file navigation and folding, very useful when developing Razor pages for example.

** Step 7: auto open file modes

Of course running and building in windows means in Emacs probably having to open .csproj files from time to time, well =nxml-mode= comes in useful for this:

#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.csproj\\'" . nxml-mode))
#+end_src

** Step 8: build script

Here is my general build script, leveraging msbuild and running generally from =eshell=

New projects are added to :

#+begin_src bat
set PROJECTS
set PROJECT_NAMES
#+end_src

#+begin_src bat
@echo off
setlocal

REM =================================================================
REM Build Management Script
REM =================================================================
REM Usage: build-selected.bat [action] [verbosity] [configuration] [platform]
REM   action: build, clean, restore, rebuild (default: build)
REM   verbosity: quiet, minimal, normal, detailed, diagnostic (default: minimal)
REM   configuration: Debug, Release (default: Debug)
REM   platform: x64, x86, "Any CPU" (default: x64)
REM =================================================================

REM Set defaults
set ACTION=%1
set VERBOSITY=%2
set CONFIGURATION=%3
set PLATFORM=%4

if "%ACTION%"=="" set ACTION=build
if "%VERBOSITY%"=="" set VERBOSITY=minimal
if "%CONFIGURATION%"=="" set CONFIGURATION=Debug
if "%PLATFORM%"=="" set PLATFORM=x64

echo Build Script - Action=%ACTION%, Verbosity=%VERBOSITY%, Config=%CONFIGURATION%, Platform=%PLATFORM%
echo.

REM Common build parameters
set BUILD_PARAMS=/p:Configuration=%CONFIGURATION% /p:Platform="%PLATFORM%" /verbosity:%VERBOSITY%

REM Set MSBuild target based on action
if /I "%ACTION%"=="build" set TARGET=Build
if /I "%ACTION%"=="clean" set TARGET=Clean
if /I "%ACTION%"=="restore" set TARGET=Restore
if /I "%ACTION%"=="rebuild" set TARGET=Rebuild

if "%TARGET%"=="" (
    echo Error: Invalid action '%ACTION%'. Use: build, clean, restore, or rebuild
    exit /b 1
)

echo Executing %ACTION% action...
echo.

set PROJECTS[1]=Demo/Demo.csproj
set PROJECT_NAMES[1]=Demo

set PROJECTS[2]=Test/Test.csproj
set PROJECT_NAMES[2]=Test

set PROJECT_COUNT=2

REM Special handling for rebuild (clean then build)
if /I "%ACTION%"=="rebuild" (
    echo === CLEANING PHASE ===
    for /L %%i in (1,1,%PROJECT_COUNT%) do (
        call :process_project %%i Clean
        if errorlevel 1 goto :error
    )
    echo.
    echo === BUILDING PHASE ===
    set TARGET=Build
)

REM Process all active projects
for /L %%i in (1,1,%PROJECT_COUNT%) do (
    call :process_project %%i %TARGET%
    if errorlevel 1 goto :error
)

echo.
if /I "%ACTION%"=="clean" (
    echo All selected components cleaned successfully!
) else if /I "%ACTION%"=="restore" (
    echo All selected components restored successfully!
) else if /I "%ACTION%"=="rebuild" (
    echo All selected components rebuilt successfully!
) else (
    echo All selected components built successfully!
)
goto :end

:process_project
    setlocal EnableDelayedExpansion
    set idx=%1
    set target=%2
    
    REM Get project path and name using the index
    for /f "tokens=2 delims==" %%a in ('set PROJECTS[%idx%] 2^>nul') do set PROJECT_PATH=%%a
    for /f "tokens=2 delims==" %%a in ('set PROJECT_NAMES[%idx%] 2^>nul') do set PROJECT_NAME=%%a
    
    if "!PROJECT_PATH!"=="" goto :eof

    echo ----------------------------------------
    echo [%idx%/%PROJECT_COUNT%] %target%ing !PROJECT_NAME!...

    REM Build the project normally
    msbuild "!PROJECT_PATH!" /t:%target% %BUILD_PARAMS%
    if errorlevel 1 exit /b 1
    
goto :eof

:error
echo.
echo %ACTION% failed! Check the output above for errors.
exit /b 1

:end
echo %ACTION% completed at %time%
#+end_src

to launch applications of course, if it is a pure DOTNET project you would use =dotnet run=

** Troubleshooting

*** "Cannot find csharp-ls" or Eglot won't start

1. Check the PATH: =M-x getenv RET PATH=
2. Verify the DLL exists at the configured location
3. Try running manually: =dotnet path\to\CSharpLanguageServer.dll --version=
4. Check =*eglot-events*= buffer for detailed error messages

*** LSP is slow or uses too much memory

Try adding to your configuration:

#+begin_src emacs-lisp
;; Increase garbage collection threshold during LSP operations
(setq gc-cons-threshold 100000000)  ; 100MB
(setq read-process-output-max (* 1024 1024))  ; 1MB
#+end_src

*** Debugger won't attach

1. Ensure the project is built in Debug configuration
2. Check the DLL path matches your build output
3. Look at =*dape-repl*= for error messages
4. Verify netcoredbg runs: =netcoredbg.exe --version=

** Conclusion

This setup has served me well for my windows .NET 9.0 projects and various other C# work. The key benefits:

- *Portability*: Everything lives in one directory
- *Speed*: csharp-ls is notably faster than OmniSharp
- *Flexibility*: Easy to customise and extend
- *Offline-capable*: Works in air-gapped environments

The initial setup takes some effort, but once it's done, you have a powerful, consistent development environment that travels with you.

* DONE Expanding Ollama Buddy: Mistral Codestral Integration :ollama_buddy:llm:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20251211081935-emacs--Expanding-Ollama-Buddy-Mistral-Codestral-Integration
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-12-11 08:19>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions_001.jpg
:END:

Ollama Buddy now supports Mistral's Codestral - a powerful code-generation model from Mistral AI that seamlessly integrates into the ollama-buddy ecosystem.

#+hugo: more

https://github.com/captainflasmr/ollama-buddy

https://melpa.org/#/ollama-buddy

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions_001.jpg]]

So now we have:

- *Local Ollama models* — full control, complete privacy
- *OpenAI* — extensive model options and API maturity
- *Claude* — reasoning and complex analysis
- *Gemini* — multimodal capabilities
- *Grok* — advanced reasoning models
- *Codestral* — specialized code generation *NEW*

To get up and running...

First, sign up at [[https://console.mistral.ai/][Mistral AI]] and generate an API key from your dashboard.

Add this to your Emacs configuration:

#+begin_src elisp
(use-package ollama-buddy
  :bind
  ("C-c o" . ollama-buddy-menu)
  ("C-c O" . ollama-buddy-transient-menu-wrapper)
  :custom
  (ollama-buddy-codestral-api-key
   (auth-source-pick-first-password :host "ollama-buddy-codestral" :user "apikey"))
  :config
  (require 'ollama-buddy-codestral nil t))
#+end_src

Once configured, Codestral models will appear in your model list with an =s:= prefix (e.g., =s:codestral-latest=). You can:

- Select it from the model menu (=C-c m=)
- Use it with any command that supports model selection
- Switch between local and cloud models on-the-fly
* DONE Convert copied jira kanban to org (jira-to-org) :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20251128145610-emacs--jira-to-org
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-11-28 14:56>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20251128145610-emacs--jira-to-org.jpg
:END:
I have been fiddling around with some very rudimentary Jira integration to org, basically something very simple, just a regular copy from the kanban and then convert into org headlines!

This package is designed for simpler workflows where you copy data from Jira rather than maintaining API integration.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20251128145610-emacs--jira-to-org.jpg]]

Here is a link to the package:

https://github.com/captainflasmr/jira-to-org

** Overview

=jira-to-org= is an Emacs package that converts Jira sprint board data into org-mode task entries. It parses text copied directly from Jira sprint boards and transforms it into properly formatted org-mode headings with TODO keywords, priorities, tags, and metadata.

** Features

- Parse Jira sprint data from buffers, regions, or clipboard
- Convert Jira statuses to org-mode TODO keywords
- Map Jira priorities to org-mode priorities (A/B/C)
- Generate tags from assignees, sprint identifiers, and years
- Update existing org entries based on fresh Jira data
- Customizable mappings for assignees, priorities, and statuses
- Configurable heading levels and default values

** Installation

*** Manual Installation

1. Download =jira-to-org.el= to your Emacs configuration directory
2. Add to your =init.el=:

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/path/to/jira-to-org/")
(require 'jira-to-org)
#+END_SRC

*** Using =use-package=

#+BEGIN_SRC emacs-lisp
(use-package jira-to-org
  :load-path "/path/to/jira-to-org/"
  :custom
  (jira-to-org-default-sprint "s7")
  (jira-to-org-default-year "2025")
  (jira-to-org-heading-level 4))
#+END_SRC

** Usage

*** Basic Workflow

1. Open your Jira sprint board in a web browser
2. Select and copy the sprint data (the entire board or specific columns)
3. In Emacs, use one of the parsing commands

*** Commands

**** =jira-to-org-parse-buffer=

Parse the entire current buffer as Jira data. The result is copied to the kill ring.

#+BEGIN_SRC bash
M-x jira-to-org-parse-buffer
#+END_SRC

With prefix argument (=C-u=), prompts for a sprint tag:

#+BEGIN_SRC bash
C-u M-x jira-to-org-parse-buffer
Sprint tag (e.g., s7): s8
#+END_SRC

**** =jira-to-org-parse-region=

Parse Jira data in the selected region. The result is copied to the kill ring.

#+BEGIN_SRC bash
1. Select region containing Jira data
2. M-x jira-to-org-parse-region
#+END_SRC

**** =jira-to-org-parse-and-insert=

Parse Jira data from the clipboard and insert the org headings at point.

#+BEGIN_SRC bash
1. Copy Jira data to clipboard
2. Position cursor where you want entries inserted
3. M-x jira-to-org-parse-and-insert
#+END_SRC

**** =jira-to-org-update-from-jira=

Update existing org entries based on fresh Jira data. This command:
- Updates TODO statuses for entries that already exist in your buffer
- Reports how many entries were updated
- Copies new items (not found in buffer) to the kill ring

#+BEGIN_SRC bash
M-x jira-to-org-update-from-jira
#+END_SRC

*** Example Input Format

The package expects text copied from Jira sprint boards in this format:

#+BEGIN_EXAMPLE
To Do
MM-78
Implement IG connection management APIs
Assignee: James Dyer
Priority: Medium
Issue Type: Story
2

In Progress
MM-79
Create gRPC service definition
Assignee: Freddy
Priority: High
3

Done
MM-75
Setup project structure
Assignee: N Cropper
Priority: Low
Issue Type: Task
1
#+END_EXAMPLE

*** Example Output

The above input would be converted to:

#+BEGIN_EXAMPLE
***** TODO [#B] MM-78 Implement IG connection management APIs :s7:jdyer:2025:
***** DOING [#A] MM-79 Create gRPC service definition :s7:freddy:2025:
***** DONE [#C] MM-75 Setup project structure :s7:ncropper:2025:
#+END_EXAMPLE

** Configuration

*** Customization Variables

**** =jira-to-org-default-sprint=

Default sprint tag to add to all entries (e.g., ="s7"=). If =nil=, no sprint tag is added.

#+BEGIN_SRC emacs-lisp
(setq jira-to-org-default-sprint "s7")
#+END_SRC

**** =jira-to-org-default-year=

Default year to add as a tag to all entries.

#+BEGIN_SRC emacs-lisp
(setq jira-to-org-default-year "2025")
#+END_SRC

**** =jira-to-org-assignee-map=

Alist mapping full names (as they appear in Jira) to short tag names.

#+BEGIN_SRC emacs-lisp
(setq jira-to-org-assignee-map
      '(("James Dyer" . "jdyer")
        ("Freddy" . "freddy")
        ("N Cropper" . "ncropper")))
#+END_SRC

**** =jira-to-org-priority-map=

Alist mapping Jira priority levels to org-mode priority letters.

#+BEGIN_SRC emacs-lisp
(setq jira-to-org-priority-map
      '(("Highest" . "A")
        ("High" . "A")
        ("Medium" . "B")
        ("Low" . "C")
        ("Lowest" . "C")))
#+END_SRC

**** =jira-to-org-status-map=

Alist mapping Jira status names to org-mode TODO keywords.

#+BEGIN_SRC emacs-lisp
(setq jira-to-org-status-map
      '(("To Do" . "TODO")
        ("In Progress" . "DOING")
        ("Done" . "DONE")))
#+END_SRC

**** =jira-to-org-heading-level=

Number of asterisks for generated org headings (default: 4).

#+BEGIN_SRC emacs-lisp
(setq jira-to-org-heading-level 3)  ; Use *** instead of ****
#+END_SRC

*** Complete Configuration Example

#+BEGIN_SRC emacs-lisp
(use-package jira-to-org
  :custom
  (jira-to-org-default-sprint "s8")
  (jira-to-org-default-year "2025")
  (jira-to-org-heading-level 4)
  (jira-to-org-assignee-map
   '(("James Dyer" . "jdyer")
     ("Freddy Johnson" . "freddy")
     ("Sarah Chen" . "schen")
     ("Mike Wilson" . "mwilson")))
  (jira-to-org-priority-map
   '(("Highest" . "A")
     ("High" . "A")
     ("Medium" . "B")
     ("Low" . "C")
     ("Lowest" . "C")))
  (jira-to-org-status-map
   '(("To Do" . "TODO")
     ("In Progress" . "DOING")
     ("In Review" . "REVIEW")
     ("Done" . "DONE")))
  :bind
  (:map org-mode-map
        ("C-c j p" . jira-to-org-parse-and-insert)
        ("C-c j u" . jira-to-org-update-from-jira)))
#+END_SRC

** Workflow Integration

*** Sprint Planning Workflow

1. Open your sprint planning org file
2. Navigate to the sprint section
3. Copy the Jira sprint board data
4. Run =M-x jira-to-org-parse-and-insert=
5. Adjust any entries as needed

*** Daily Standup Updates

1. Copy current sprint board state from Jira
2. Run =M-x jira-to-org-update-from-jira=
3. Review updated TODO states
4. Any new items are copied to kill ring for manual placement

*** Custom Key Bindings

#+BEGIN_SRC emacs-lisp
;; Add to your org-mode configuration
(with-eval-after-load 'org
  (define-key org-mode-map (kbd "C-c j p") #'jira-to-org-parse-and-insert)
  (define-key org-mode-map (kbd "C-c j r") #'jira-to-org-parse-region)
  (define-key org-mode-map (kbd "C-c j b") #'jira-to-org-parse-buffer)
  (define-key org-mode-map (kbd "C-c j u") #'jira-to-org-update-from-jira))
#+END_SRC

** Parsed Fields

The package extracts and uses the following fields from Jira data:

| Jira Field    | Usage                                  | Example        |
|---------------+----------------------------------------+----------------|
| Issue Key     | Included in heading                    | MM-78          |
| Title         | Included in heading                    | Fix bug in API |
| Status        | Converted to TODO keyword              | In Progress    |
| Assignee      | Converted to tag                       | James Dyer     |
| Priority      | Converted to org priority              | Medium         |
| Story Points  | Extracted (not currently used in output) | 3              |

** Customizing for Your Organization

*** Adjusting Issue Key Pattern

If your Jira instance uses a different project key pattern, modify the regex in =jira-to-org--parse-buffer-to-items=:

#+BEGIN_SRC emacs-lisp
;; Current pattern matches MM-123
((string-match "^\\(MM-[0-9]+\\)$" line)

;; Example: Match PROJECT-123
((string-match "^\\(PROJECT-[0-9]+\\)$" line)

;; Example: Match multiple projects (PROJ1-123 or PROJ2-123)
((string-match "^\\(\\(?:PROJ1\\|PROJ2\\)-[0-9]+\\)$" line)
#+END_SRC

*** Adding Custom Status Mappings

If your Jira workflow has additional statuses:

#+BEGIN_SRC emacs-lisp
(setq jira-to-org-status-map
      '(("To Do" . "TODO")
        ("In Progress" . "DOING")
        ("Code Review" . "REVIEW")
        ("QA Testing" . "TESTING")
        ("Blocked" . "BLOCKED")
        ("Done" . "DONE")))
#+END_SRC

Make sure your org-mode TODO keywords match:

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO" "DOING" "REVIEW" "TESTING" "BLOCKED" "|" "DONE")))
#+END_SRC

** Troubleshooting

*** No Items Parsed

- Verify the Jira data format matches the expected structure
- Check that issue keys match the pattern (e.g., =MM-123=)
- Ensure status headers (To Do, In Progress, Done) are present

*** Wrong Assignee Tags

- Check =jira-to-org-assignee-map= contains mappings for all team members
- Verify exact spelling of names in Jira matches the mapping

*** Incorrect TODO Keywords

- Verify =jira-to-org-status-map= maps all statuses used in your Jira
- Check that target TODO keywords exist in =org-todo-keywords=

*** Entries Not Found During Update

- Ensure issue keys in org file exactly match Jira format
- Verify the heading contains the issue key followed by a space

** API Functions

For programmatic use:

*** =jira-to-org-parse-string=

#+BEGIN_SRC emacs-lisp
(jira-to-org-parse-string STRING &optional SPRINT)
#+END_SRC

Parse STRING containing Jira data and return org-mode headings as a string.

*** =jira-to-org--parse-buffer-to-items=

#+BEGIN_SRC emacs-lisp
(jira-to-org--parse-buffer-to-items BUFFER-OR-STRING)
#+END_SRC

Parse Jira data into a list of =jira-to-org-item= structs for further processing.

*** =jira-to-org--item-to-org-heading=

#+BEGIN_SRC emacs-lisp
(jira-to-org--item-to-org-heading ITEM &optional SPRINT)
#+END_SRC

Convert a =jira-to-org-item= struct to an org-mode heading string.

** Contributing

Contributions are welcome! Please submit issues or pull requests on the project repository.

*** Development Setup

1. Clone the repository
2. Load =jira-to-org.el= in Emacs
3. Make changes and test with sample Jira data
4. Run byte-compilation: =M-x byte-compile-file=

*** Testing

Create a test file with sample Jira data and verify parsing:

#+BEGIN_SRC emacs-lisp
(with-temp-buffer
  (insert "To Do\nMM-1\nTest Issue\nAssignee: Test User\nPriority: High\n")
  (jira-to-org-parse-buffer))
#+END_SRC

** License

This package is provided as-is for personal and professional use.

** Changelog

*** Version 1.0
- Initial release
- Basic parsing of Jira sprint data
- Configurable mappings for assignees, priorities, and statuses
- Buffer, region, and clipboard parsing commands
- Update existing entries from fresh Jira data

** Related Packages

- [[https://github.com/ahungry/org-jira][org-jira]] - Full bidirectional sync with Jira (requires API access)
- [[https://github.com/nyyManni/jiralib2][jiralib2]] - Jira REST API library for Emacs
- [[https://github.com/baohaojun/org-jira][org-jira (baohaojun)]] - Alternative Jira integration

* DONE The Ping Localhost Hack for Emacs Shell on Windows :ping:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20251101152419-emacs--The-Ping-Localhost-Hack-for-Emacs-Shell-on-Windows
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-11-01 15:24>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20251101152419-emacs--The-Ping-Localhost-Hack-for-Emacs-Shell-on-Windows.jpg
:END:

For a little while now, I've been developing software that needs to run on Windows (I know, I know!) and occasionally firing up batch scripts from within Emacs shell. Everything was working perfectly until I needed to add a simple delay between commands. That's when I discovered one of Windows batch scripting's more peculiar quirks.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20251101152419-emacs--The-Ping-Localhost-Hack-for-Emacs-Shell-on-Windows.jpg]]

The obvious solution for adding a delay in a Windows batch script is the =timeout= command:

#+begin_src batch
timeout /T 5
#+end_src

Simple enough, right? Well, it turns out that when you run this from Emacs shell (or any non-interactive environment), it just... doesn't work. The script either hangs indefinitely or skips the timeout entirely. Even adding the =/NOBREAK= flag doesn't reliably solve the issue.

The =timeout= command is actually an interactive program that expects to interact with a proper Windows console. It's designed to wait for user input OR timeout, whichever comes first. When running from Emacs shell:

- There's no proper console attachment that =timeout= can latch onto
- Input redirection gets confused
- The TTY limitations of Emacs shell mean =timeout= can't find what it's looking for

This is particularly frustrating when you've got a perfectly good batch script that works fine from cmd.exe but fails spectacularly when launched from your beloved Emacs environment.

Here's where things get interesting (and slightly ridiculous). The solution that the Windows community by all accounts has rallied around is the =ping= command:

#+begin_src batch
ping 127.0.0.1 -n 6 > nul
#+end_src

So here we are using a network diagnostic tool as a timer. But it works brilliantly! Here's why:

- =ping= is completely non-interactive - it just runs and exits
- Each ping takes roughly 1 second by default
- The =-n= flag specifies the number of pings, so =-n 6= gives you approximately 5 seconds (n-1)
- It's available on every Windows system, no exceptions
- It doesn't care about console attachment, TTY setup, or any of that nonsense

In my batch scripts that launch from Emacs, I've settled on this pattern:

#+begin_src batch
@echo off
echo Starting process...
ping 127.0.0.1 -n 3 > nul
echo Continuing after 2 second delay...
#+end_src

The => nul= redirects all the ping output to nowhere, so you don't see the typical ping response spam in your output. Clean, simple, and most importantly - it actually works!

This whole situation is a perfect example of the kind of head-scratching workarounds you encounter when working across different environments. Emacs shell on Windows is already operating in a slightly weird space - it's not quite a native Windows console, not quite a Unix-like shell, but something in between.

After adding this to my batch scripts, everything now runs smoothly from Emacs shell on Windows. The software launches, pauses where it needs to, and continues without any console-related tantrums.

Is it elegant? Not particularly. Is it a proper use of the ping command? Absolutely not. Does it work perfectly every single time? You bet it does!

And really, isn't that the most important thing? Sometimes the best solution isn't the most theoretically pure one - it's the one that just works, regardless of how strange it might look to an outsider.

* DONE Planning my Weekly Meals in Emacs! :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250926100543-emacs--Planning-my-Weekly-meals-in-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-09-26 10:05>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250926100543-emacs--Planning-my-Weekly-meals-in-Emacs.jpg
:END:

And what have I been working on recently?, well lets consider the following questions...

- What should we eat Monday through Friday?
- What about the weekend when we have more time to cook?
- Didn't we just have pasta last week? And the week before?
- How do I plan for batch cooking without ending up with the same meal rotation?
- Where did I put that list of meal ideas again?

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250926100543-emacs--Planning-my-Weekly-meals-in-Emacs.jpg]]

And what has all this to do with Emacs I hear to you say?, well as some of you might have guessed I thought I would let Emacs take the stress out of these types of decisions by writing a very simple meal planning package and instead of trying to be everything to everyone I have just decided to focus it on solving one specific problem: *generating varied weekly meal plans that support batch cooking workflows*.

Here is a link to the package : https://github.com/captainflasmr/meal-planner

Here's how it works:

Your meals are stored in simple text files, one meal per line:

#+begin_src bash
Chicken curry
Pizza
Lasagna
Toad in the hole
Chilli con carne
Sausage bake
Pasta bake
#+end_src

and one file per category (which I shall explain later)

#+begin_src bash
weekday-dinner.txt
weekday-lunch.txt
weekday-pudding.txt
weekday-sweet.txt
weekend-dessert.txt
weekend-dinner.txt
weekend-lunch.txt
#+end_src

Need to add a new meal? Just edit the text file. Want to remove something you're tired of? delete the line and who knows, maybe for fun, add these files to your favourite Emacs LLM integration, gptel of course or my personal favourite (as I wrote it) https://github.com/captainflasmr/ollama-buddy and see what myriad of fantastical foods it can add!

I have simplified the whole concept as much as possible, so instead of planning individual meals for each day (which gets repetitive and tiresome), it recognizes that many of us batch cook, so:

- *Weekdays (Monday-Friday)*: One set of meals for the entire week
- *Weekend (Saturday-Sunday)*: A different set of meals for more relaxed cooking and possibly straight from the freezer!

When you run =M-x meal-planner-generate-week=, you will get something like:

#+begin_src bash
=== MEAL PLAN - Week 42 ===

WEEKDAYS (Monday-Friday):
  Weekday lunch: Chicken curry batch
  Weekday sweet: Apple slices  
  Weekday dinner: Pasta bake
  Weekday pudding: Jam sponge

WEEKEND (Saturday-Sunday):
  Weekend lunch: Omelette
  Weekend dinner: Beef stew
  Weekend dessert: Eton mess
#+end_src

Also the package automatically tracks what you've eaten in recent weeks and avoids suggesting the same combinations. No more "didn't we just have this last week?" moments.

The package supports different types of meals to match my current real-world eating patterns:

*Weekday Categories:*

- Lunch meals (lunchbox-friendly)
- Sweet snacks/desserts
- Main dinner meals
- Evening puddings/desserts

*Weekend Categories:*

- Leisurely lunch meals
- Weekend dinner meals  
- Weekend desserts

Here's how meal-planner.el fits into our weekly routine:

*Sunday Morning*: Run =M-x meal-planner-generate-week= while having coffee. The package suggests a week's worth of meals, carefully avoiding anything we've had recently.

*Sunday Afternoon*: Use =M-x meal-planner-edit-category= to quickly add any new meal ideas we've discovered, or remove things we're temporarily tired of.

*Shopping*: The meal plan gives us a clear shopping list foundation for when we do our weekly online order.

*Weekday Evenings*: No decisions needed! We already know what we're having, and the ingredients are ready to go!

Installation is straightforward:

#+begin_src elisp
;; Add to your init.el
(require 'meal-planner)
#+end_src

Then run the setup command to create sample meal files:

#+begin_src elisp
M-x meal-planner-setup-data-files
#+end_src

This creates a =~/.emacs.d/meal-data/= directory with sample meals for each category. Edit these files to match your preferences, then generate your first meal plan:

#+begin_src elisp
M-x meal-planner-generate-week
#+end_src

This package embodies one aspect I love about Emacs, taking a real-world problem and solving it in an elegant, customizable way. Now my brain has a little more space to accommodate more Emacs rabbit holes!

* DONE Customizing Emacs Completion: From Fido's Fuzzy Matching to Literal Substring :fido:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250905100614-emacs--Customizing-Emacs-Completion:-From-Fido's-Fuzzy-Matching-to-Literal-Substring-Search
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-09-05 10:06>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250905100614-emacs--Customizing-Emacs-Completion:-From-Fido's-Fuzzy-Matching-to-Literal-Substring-Search.jpg
:END:

For my completion framework, I'm currently using =fido-mode=, and more recently, =fido-vertical-mode=. However, I'm scratching yet another itch in my ongoing quest to be more efficient in Emacs, specifically to jump to files more quickly. I explored this in a previous post where I enhanced the =recentf= functionality to work through completing-read in a predictable order, but what about the completing-read interface itself?

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250905100614-emacs--Customizing-Emacs-Completion:-From-Fido's-Fuzzy-Matching-to-Literal-Substring-Search.jpg]]

This happens to me often in Emacs, there is a subconscious functional annoyance which eventually bubbles to the surface and this case the surface bubble revolves around fido's fuzzy matching behaviour.  Simply put, I don't like it!

While it can be helpful for discovering files and commands you partially remember, sometimes you know exactly what you're looking for and want a more literal, predictable search experience, in fact for me now, I would say it is not just sometimes, but always!. The fuzzy matching is finding too many candidates when I type in a few characters and really I want a contiguous input string to be literally matched.

This post chronicles my journey from fido's flex matching to a custom setup that provides literal substring matching, perfect for when you know what you want and just want to type it directly.

Hang on a sec, can't I just change the completion style?, this should be easy!

#+begin_src elisp
(setq completion-styles '(substring basic))
#+end_src

But that has no effect!, boooo!

Anyways, that was a quick attempt at a fix, in the meantime lets explore flex a little bit more and =icomplete= (which is the underpinning completion technology of fido) and see if we cam come up with a robust solution.

Fido-mode use what's called "flex" completion by default. This means that when you type =abc=, it will match files like =a_long_b_filename_c.txt= because it finds the letters a, b, and c in that order, even with other characters between them.

While this flexibility is powerful, it can be frustrating when you want to search for a specific substring. If you're looking for a file named =project-abc-config.txt=, you might expect typing =abc= to prioritize that match, but flex matching might show you =a_big_collection.txt= first instead.

So back to my initial attempt at a fix by setting the =completion-styles= variable. The =substring= style matches your input as a contiguous block anywhere within candidates, while =basic= does prefix matching. This seemed like exactly what I wanted, I just need to find a way to set it and to make it stick.

After some digging into the source code, I found the culprit in =icomplete.el=. The =icomplete--fido-mode-setup= function contains the following:

#+begin_src elisp
(defun icomplete--fido-mode-setup ()
  "Setup `fido-mode''s minibuffer."
  (when (and icomplete-mode (icomplete-simple-completing-p))
    ;; ... other settings ...
    (setq-local completion-styles '(flex)  ; This line forces flex!
                completion-flex-nospace nil
                ;; ... more settings ...
                )))
#+end_src

This function runs every time you enter the minibuffer, forcibly overriding any =completion-styles= setting you might have configured. This explains why my =setq= had no effect, fido was resetting it on every use!

Rather than fight fido's opinionated behaviour, I could instead switch to =icomplete-vertical-mode=, which provides a similar interface but respects the standard completion configuration.

#+begin_src elisp
(icomplete-vertical-mode 1)

;; scroll list rather than rotating
(setq icomplete-scroll t)

;; Make completion case-insensitive
(setq completion-ignore-case t)
(setq read-file-name-completion-ignore-case t)
(setq read-buffer-completion-ignore-case t)

(with-eval-after-load 'icomplete
  (setq completion-styles '(substring basic partial-completion emacs22)))
#+end_src

This gave me the literal substring matching I wanted and I think I have managed to set up everything else to the way fido comes out of the box.

However, there was one more hurdle.

By default, =icomplete-vertical-mode= requires you to explicitly select a completion before submitting with =C-m= (Enter) which is a keybinding I had grown accustomed to using in fido. This adds an extra confirmation step that fido-mode doesn't have.  There is a way around this however and that is to adapt to the keybinding =C-j= which typically is more of a do literal action then exit type of thing, where C-m is more of just a simple Enter/action.  I am willing to adapt to this keybinding.

So this works pretty well for me really, but can I not just get =completion-styles= to stick for fido?, even though I have a solution I really want to see if I can adjust fido's default functionality.

Well simply I used an advice function to wrap around the original fido setup function and set up the =completion-styles= local variable after fido has done its thing:

#+begin_src elisp
(defun my-fido-completion-styles-advice (&rest _args)
  "Override completion styles after fido setup."
  (when (and fido-mode (icomplete-simple-completing-p))
    (setq-local completion-styles '(substring basic partial-completion))))

(advice-add 'icomplete--fido-mode-setup :after #'my-fido-completion-styles-advice)
#+end_src

Now I have two options for using completion in Emacs the way I want it and now I can find files, or anything else for that matter much more quickly.

This journey taught me several important lessons about Emacs customization:

1. *Read the source*: When configuration variables don't seem to work as expected, the source code often reveals why.

2. *Local vs. global settings*: Fido uses =setq-local= to override settings per-buffer, which is why global =setq= calls don't work.

3. *There's always another way*: Emacs' flexibility means there are usually multiple approaches to achieving the same goal.

While fido-mode's fuzzy matching is excellent for discovery and exploration, I just wanted the predictability of literal substring matching and with a small advice function, you can have the best of both worlds!

* DONE Debugging Software Breakage with Git Stash and Emacs :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250826103741-emacs--Debugging-Software-Breakage-with-Git-Stash-and-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-09-10 08:00> 
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250826103741-emacs--Debugging-Software-Breakage-with-Git-Stash-and-Emacs.jpg
:END:
We've all been there, your code was working perfectly from a clean checkout, but after making a bunch of changes across multiple files, something has broken. The dreaded question arises! which change caused the break? This is the story of how a debugging session led me to discover gaps in Emacs' VC mode and ultimately create a custom solution.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250826103741-emacs--Debugging-Software-Breakage-with-Git-Stash-and-Emacs.jpg]]

I started with a clean, working codebase. After implementing several features across different files, my software suddenly stopped working. The classic debugging nightmare, multiple changes, one (or more) breaking changes, and no clear path to the culprit.

My debugging strategy as always is methodical. Over many years of software engineering I have learnt that you just need to figure out a systematic approach and then just get on with it!

1. Start from the known-good base version
2. Gradually reintroduce changes from my working set
3. Test after each addition to identify the breaking point

Git stash turned out to be perfect for this workflow. Firstly I stashed all my changes, giving me a clean working directory to start from. My plan was to selectively apply portions of the stash, testing after each addition.

Using Emacs' built-in VC mode, I could use =vc-git-stash-show= to display my stashed changes in a diff buffer. From there, I could navigate through the files and selectively apply hunks using Emacs' diff mode commands. This gave me fine-grained control over which changes to reintroduce.

As I progressed through applying changes, I realised that I would really like to keep an eye on what changes remained in my stash compared to my current working directory, basically like a dynamic diff to be regenerated after each application (like typically on an individual file using ediff). This would allow me to keep an eye on likely culprits as I move through the hunking process.

In pure Git, this is straightforward:

#+begin_src bash
git diff stash@{0}
#+end_src

But Emacs' VC mode doesn't provide a command for this specific operation (I have found this not to be uncommon for Emacs vc-mode, but I still like it anyways!)

Generally I think, Emacs' VC interface is designed to be VCS agnostic, which is both a strength and a limitation. While it provides excellent abstractions for common operations like =vc-diff=, it doesn't expose Git specific features like comparing against stash references.

The available VC commands were:

- =vc-diff= - compares working directory with HEAD or between revisions  
- =vc-git-stash-show= - shows the diff of a stash
  
But no "diff working directory against stash" command

Now, it's worth noting that Magit, does apparently provide this functionality, but I prefer to run on air-gapped systems (yes, that again!) where installing external packages isn't always practical or desired. In such environments, I lean heavily on Emacs' built-in functionality and augment it with custom elisp when needed which is probably something I suspect I am likely to do in this case.

I had an initial eshell idea on how to accomplish this!, for example you can redirect command line output to Emacs buffers using the =#<buffer name>= syntax, so lets try that!

I tried:

#+begin_src bash
git diff stash@{0} > #<buffer *git-diff*> && diff-mode
#+end_src

This almost worked, but I encountered a timer error related to eshell's command chaining.

and then I tried:

#+begin_src bash
git diff stash@{0} > #<buffer *git-stash-diff*> ; diff-mode
#+end_src

After some experimentation, I still couldn't quite get eshell to generate a buffer from a command and then initiate a mode.  Of course I could just jump to the buffer and run it myself, but generally I wanted a solution to be easily repeatable.

Right, lets scrap the eshell idea and lets fall back on my tried and tested method of writing a defun in elisp!:

#+begin_src elisp
(defun my-git-diff-stash (stash-ref)
  "Diff working directory against specified stash"
  (interactive "sStash reference (e.g., 0, 1, 2): ")
  (let ((buffer (get-buffer-create "*git-stash-diff*")))
    (with-current-buffer buffer
      (erase-buffer)
      (call-process "git" nil buffer t "diff" (format "stash@{%s}" stash-ref))
      (diff-mode)
      (goto-char (point-min)))
    (switch-to-buffer buffer)))
#+end_src

This function:

- Prompts for a stash reference (defaulting to numeric input like 0, 1, 2)
- Creates a dedicated buffer for the diff
- Runs =git diff= against the specified stash
- Automatically applies =diff-mode= for syntax highlighting
- Opens the buffer and positions the cursor at the beginning

The final step was to bind this command to the VC prefix map:

#+begin_src elisp
(define-key vc-prefix-map (kbd "S") 'my-git-diff-stash)
#+end_src

"S" is currently used for a regex search of some kind which I currently don't understand and hence am not using.

Now I can use =C-x v S= to quickly diff my working directory against any stash (although who knows when I will need this again!)

With this in place, my debugging workflow became smoother

1. Stash all changes
2. Apply changes incrementally using =vc-git-stash-show=
3. Test the software after each addition
4. When it still works, check what remains =C-x v S=
5. Continue applying changes from the remaining diff
6. When it breaks, I have a good idea of the breaking issue

This experience taught me several valuable lessons:

1. *VC mode's limitations*: While Emacs' VC interface is excellent for common operations, specialized Git workflows sometimes require custom solutions.

2. *The value of built-in solutions*: Working in air-gapped environments has taught me to maximize Emacs' built-in capabilities before reaching for external packages. While Magit would have solved this problem out of the box, building the solution myself using VC mode and custom elisp keeps dependencies minimal and increases my understanding of both Git and Emacs internals.

3. *Eshell's power*: The ability to redirect command output directly to Emacs buffers is incredibly useful, even if it has some quirks with command chaining and in the end I never really got it to work, but it is in my brain more concretely now as this blog post now exists!

4. *Integration matters*: Binding custom functions to standard keymaps makes them feel like native features.

* DONE A Better Way to Indent Your Entire Buffer in Emacs? :emacs:elisp:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250826095622-emacs--A-Better-Way-to-Indent-Your-Entire-Buffer-in-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-08-26 09:56>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250826095622-emacs--A-Better-Way-to-Indent-Your-Entire-Buffer-in-Emacs.jpg
:END:

As an Emacs user, you've probably found yourself wanting to clean up the indentation of an entire file. The standard approach is to select all (=C-x h=) and then run =indent-region= (I think, correct me if I am wrong!), but this has an annoying side effect: it destroys your current mark position, which might have been carefully set for other operations.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250826095622-emacs--A-Better-Way-to-Indent-Your-Entire-Buffer-in-Emacs.jpg]]

Also, and just whisper it and don't tell anyone, but I have been using VSCode a little (only for work, of course!) and an indent by default seems to indent the whole file, which initially I thought would be really annoying, but actually it feels quite natural, as always at some point I would like to indent my code.

This is Emacs however and there is a simple solution and I've added it to my Emacs configuration:

So, just a recap on some typical workflow, it goes a little something like this:

1. You're working in a file with inconsistent indentation
2. You want to fix the entire buffer's formatting
3. You run =C-x h= (select all) followed by =M-x indent-region=
4. Your mark is now at the beginning of the buffer, disrupting your workflow

This is particularly frustrating when you've set a mark for a specific editing task and want to preserve that position.

#+begin_src elisp
(defun indent-whole-buffer ()
  "Indent the entire buffer without affecting point or mark."
  (interactive)
  (save-excursion
    (save-restriction
      (indent-region (point-min) (point-max)))))

(global-set-key (kbd "C-c i") 'indent-whole-buffer)
#+end_src

The function indents from =(point-min)= to =(point-max)=, covering the entire buffer, then restores everything to exactly how it was before, except now with proper indentation.

After adding this to your configuration, simply press =C-c i= (or whatever keybinding you prefer) to indent your entire buffer. Your cursor stays put, your mark remains set, and your file gets beautifully formatted!

* DONE Fast Recent File Navigation in Emacs :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250815071935-emacs--Fast-File-Navigation-in-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-08-16 19:07> 
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250815071935-emacs--Fast-File-Navigation-in-Emacs.jpg
:END:

As an Emacs user, you're always hunting for ways to shave milliseconds off common tasks and generally noodling around and shaving some more of that yak!. File switching is one of those operations you do hundreds of times a day, so even small improvements compound dramatically. Today, I want to share a workflow that I have been tinkering with that combines the best of Emacs's built-in recent file tracking with modern completion interfaces.

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250815071935-emacs--Fast-File-Navigation-in-Emacs.jpg]]

Emacs gives us several ways out of the box to quickly access files:

- find-file
- switch-to-buffer for open buffers  
- Registers
- Bookmarks
- recentf-mode for recently accessed files

and I have a funny feeling there are probably more.

Each has its place, but they all have limitations. switch-to-buffer only shows currently open buffers, and with fido-mode, I have found that the most frequently used buffers don't always bubble to the top predictably, I may need to look a little more into this though. Registers are great but require manual setup and only remember the position when you set them, not your last edit location.

What I really wanted was instant access to my recently edited files, with each file opening exactly where I left off!

I thought I had become quite efficient at file switching through fido completion and dired but only recently I realised I was navigating through dired to find files way too often and wasting time.  I think this is probably typical of an Emacsers journey and after a while of continuous minor toil there comes a time to take action and shave off those milliseconds and improve flow.

The solution starts by enabling two built-in  Emacs features:

#+begin_src elisp
(save-place-mode 1)
(recentf-mode 1)
(setq recentf-max-menu-items 10)
(setq recentf-max-saved-items 10)
#+end_src

save-place-mode automatically remembers your cursor position in every file and restores it when you reopen the file, it was the first time I had heard of this when figuring all this out and couldn't believe I didn't know about it before (not an uncommon Emacs experience), this works across Emacs sessions, so you get that "pick up exactly where I left off" experience.

And recentf-mode maintains a persistent list of recently visited files, ordered chronologically. Unlike switch-to-buffer, this survives Emacs restarts and gives you a true history of your work and I thought in this case it better to limit the list size as much as possible for greater clarity.

The traditional recentf-open-files command shows a nice ordered list in a buffer but to some it could feel clunky compared to modern completion interfaces.  There is also recentf-open which does go through completing read but then reorders the recentf list for some reason, so to me the obvious solution is to push the recent files list through completing-read myself:

#+begin_src elisp
(defun my/fido-recentf ()
  "Use fido to select from recently opened files."
  (interactive)
  (completing-read "Recent file: " recentf-list nil t nil 'recentf-list))
#+end_src

To get this to work the way I wanted, I had to supply recentf-list also as the last argument. By using the same symbol for both the collection and the history, we tell the completion system to respect the original ordering. Your most recently accessed files should stay at the top!

In my final solution I have decided to keep the old recentf-open-files interface as an option. Strangely I actually like the old list in a buffer interface so I have included it in my final version as an option.

#+begin_src elisp
(defun my/fido-recentf (arg)
  "Use fido to select from recently opened files.
With universal argument, use the traditional recentf-open-files interface."
  (interactive "P")
  (if arg
      (recentf-open-files)
    (find-file (completing-read "Recent file: " recentf-list nil t nil 'recentf-list))))
#+end_src

Now M-x my/fido-recentf gives you completing read, while C-u M-x my/fido-recentf drops you into the classic numbered list.

Bind this to something convenient (I use M-o) and your file navigation transforms! (well that might be a bit of an exaggeration)

This might seem like a small optimization, but it exemplifies what makes Emacs special. We're not just using the tools as shipped, we're composing them in novel ways to create something perfectly tailored to our needs.

That's the kind of workflow improvement that makes every day at the keyboard just a little bit more pleasant, and those small pleasures add up to something significant over months and years of coding.

* DONE View-Mode - Emacs's Hidden Modal Editing Gem? :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250731123820-emacs--Discovering-View-Mode-Emacss-Hidden-Modal-Editing-Gem
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-08-01 08:30>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250731123820-emacs--Discovering-View-Mode-Emacss-Hidden-Modal-Editing-Gem.jpg
:END:

---
#+TOC: headlines 1 local
---

** The Rabbit Hole

I've fallen down another rabbit hole, but then again, this is Emacs we're talking about!

In this case it relates to a fundamental editing principle.

I was trying to understand some code, so of course that involved plenty of point/cursor navigation, scrolling, etc. After an hour or so of doing this, I started to wonder if there was a more efficient navigation method involving single keypresses. If I know I only want to view the file, then why not get rid of this modifier key nonsense? 😁 I'm aware that the basic functionality I'm talking about here is modal editing.

There are many different packages out there from *boon* to *meow*. So does Emacs have something built-in? Well, throughout my series of blog posts, I often ask this question, and the answer always comes back emphatically the same: *"Why yes, of course it does!"* This might be a little misleading, as though there isn't a specific built-in that gives modal editing right out of the box, there is a mode that can be tweaked a little to achieve something similar.

** View Mode

So what is the thing that's been hiding in plain sight? Well, it is *view-mode*. Although strictly not a modal editing option, I think with a little tweaking I could possibly turn it into one. After a bit of internet stumbling, I came across a Reddit post from someone who has tried something similar. I think I shall add my own spin. The link is https://www.reddit.com/r/emacs/comments/fojc1y/using_viewmode_for_modal_navigation/

If you have been reading my posts over the years, you probably know my general design ethos on such a solution, and that is to use built-in Emacs-centric philosophies and to make sure it can easily be set up on an air-gapped system. Well, for this solution, I'm going to deviate slightly from this idiom and incorporate not just more Emacs-ish keybindings but also some Vim ones! My main reasoning for this is that evil-mode is very popular, and from time to time I have recourse to using Vim over ssh, and the ~jkhl~ setup does feel pretty natural.

View-mode has been part of Emacs forever, but its default keybindings feel a bit... antiquated. *z* and *w* for scroll up and down? Space for page scroll, Return for forward one line, etc. (Maybe it works in the latter case, as it is more of a legacy Unixy vibe, but really I think we should be using more Emacs-ish keybindings, and as an option, why not Vim ones, as they tend to be mutually exclusive)

** The Setup

Of course, view-mode is completely customizable, so here's my setup that combines the best of both worlds, familiar Emacs patterns and efficient Vim-style navigation:

#+begin_src elisp
;; Enable view-mode when entering read-only
(setq view-read-only t)

;; Enhanced keybindings
(with-eval-after-load 'view
  ;; More Emacs-ish keys

  ;; Navigation
  (define-key view-mode-map (kbd "n") 'next-line)
  (define-key view-mode-map (kbd "p") 'previous-line)
  (define-key view-mode-map (kbd "f") 'forward-char)
  (define-key view-mode-map (kbd "b") 'backward-char)

  ;; Beginning/end of line
  (define-key view-mode-map (kbd "a") 'beginning-of-line)
  (define-key view-mode-map (kbd "e") 'end-of-line)

  ;; Vim-ish keys

  ;; Quick exit to edit mode
  (define-key view-mode-map (kbd "i") 'View-exit)
  (define-key view-mode-map (kbd "j") 'next-line)
  (define-key view-mode-map (kbd "k") 'previous-line)
  (define-key view-mode-map (kbd "h") 'backward-char)
  (define-key view-mode-map (kbd "l") 'forward-char)

  ;; Page movement
  (define-key view-mode-map (kbd "u") '(lambda()
                                         (interactive)
                                         (View-scroll-page-backward 3)))
  (define-key view-mode-map (kbd "d") '(lambda()
                                         (interactive)
                                         (View-scroll-page-forward 3)))

  ;; Beginning/end of line (Vim style)
  (define-key view-mode-map (kbd "0") 'beginning-of-line)
  (define-key view-mode-map (kbd "$") 'end-of-line)

  ;; Beginning/end of buffers
  (define-key view-mode-map (kbd "g") 'beginning-of-buffer)
  (define-key view-mode-map (kbd "G") 'end-of-buffer)

  ;; Other bespoke bindings
  (define-key view-mode-map (kbd ";") 'other-window)

  (define-key view-mode-map (kbd "SPC") 'nil))

;; Quick toggle keys
(global-set-key (kbd "C-<escape>") 'view-mode)
(global-set-key (kbd "C-<tab>") 'view-mode)

;; Optional: return to view-mode after saving
(add-hook 'after-save-hook 
          (lambda ()
            (when (and buffer-file-name (not view-mode))
              (view-mode 1))))

;; Visual feedback - box cursor in view mode, bar when editing
(add-hook 'view-mode-hook
          (defun view-mode-hookee+ ()
            (setq cursor-type (if view-mode 'box 'bar))))
#+end_src

** Baby Proofing

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250731123820-emacs--Discovering-View-Mode-Emacss-Hidden-Modal-Editing-Gem.jpg]]

Here's where it gets interesting (possibly). I have a baby, and babies have this amazing ability to slam their tiny hands down on keyboards at the most inopportune moments. Nothing quite like a random key smash right in the middle of an important file!. Wouldn't it be great to have a protective read-only shield over a file? So I decided, why not put all files into view-mode by default?, this way, accidental keypresses won't modify anything, and I can intentionally switch to edit mode only when I actually need to make changes.

#+begin_src elisp
;; Enable view-mode for files by default
(add-hook 'find-file-hook 
          (lambda ()
            (unless (or (derived-mode-p 'dired-mode))
              (view-mode 1))))
#+end_src

I'm currently using the automatic activation to see how it goes, but I have to say I'm not completely comfortable with setting files to read-only mode. Although more baby-proof, it does mean I have to activate edit mode (or deactivate view-mode) each time I want to edit a file and that doesn't feel very Emacsy to me.

** Cursor

You will notice that in the setup there is a modification of the cursor depending on the mode state. Although the modeline will indicate if view-mode is on or off, I'm actually quite liking the differentiation in editing modes to be reflected in the cursor. It is simple, and my brain is starting to recognize instinctively which mode I am in with no extra visual baggage.

** Subtleties

It is also worth pointing out some more subtleties:

- I have added the enabling of view-mode every time a file is saved. I am a habitual saver, I have no idea why (oh wait, habit!), so that means having to enter "edit mode" quite often. We shall see how this goes, but currently it means that I am not having to often flit back to view-mode after some characters are inserted as I would have saved and returned anyway!

- In addition, there is a sneaky ~(setq view-read-only t)~ which means that toggling a file to and from read-only via =C-x C-q= will activate =view-mode= accordingly. I'm not really using this at the moment, but it could come in useful if I start thinking more in a =dired= manner, where I activate the edit mode in dired quite often to change filenames, so this could be muscle memory transferable. In the main, though, I don't think setting this is going to hurt anything.

- Another subtlety is the lambdas set for the page scroll. =view-mode= has quite a neat implementation for scrolling, in that, with a prefix or a defun argument, the number of lines for a scroll can be set. I don't often like to scroll full pages or even half pages, so I typically have set only a few lines for faster scrolling, this of course is configurable to your own tastes.

- You can see that I have added in all the basic Emacs and Vim typical navigational keys, and in the case of Emacs, stripped of the modifier. This, for me, feels much more natural, and strangely, I find myself naturally jumping between the Vim and Emacs keys, for shame!

- I have already disabled a key within the view-mode mode-map and that is SPC, I found myself often (so far) pressing space without toggling off view-mode and that would scroll one page down - annoying!

- If I am using the vim keys often and it might be likely I am viewing files, maybe code files and maybe I have a single horizontal split, I might just like to have a single key to jump back and forward between windows.  I chose ";" for a few reasons but the main one is that the key is adjacent to the other vim navigation keys.

It is worth noting, of course, that all normal Emacs navigational keybindings are still available, so you also have that option too within view-mode.

** Foibles

So far I have noticed some, lets say, foibles

- It is not uncommon that I would want changes that I have just made and saved to be undone, but when undoing I am in view-mode, and the reversal is rejected due to the file being read only!, I might have to think about this one.

- In org-mode, with the speed keys enabled which gives you a range of org commands from a single character when the point is at the heading start obviously can cause a conflict.  For example, "s" is mapped in speed keys to narrow section, but in view-mode mode it is an incremental search.

** Improvements?

- One Idea is maybe I can auto-deactivate view-mode when a typical Emacs edit keybinding is detected, but this is fraught with edge cases, but maybe.
  
- Do I go further with a vim paradigm? I'm not going to lie here I like the "x" to delete a character and "dd" to delete a whole line (C-k (kill-line) is something I use all the time).  Could I add these in without having to break out of view-mode and hence preserving a flow for fast edits?, not sure.

** Conclusion

Anyways, the result is a surprisingly pleasant modal editing experience so far that already feels natural in Emacs while giving me the ergonomic benefits of Vim-style navigation and comfortable single-key navigation options.

Plus, my codebase is now baby-resistant!

* DONE Ollama Buddy v1.0: A Simple AI Assistant :ollama_buddy:ollama:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250723083048-emacs--Announcing-v1-ollama-buddy
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-07-23 09:20>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg
:END:

After months of development and refinement, I'm excited to announce *Ollama Buddy v1.0* - an Emacs package that simply interfaces mainly to ollama, for local LLM usage, but can be integrated to the major online players. This project initially started as a simple integration with Ollama and since then has somewhat evolved into a more fully fully-featured AI Emacs assistant.  The main focus with this package is a front facing simplicity but hiding (hopefully) all the features you would expect from an AI chatbot - wait I hate that term, I mean, assistant :).  There is also the ability to craft a customizable menu system for different roles.

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg]]

I had a blast developing this package and next up is RAG!. I saw recently that a package called =vecdb= was introduced into the package ecosystem to help with the storage of vector embeddings, so as ollama can return embedding vectors for semantic search I thought I would combine my package, vecdb, also probably initially a PostgreSQL database with a pgvector extension and ollama into something that could ingest files directly from Emacs.  I think I have figured this out now, I just need to do it (when the baby is asleep, probably!)

** Why Choose Ollama Buddy?

I designed Ollama Buddy to be as simple as possible to set up, no backend configuration or complex setup required. This was achievable initially because I focused solely on Ollama integration, where models are automatically discoverable.

Since then, I've expanded support to major online AI providers while maintaining that same simplicity through a modular architecture. The system now handles multiple providers without adding complexity to the user experience.

Another key feature is the customizable menu system, which integrates with role-based switching. You can create specialized AI menus for different contexts, like a coding-focused setup or a writing-optimized configuration and switch between them instantly. Everything is fully configurable to match your workflow.

** Links

Here are some links:

https://github.com/captainflasmr/ollama-buddy
https://melpa.org/#/ollama-buddy

I will outline the major features below, but I do have a manual available!

https://github.com/captainflasmr/ollama-buddy/blob/main/docs/ollama-buddy.org

** Key Features
*** Multiple AI Providers

- *Local Models*: Full support for Ollama with automatic model management
- *Cloud Services*: Integrated support for OpenAI (ChatGPT), Anthropic Claude, Google Gemini, and Grok
- *Seamless Switching*: Change between local and cloud models with a single command
- *Unified Interface*: Same commands work across all providers

*** Role-Based Workflows - build your own AI menu

- *Preset Roles*: Switch between different AI personalities (developer, writer, analyst, etc.)
- *Custom Roles*: Create specialized workflows with specific models and parameters
- *Menu Customization*: Each role can have its own set of commands and shortcuts

*** Chat Interface

- *Org-mode Integration*: Conversations rendered in structured org-mode format
- *Real-time Streaming*: Watch responses appear token by token
- *Context Management*: Visual context window monitoring with usage warnings
- *History Tracking*: Full conversation history with model-specific storage

*** File Handling

- *File Attachments*: Attach documents directly to conversations for context-aware analysis
- *Vision Support*: Upload and analyse images with vision-capable models
- *Dired Integration*: Bulk attach files directly from Emacs file manager

*** Prompt Management

- *System Prompts*: Create and manage reusable system prompts for different use cases
- *Fabric Integration*: Auto-sync with Fabric patterns (200+ professional prompts)
- *Awesome ChatGPT Prompts*: Built-in access to the popular prompt collection
- *User Prompts*: Create and organize your own custom prompt library (which of course is org based)

*** Session Management

- *Save & Restore*: Full session persistence including history, attachments, and settings
- *Session Browser*: Visual interface to manage multiple conversation sessions
- *Auto-naming*: Intelligent session naming based on conversation content

*** Flexible Interface Options

- *Two Interface Levels*: Basic mode for beginners, advanced for power users
- *Transient Menus*: Magit-style discoverable command interface
- *Custom Menus*: Traditional text-based menu system
- *Keyboard Shortcuts*: Comprehensive keybinding system for efficiency, I'm not sure there are any keys left!!

** What's Next?

Version 1.0 represents a stable, foundation, Ollama Buddy has been out there now for a few months with only a single github issue but development continues with:

- RAG integration using perhaps the new =vecdb= package, as mentioned above
- Additional AI provider integrations (Perplexity maybe?, any suggestions?)
- Auto-completion (not sure how doable this is with ollama, but I do have a prototype)

* DONE Building an Emacs Package from Scratch: Cursor Heatmap Tutorial Part 2 :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250722132631-emacs--Building-a-New-Package-From-Scratch---Cursor-Heatmap-Pt2
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-07-22 13:26>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250722132631-emacs--Building-a-New-Package-From-Scratch---Cursor-Heatmap-Pt2.jpg
:END:

In our ongoing quest to construct a new fully functional Emacs package, in Part 1, we built the foundation and have a very basic package for our cursor heatmap package. Now we're ready to tackle the core challenge, actually tracking where the cursor is and detecting when it moves!

So, where is the cursor?, this seems simple, but with Emacs and of course generally software engineering there are several different approaches and concepts to understand and think about before we move on to some implementation.

1. *Point*: The character position in the buffer (like character 1,847)
2. *Line and column*: Traditional text coordinates (line 42, column 15)
3. *Window coordinates*: Position relative to the current window
4. *Frame coordinates*: Position relative to the entire Emacs frame
5. *Pixel coordinates*: Exact pixel position on screen

For our heatmap, we want to visualize cursor movement patterns across the entire Emacs interface, so we'll focus on *frame-relative positioning*, both pixel-based (for GUI Emacs) and character-based (for terminal Emacs).

** Exploring Emacs Coordinate Systems

Let's start by understanding what information Emacs can give us about cursor position. Add this exploration function to your package:

#+begin_src elisp
(defun cursor-heatmap-debug-position ()
  "Show detailed information about current cursor position."
  (interactive)
  (let* ((point-pos (point))
         (line-col (cons (line-number-at-pos) (current-column)))
         (window-edges (window-edges))
         (pixel-pos (when (display-graphic-p)
                      (window-absolute-pixel-position))))
    (message "Debug - Point: %d | Line/Col: %s | Window edges: %s | Pixels: %s"
             point-pos line-col window-edges pixel-pos)))
#+end_src

Try this function in different buffers and notice how the values change. You'll see that:
- *Point* changes based on buffer content and cursor position within text
- *Line/column* reflects traditional text editing coordinates
- *Window edges* show the window boundaries in character units
- *Pixel position* (GUI only) gives exact screen coordinates

** Building Our Position Detection System

Now let's create our core position detection function. We'll handle both GUI and terminal modes:

#+begin_src elisp
(defun cursor-heatmap--get-cursor-position ()
  "Get cursor position as frame-relative coordinates.
Returns (x . y) cons cell or nil if position should be excluded."
  (when (and (not (minibufferp))  ; Skip minibuffer
             (get-buffer-window)) ; Only track visible buffers
    (condition-case err
        (if (display-graphic-p)
            (cursor-heatmap--get-pixel-position)
          (cursor-heatmap--get-character-position))
      (error 
       ;; If anything goes wrong, return nil silently
       nil))))
#+end_src

Notice several important design decisions here:

*Error Handling*: We wrap everything in =condition-case= because cursor position detection can fail in various edge cases (buffer switching, window operations, etc.).

*Exclusion Logic*: We skip the minibuffer because it's typically used for brief interactions, not sustained editing work.

*Display Mode Detection*: We use different strategies for GUI vs. terminal Emacs.

** Implementing Pixel-Based Position Detection

For GUI Emacs, we can get precise pixel coordinates:

#+begin_src elisp
(defun cursor-heatmap--get-pixel-position ()
  "Get cursor position using pixel coordinates in GUI mode."
  (let* ((pixel-pos (window-absolute-pixel-position))
         (frame (selected-frame))
         (frame-pixel-width (frame-pixel-width frame))
         (frame-pixel-height (frame-pixel-height frame)))
    
    (when (and pixel-pos 
               (> frame-pixel-width 0) 
               (> frame-pixel-height 0))
      (let* ((frame-x-pixel (car pixel-pos))
             (frame-y-pixel (cdr pixel-pos))
             ;; Normalize to 0.0-1.0 range
             (normalized-x (/ (float frame-x-pixel) frame-pixel-width))
             (normalized-y (/ (float frame-y-pixel) frame-pixel-height)))
        
        ;; Return as percentages for easier grid mapping later
        (cons normalized-x normalized-y)))))
#+end_src

This function:
1. Gets the absolute pixel position of the cursor
2. Normalizes it to a 0.0-1.0 range relative to the frame size
3. Returns coordinates that we can easily map to any grid size

** Implementing Character-Based Position Detection

Terminal Emacs doesn't have pixel coordinates, so we use character positions:

#+begin_src elisp
(defun cursor-heatmap--get-character-position ()
  "Get cursor position using character coordinates in terminal mode."
  (let* ((window (selected-window))
         (window-edges (window-edges window))
         (window-left (nth 0 window-edges))
         (window-top (nth 1 window-edges))
         (point-pos (window-point window))
         (total-frame-width (frame-width))
         (total-frame-height (frame-height)))
    
    (when (and (> total-frame-width 0) 
               (> total-frame-height 0))
      (save-excursion
        (goto-char point-pos)
        (let* ((current-column (current-column))
               (window-line (count-lines (window-start window) point-pos))
               ;; Calculate frame-relative position
               (frame-column (+ window-left current-column))
               (frame-row (+ window-top window-line))
               ;; Normalize to 0.0-1.0 range
               (normalized-x (/ (float frame-column) total-frame-width))
               (normalized-y (/ (float frame-row) total-frame-height)))
          
          (cons normalized-x normalized-y))))))
#+end_src

This is more complex because we need to:
1. Get the current column position (handling tabs correctly)
2. Calculate which line we're on relative to the window
3. Convert window-relative coordinates to frame-relative coordinates
4. Normalize to the same 0.0-1.0 range as pixel coordinates

** Adding Movement Detection

Having a position is only half the battle, we need to detect when the cursor actually moves. Let's add state tracking:

#+begin_src elisp
(defvar cursor-heatmap--last-position nil
  "Last recorded cursor position for movement detection.")

(defvar cursor-heatmap--movement-count 0
  "Total number of cursor movements detected.")

(defun cursor-heatmap--detect-movement ()
  "Check if cursor has moved and record the movement."
  (let ((current-pos (cursor-heatmap--get-cursor-position)))
    (when current-pos
      (when (and cursor-heatmap--last-position
                 (not (equal current-pos cursor-heatmap--last-position)))
        ;; This is a real movement!
        (cl-incf cursor-heatmap--movement-count)
        (message "Movement detected! Total movements: %d" 
                 cursor-heatmap--movement-count))
      
      ;; Update last position for next comparison
      (setq cursor-heatmap--last-position current-pos))))
#+end_src

** Setting Up the Hook System

Emacs provides several hooks we can use to detect cursor movement. The most reliable is =post-command-hook=, which runs after every command:

#+begin_src elisp
(defun cursor-heatmap--setup-tracking ()
  "Set up hooks to track cursor movement."
  (add-hook 'post-command-hook #'cursor-heatmap--detect-movement))

(defun cursor-heatmap--stop-tracking ()
  "Remove movement tracking hooks."
  (remove-hook 'post-command-hook #'cursor-heatmap--detect-movement))
#+end_src

** Creating Our First Interactive Commands

Let's add commands users can run to test our tracking:

#+begin_src elisp
;;;###autoload
(defun cursor-heatmap-start-tracking ()
  "Start tracking cursor movements."
  (interactive)
  (cursor-heatmap--setup-tracking)
  (setq cursor-heatmap--last-position (cursor-heatmap--get-cursor-position)
        cursor-heatmap--movement-count 0)
  (message "Cursor movement tracking started"))

;;;###autoload
(defun cursor-heatmap-stop-tracking ()
  "Stop tracking cursor movements."
  (interactive)
  (cursor-heatmap--stop-tracking)
  (message "Cursor movement tracking stopped. Total movements: %d"
           cursor-heatmap--movement-count))

;;;###autoload
(defun cursor-heatmap-show-stats ()
  "Show current tracking statistics."
  (interactive)
  (let ((current-pos (cursor-heatmap--get-cursor-position)))
    (message "Position: %s | Movements: %d | Tracking: %s"
             (if current-pos
                 (format "%.3f, %.3f" (car current-pos) (cdr current-pos))
               "unknown")
             cursor-heatmap--movement-count
             (if (memq #'cursor-heatmap--detect-movement post-command-hook)
                 "ON" "OFF"))))
#+end_src

The =;;;###autoload= comments are special, they tell Emacs to make these functions available even before the package is fully loaded.

** Handling Edge Cases

Real-world usage reveals edge cases we need to handle:

#+begin_src elisp
(defcustom cursor-heatmap-exclude-minibuffer t
  "Whether to exclude minibuffer from tracking."
  :type 'boolean
  :group 'cursor-heatmap)

(defcustom cursor-heatmap-exclude-special-buffers t
  "Whether to exclude special buffers (starting with space or asterisk)."
  :type 'boolean
  :group 'cursor-heatmap)

(defun cursor-heatmap--should-track-buffer-p ()
  "Return non-nil if current buffer should be tracked."
  (and (not (and cursor-heatmap-exclude-minibuffer
                 (minibufferp)))
       (not (and cursor-heatmap-exclude-special-buffers
                 (string-match "^[ *]" (buffer-name))))
       (get-buffer-window))) ; Only track visible buffers
#+end_src

Update our position function to use this check:

#+begin_src elisp
(defun cursor-heatmap--get-cursor-position ()
  "Get cursor position as frame-relative coordinates.
Returns (x . y) cons cell or nil if position should be excluded."
  (when (cursor-heatmap--should-track-buffer-p)
    (condition-case err
        (if (display-graphic-p)
            (cursor-heatmap--get-pixel-position)
          (cursor-heatmap--get-character-position))
      (error nil))))
#+end_src

** Testing Our Movement Detection

Let's create a comprehensive test function:

#+begin_src elisp
(defun cursor-heatmap-test-detection ()
  "Interactive test of cursor position detection."
  (interactive)
  (if (memq #'cursor-heatmap--detect-movement post-command-hook)
      (message "Tracking already active. Use cursor-heatmap-stop-tracking to stop.")
    (cursor-heatmap-start-tracking)
    (message "Move your cursor around, then run cursor-heatmap-show-stats")))
#+end_src

** Our Complete Progress So Far

Here's what we've built in this post:

#+begin_src elisp
;; Add these to your cursor-heatmap.el file after the customization variables

(require 'cl-lib) ; For cl-incf

;; State variables
(defvar cursor-heatmap--last-position nil
  "Last recorded cursor position for movement detection.")

(defvar cursor-heatmap--movement-count 0
  "Total number of cursor movements detected.")

;; New customization options
(defcustom cursor-heatmap-exclude-minibuffer t
  "Whether to exclude minibuffer from tracking."
  :type 'boolean
  :group 'cursor-heatmap)

(defcustom cursor-heatmap-exclude-special-buffers t
  "Whether to exclude special buffers (starting with space or asterisk)."
  :type 'boolean
  :group 'cursor-heatmap)

;; Core detection functions
(defun cursor-heatmap--should-track-buffer-p ()
  "Return non-nil if current buffer should be tracked."
  (and (not (and cursor-heatmap-exclude-minibuffer
                 (minibufferp)))
       (not (and cursor-heatmap-exclude-special-buffers
                 (string-match "^[ *]" (buffer-name))))
       (get-buffer-window)))

(defun cursor-heatmap--get-pixel-position ()
  "Get cursor position using pixel coordinates in GUI mode."
  (let* ((pixel-pos (window-absolute-pixel-position))
         (frame (selected-frame))
         (frame-pixel-width (frame-pixel-width frame))
         (frame-pixel-height (frame-pixel-height frame)))
    
    (when (and pixel-pos 
               (> frame-pixel-width 0) 
               (> frame-pixel-height 0))
      (let* ((frame-x-pixel (car pixel-pos))
             (frame-y-pixel (cdr pixel-pos))
             (normalized-x (/ (float frame-x-pixel) frame-pixel-width))
             (normalized-y (/ (float frame-y-pixel) frame-pixel-height)))
        (cons normalized-x normalized-y)))))

(defun cursor-heatmap--get-character-position ()
  "Get cursor position using character coordinates in terminal mode."
  (let* ((window (selected-window))
         (window-edges (window-edges window))
         (window-left (nth 0 window-edges))
         (window-top (nth 1 window-edges))
         (point-pos (window-point window))
         (total-frame-width (frame-width))
         (total-frame-height (frame-height)))
    
    (when (and (> total-frame-width 0) 
               (> total-frame-height 0))
      (save-excursion
        (goto-char point-pos)
        (let* ((current-column (current-column))
               (window-line (count-lines (window-start window) point-pos))
               (frame-column (+ window-left current-column))
               (frame-row (+ window-top window-line))
               (normalized-x (/ (float frame-column) total-frame-width))
               (normalized-y (/ (float frame-row) total-frame-height)))
          (cons normalized-x normalized-y))))))

(defun cursor-heatmap--get-cursor-position ()
  "Get cursor position as frame-relative coordinates.
Returns (x . y) cons cell or nil if position should be excluded."
  (when (cursor-heatmap--should-track-buffer-p)
    (condition-case err
        (if (display-graphic-p)
            (cursor-heatmap--get-pixel-position)
          (cursor-heatmap--get-character-position))
      (error nil))))

(defun cursor-heatmap--detect-movement ()
  "Check if cursor has moved and record the movement."
  (let ((current-pos (cursor-heatmap--get-cursor-position)))
    (when current-pos
      (when (and cursor-heatmap--last-position
                 (not (equal current-pos cursor-heatmap--last-position)))
        (cl-incf cursor-heatmap--movement-count))
      (setq cursor-heatmap--last-position current-pos))))

(defun cursor-heatmap--setup-tracking ()
  "Set up hooks to track cursor movement."
  (add-hook 'post-command-hook #'cursor-heatmap--detect-movement))

(defun cursor-heatmap--stop-tracking ()
  "Remove movement tracking hooks."
  (remove-hook 'post-command-hook #'cursor-heatmap--detect-movement))

;; Interactive commands
;;;###autoload
(defun cursor-heatmap-start-tracking ()
  "Start tracking cursor movements."
  (interactive)
  (cursor-heatmap--setup-tracking)
  (setq cursor-heatmap--last-position (cursor-heatmap--get-cursor-position)
        cursor-heatmap--movement-count 0)
  (message "Cursor movement tracking started"))

;;;###autoload
(defun cursor-heatmap-stop-tracking ()
  "Stop tracking cursor movements."
  (interactive)
  (cursor-heatmap--stop-tracking)
  (message "Cursor movement tracking stopped. Total movements: %d"
           cursor-heatmap--movement-count))

;;;###autoload
(defun cursor-heatmap-show-stats ()
  "Show current tracking statistics."
  (interactive)
  (let ((current-pos (cursor-heatmap--get-cursor-position)))
    (message "Position: %s | Movements: %d | Tracking: %s"
             (if current-pos
                 (format "%.3f, %.3f" (car current-pos) (cdr current-pos))
               "unknown")
             cursor-heatmap--movement-count
             (if (memq #'cursor-heatmap--detect-movement post-command-hook)
                 "ON" "OFF"))))

;;;###autoload
(defun cursor-heatmap-test-detection ()
  "Interactive test of cursor position detection."
  (interactive)
  (if (memq #'cursor-heatmap--detect-movement post-command-hook)
      (message "Tracking already active. Use cursor-heatmap-stop-tracking to stop.")
    (cursor-heatmap-start-tracking)
    (message "Move your cursor around, then run cursor-heatmap-show-stats")))

;; Debug helper
(defun cursor-heatmap-debug-position ()
  "Show detailed information about current cursor position."
  (interactive)
  (let* ((point-pos (point))
         (line-col (cons (line-number-at-pos) (current-column)))
         (window-edges (window-edges))
         (pixel-pos (when (display-graphic-p)
                      (window-absolute-pixel-position)))
         (our-pos (cursor-heatmap--get-cursor-position)))
    (message "Point: %d | Line/Col: %s | Edges: %s | Pixels: %s | Our pos: %s"
             point-pos line-col window-edges pixel-pos our-pos)))
#+end_src

** What We've Accomplished

In this post, we've built the core tracking system:

✅ *Position detection*: Works in both GUI and terminal modes  
✅ *Movement detection*: Only counts actual cursor movements  
✅ *Error handling*: Gracefully handles edge cases  
✅ *Hook system*: Reliable tracking using Emacs' event system  
✅ *Interactive testing*: Commands to start, stop, and debug tracking  
✅ *Customization*: User control over what gets tracked  

** Testing Your Implementation

Try these exercises to verify everything works:

1. *Load and test*: Reload your package and run =cursor-heatmap-test-detection=
2. *Move around*: Navigate between buffers, windows, and frames
3. *Check stats*: Run =cursor-heatmap-show-stats= to see movement counts
4. *Debug position*: Use =cursor-heatmap-debug-position= to see raw coordinate data
5. *Test exclusions*: Try the minibuffer and special buffers

** Common Issues and Solutions

*"Position always nil"*: Check that you're in a visible buffer and not a special buffer.

*"No movements detected"*: Make sure tracking is active and you're making actual movements, not just staying in one place.

*"Coordinates seem wrong"*: This is normal, we're getting normalized coordinates (0.0-1.0) that we'll map to grids later.

** Looking Ahead

In Part 3, we'll transform these normalized coordinates into a grid system and start building our data structures for the heatmap. We'll cover:

- Mapping coordinates to grid cells
- Creating efficient storage for movement data
- Handling different grid sizes
- Building the foundation for visualization

The tracking system we built today is the engine that will power our entire heatmap, everything else builds on this foundation.

** Your Turn: Hands-On Exercise

Extend the tracking system:

1. *Add buffer tracking*: Modify the system to track which buffer movements occur in
2. *Add time tracking*: Record timestamps with movements
3. *Create a movement log*: Store the last 10 movements for debugging
4. *Experiment with hooks*: Try different hooks beyond =post-command-hook=

** Next Time

In Part 3, we'll build the grid mapping system that transforms our position data into the structure needed for heatmap visualization.

* DONE Building a New Package From Scratch - Cursor Heatmap Pt1 :heatmap:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250719094720-emacs--Building-an-Emacs-Cursor-Heatmap-Pt1
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-07-20 13:17>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/cursor-heatmap-banner_pt1.jpg
:END:

---
#+TOC: headlines 1 local
---

** Lets Create a New Package!

Given that I now have greater experience in Emacs package creation, I thought I would create a short series of blog posts over the next few weeks in taking an initial idea I have for a new Emacs package and working it up into a full, working version!

The idea here is to hopefully be useful to someone who has an idea for doing something new in Emacs and would like to start working it up into a package. There are resources out there, but I thought I would give a go at creating my own.

As usual with writing a blog and having to explain a concept to someone in an understandable format, I suspect that I'm also actually likely to learn something from this activity.

Right, so what is my idea?

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/cursor-heatmap-banner_pt1.jpg]]

-----

#+begin_center
/Have you ever wondered where your cursor/point spends most of its time when you are fiddling around with Emacs?, do you generally split two windows side-by-side and which window do you typically work in?, do you use olivetti or a similar mode to centralise the text, do you use a four window split on a large monitor and where do you spend most of your time?/

/So how about an Emacs package that monitors your cursor/point position and can provide a graphical report showing by some kind of graphical heat map the often used Emacs window locations/
#+end_center

-----

Lets quickly break this concept down into a very high level design (so high it is in fact just a speck!), should we go the full software engineering approach and define requirements?, then start deriving a design, (maybe not!), so lets see what functional aspects we can start with:

- Tracks cursor movements throughout your Emacs editing session
- Creates a visual heat map showing movement patterns
- Provides analytics about your editing behaviour
- Persists data across sessions so we can have recall and overall data across many days

** Building Our Foundation

Lets crack on and get something down on paper and begin with the absolute minimum structure and expand from there.

*** Step 1: Create the Basic File Structure

Create a new file called =cursor-heatmap.el= with the following contents:

#+begin_src elisp
;;; cursor-heatmap.el --- Monitor and visualize cursor movement patterns -*- lexical-binding: t; -*-

;; Copyright (C) 2025

;; Author: Your Name <your.email@example.com>
;; Version: 0.1.0
;; Package-Requires: ((emacs "26.1"))
;; Keywords: tools, analytics, visualization
;; URL: https://github.com/yourusername/cursor-heatmap

;;; Commentary:

;; This package will monitor cursor movements throughout an Emacs session and
;; generate heatmap reports showing where you move your cursor most frequently.
;;
;; Basic usage (to be implemented):
;;   M-x cursor-heatmap-mode - start tracking
;;   M-x cursor-heatmap-show-report - view results

;;; Code:

;; Package implementation will go here

(provide 'cursor-heatmap)

;;; cursor-heatmap.el ends here
#+end_src

*** Step 2: Understanding Key Components

*Why =lexical-binding: t=?*

This enables modern variable scoping in Emacs Lisp. Without it, all variables have dynamic scope, which can lead to surprising behaviour and bugs. Always use lexical binding for new packages.

*The =provide= statement:*

#+begin_src elisp
(provide 'cursor-heatmap)
#+end_src

This tells Emacs that loading this file provides the =cursor-heatmap= feature. Other packages can then use =(require 'cursor-heatmap)= to load your package.

There are other more advanced ways of loading packages but we shall stick with the basic built-in Emacs package.el for now.

*Version numbering:*

We start with =0.1.0= following a simple versioning mechanism. As we add features, we'll increment appropriately.

*** Step 3: Setting Up Customization Groups

One of Emacs' greatest strengths is customizability. Let's set up a customization group for our package:

#+begin_src elisp
;;; Code:

(defgroup cursor-heatmap nil
  "Cursor movement heatmap monitoring and visualization."
  :group 'tools
  :prefix "cursor-heatmap-")
#+end_src

This creates a customization group that will appear under the "Tools" category in Emacs' customization interface. Users can access it via =M-x customize-group cursor-heatmap=

*** Step 4: Adding Our First Variables

Let's add some basic configuration variables:

#+begin_src elisp
(defcustom cursor-heatmap-grid-width 100
  "Width of the heatmap grid (number of columns)."
  :type 'integer
  :group 'cursor-heatmap)

(defcustom cursor-heatmap-grid-height 50
  "Height of the heatmap grid (number of rows)."
  :type 'integer
  :group 'cursor-heatmap)
#+end_src

The =defcustom= macro creates variables that users can customize through the Emacs' interface. The =:type= specification helps Emacs validate user input and provide appropriate UI widgets.

** Package Naming Conventions

Notice how all our variables start with =cursor-heatmap-= This is a crucial convention in Emacs package development:

- *Prevents namespace collisions*: With thousands of packages, prefixing prevents conflicts
- *Makes code searchable*: Users can easily find all functions related to your package
- *Shows ownership*: Clear indication of what belongs to your package

Common patterns:

- Variables: =cursor-heatmap-variable-name=
- Functions: =cursor-heatmap-function-name=
- Internal functions: =cursor-heatmap--internal-function= (note the double dash)

** Testing Our Foundation

Let's make sure our basic structure works. Add this simple function to test:

#+begin_src elisp
(defun cursor-heatmap-hello ()
  "Test function to verify package structure."
  (interactive)
  (message "Cursor heatmap package loaded successfully! Grid size: %dx%d"
           cursor-heatmap-grid-width cursor-heatmap-grid-height))
#+end_src

Now you can:

1. Load the file: =M-x load-file= and select =cursor-heatmap.el=
2. Test it: =M-x cursor-heatmap-hello=
3. Check customization: =M-x customize-group cursor-heatmap=

** Our Complete Foundation

Here's our complete foundation file, I think I shall show this at the end of each post so progress can be monitored.

#+begin_src elisp
;;; cursor-heatmap.el --- Monitor and visualize cursor movement patterns -*- lexical-binding: t; -*-

;; Copyright (C) 2025

;; Author: Your Name <your.email@example.com>
;; Version: 0.1.0
;; Package-Requires: ((emacs "26.1"))
;; Keywords: tools, analytics, visualization
;; URL: https://github.com/yourusername/cursor-heatmap

;;; Commentary:

;; This package will monitor cursor movements throughout an Emacs session and
;; generate heatmap reports showing where you move your cursor most frequently.
;;
;; Basic usage (to be implemented):
;;   M-x cursor-heatmap-mode - start tracking
;;   M-x cursor-heatmap-show-report - view results

;;; Code:

(defgroup cursor-heatmap nil
  "Cursor movement heatmap monitoring and visualization."
  :group 'tools
  :prefix "cursor-heatmap-")

(defcustom cursor-heatmap-grid-width 100
  "Width of the heatmap grid (number of columns)."
  :type 'integer
  :group 'cursor-heatmap)

(defcustom cursor-heatmap-grid-height 50
  "Height of the heatmap grid (number of rows)."
  :type 'integer
  :group 'cursor-heatmap)

(defun cursor-heatmap-hello ()
  "Test function to verify package structure."
  (interactive)
  (message "Cursor heatmap package loaded successfully! Grid size: %dx%d"
           cursor-heatmap-grid-width cursor-heatmap-grid-height))

(provide 'cursor-heatmap)
#+end_src

** What We've Accomplished

In this first post, we've established the foundation of our Emacs package:

- [X] *Package structure*: Proper header, metadata, and organization  
- [X] *Customization system*: User-configurable options with validation  
- [X] *Naming conventions*: Consistent, collision-free naming  
- [X] *Basic functionality*: A working, loadable package  
- [X] *Testing framework*: Simple way to verify our progress  

** Next Time

In the next post, we'll dive into the core functionality: tracking cursor position.

We'll explore:

- How Emacs represents cursor positions
- Different coordinate systems (pixels vs. characters)
- Setting up our first movement detection
- Handling edge cases and error conditions

* DONE Red pandas also love Emacs! :emacs:ai:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250710125504-emacs--Red-Pandas-Also-Love-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-07-10 12:55>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250710125504-emacs--Red-Pandas-Also-Love-Emacs.jpg
:END:

Not much of a post this week (and in fact this is pretty low effort!), but here I present some fun with image generative AI!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250710125504-emacs--Red-Pandas-Also-Love-Emacs.jpg]]

That is all 😀

* DONE New Package! - Simply Annotate: A Lightweight Annotation System :package:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250704224318-emacs--New-Package-Simply-Annotate-A-Lightweight-Annotation-System
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-07-04 22:43>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250704224318-emacs--New-Package-Simply-Annotate-A-Lightweight-Annotation-System.jpg
:END:

Yes thats right, yet another annotation system!, in this case it is a lightweight annotation system for Emacs that allows you to add persistent notes to any text file without modifying the original content.

https://melpa.org/#/simply-annotate
https://github.com/captainflasmr/simply-annotate

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250704224318-emacs--New-Package-Simply-Annotate-A-Lightweight-Annotation-System.jpg]]

Still not convinced it is any different to any other note taking package in Emacs given that previous generic sparse description? Well I shall do my best to explain my own note taking ideas.  Of course this is also just a pet project to continue to learn elisp, so there is that too :)

I developed this package to fill my own perceived gap in the existing Emacs note-taking ecosystem. Although =annotate.el= comes close to what I needed, I wanted a simplified version and something with a few workflow adjustments that better suit my note taking preferences. The result is a lightweight alternative that handles annotations the way I have always wanted them to work.

The main functional aspects that I felt were important to me that generally differ from other existing Emacs annotation packages are:

- Header-line status display with keybinding reminders
- Simple intuitive workflow (hopefully)
- Multiple display styles (highlight, fringe indicators, or both)
- Annotation editing via a dedicated buffer
- Lightweight (if possible <1000 lines - [UPDATE], no its not possible, lets try <2000 lines!)
- Multi-purpose key to show/edit/toggle annotations
- Dedicated annotation buffer that can pop in and out
- Quickly step through annotations with =M-n= and =M-p=
- Buffer summary of annotations in grep-mode format
- Quickly browse through all annotated files using completing-read
- Smart action command that adapts based on context
- Threading conversations for each annotation

See https://github.com/captainflasmr/simply-annotate/blob/main/docs/simply-annotate.org for the manual!

** Quick Demo Video

Open this file and open the simply-annotate.el file

- highlight some regions and put in some annotation comments

- step through annotation comments

- show summary

- delete some annotations

Go to the directory level and now browse the 2 files

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/simply-annotate-screen-recording.gif]]

** Whats New
*** <2025-07-03> *0.6.0*

A little refactoring and tidying up.

*** <2025-06-29> *0.5.1*

- *Raw sexp editing*: Edit annotation data structures directly as Elisp for complete control
- *Advanced editing capabilities*: Full access to thread metadata, status, priority, and comments

*Updated Key Bindings:*
- =M-s e=: Edit annotation as raw Elisp sexp

*** <2025-06-20> *0.5.0*

- *Threading system*: Add replies to annotations for conversations
- *Status management*: Track progress (open, in-progress, resolved, closed)
- *Priority levels*: Set importance (low, normal, high, critical)
- *Multi-author support*: Configure team members for collaboration
- *Tag system*: Organize with hashtags (#review, #bug, #question)
- *Org-mode export*: Convert threads to structured TODO items
- *Enhanced display*: Thread info in headers and lists
- *Author management*: Flexible prompting modes and author changes

*New Key Bindings:*
- =M-s r=: Add reply to annotation
- =M-s s=: Set status
- =M-s p=: Set priority
- =M-s t=: Add tag
- =M-s a=: Change author
- =M-s o=: Export to org-mode

*** <2025-06-20> *0.0.1*

- Basic annotation functionality
- Persistent storage
- Navigation commands
- Org-mode export
- Customizable highlighting

** Installation
*** MELPA (Recommended)

#+begin_src emacs-lisp
(use-package simply-annotate
  :bind ("C-c A" . simply-annotate-mode))
#+end_src

*** Manual Installation

1. Download =simply-annotate.el=
2. Place it in your Emacs =load-path=
3. Add to your configuration:

#+begin_src emacs-lisp
(require 'simply-annotate)
(global-set-key (kbd "C-c A") simply-annotate-mode)
#+end_src

** Quick Start

1. Open any file
2. Enable annotation mode: =M-x simply-annotate-mode=
3. Select/mark text and press =M-s j= to create your first annotation
4. Create some more annotations
5. Navigate with =M-n= (next) and =M-p= (previous)
6. Add replies: Press =M-s r= on any annotation to reply
7. Set status: Press =M-s s= to track progress (open/resolved/etc.)
8. Advanced editing: Press =M-s e= to edit annotation data structure directly

** Usage
*** Enabling Annotation Mode

#+begin_src emacs-lisp
M-x simply-annotate-mode
#+end_src

Or bind to a convenient key:

#+begin_src emacs-lisp
(global-set-key (kbd "C-c A") 'simply-annotate-mode)
#+end_src

*** Creating Annotations
**** Simple

The =M-s j= command (=simply-annotate-smart-action=) is context-aware:

1. *With region selected*: Creates new annotation or edits existing one
2. *On annotated text*: Toggles annotation buffer visibility  
3. *With prefix (C-u M-s j)*: Forces edit mode on existing annotation
4. *Elsewhere*: Creates annotation for current line
5. Enter your annotation text in the dedicated buffer
6. Save with =C-c C-c=

*** Advanced Editing
**** Raw Sexp Editing

For complete control over annotation data structures:

1. Place cursor on any annotation
2. Press =M-s e= to open the raw sexp editor
3. Edit the Elisp data structure directly:
   - Modify thread metadata (status, priority, tags)
   - Edit comment text and timestamps
   - Add/remove/reorder comments
   - Change author information
4. Save with =C-c C-c= or cancel with =C-c C-k=

*Example sexp structure:*
#+begin_src emacs-lisp
((id . "thread-123456")
 (created . "2025-06-29T10:30:00")
 (status . "open")
 (priority . "high")
 (tags . ("bug" "critical"))
 (comments . (((author . "John Doe")
               (timestamp . "2025-06-29T10:30:00")
               (text . "Found a critical bug here")
               (type . "comment"))
              ((author . "Jane Smith")
               (timestamp . "2025-06-29T11:15:00")
               (text . "I can reproduce this issue")
               (type . "reply")))))
#+end_src

*** Threading & Collaboration
**** Adding Replies

1. Place cursor on any annotation
2. Press =M-s r= to add a reply
3. Enter your response
4. The annotation becomes a threaded conversation

**** Status Management

- Press =M-s s= to set status: open, in-progress, resolved, closed
- Press =M-s p= to set priority: low, normal, high, critical
- Press =M-s t= to add tags like #review, #bug, #question

**** Author Management

Configure for single-user or team workflows:

#+begin_src emacs-lisp
;; Single user (default behavior)
(setq simply-annotate-prompt-for-author nil)

;; Team collaboration
(setq simply-annotate-author-list '("John Doe" "Jane Smith" "Bob Wilson"))
(setq simply-annotate-prompt-for-author 'threads-only)  ; Prompt only for replies
(setq simply-annotate-remember-author-per-file t)       ; Remember per file
#+end_src

Available prompting modes:
- =nil=: Never prompt (single-user mode)
- ='first-only=: Prompt once per session
- ='always=: Prompt for every annotation
- ='threads-only=: Prompt only for thread replies (great for reviews)

**** Author Commands

- =M-s a=: Change author of existing annotation/comment

*** Display Styles

Simply Annotate supports three display styles:

- *Highlight*: Traditional background highlighting (default)
- *Fringe*: Shows indicators in the left fringe
- *Both*: Combines highlighting with fringe indicators

Change styles with =M-s ]= or customize =simply-annotate-display-style=.

*** Viewing Annotations

When =simply-annotate-mode= is active:

- Annotated text is displayed according to your chosen style
- The header line shows annotation count, status info, and available commands
- * Thread info*: Header shows =[OPEN/HIGH:3]= for status, priority, and comment count
- Moving to annotated text shows annotation details in the header
- Press =M-s j= on annotated text to view/edit in detail

*** Navigation

| Key Binding | Action                       |
|-------------+------------------------------|
| =M-n=       | Jump to next annotation      |
| =M-p=       | Jump to previous annotation  |
| =M-s j=     | Smart action (context-aware) |

*** Managing Annotations
**** Creating

- Select/mark some text
- Press =M-s j= to open the annotation buffer
- Make your changes
- Save with =C-c C-c=

**** Editing

*Standard Editing:*
- Place cursor on annotated text
- Press =C-u M-s j= to open the annotation buffer
- Make your changes
- Save with =C-c C-c=

*Advanced Sexp Editing:*
- Place cursor on annotated text
- Press =M-s e= to open the raw sexp editor
- Edit the complete data structure
- Save with =C-c C-c= or cancel with =C-c C-k=

**** Deleting

- Place cursor on annotated text
- Press =M-s -= to remove the annotation

**** Listing All Annotations

- Press =M-s l= to open a grep-mode buffer showing all annotations in the current file
- **Enhanced display**: Shows thread status, priority, comment counts, and author info
- Click on line numbers, press =Enter= or =n/p= keys to jump directly to annotations
- Perfect for getting an overview of all your notes and their status

**** Cross-file Overview

- Press =M-s 0= to browse annotations across all files
- Select a file from the completion list
- **Statistics**: Shows annotation counts and status summaries per file
- View all annotations for that file in =grep-mode= format
- Source file is presented along with =grep-mode= list of annotations

*** Org-mode Integration

Export your annotation threads to org-mode files for further processing:

- Press =M-s o= to export current buffer annotations to an org file
- Each thread becomes a TODO item with proper metadata
- Replies become sub-entries
- Status, priority, tags, and timestamps are preserved

** Tips and Tricks
*** Workflow Suggestions

Enable the mode globally if you wish for all files!
   
#+begin_src emacs-lisp
(use-package simply-annotate
  :hook
  (find-file-hook . simply-annotate-mode)
  :bind
  ("C-c A" . simply-annotate-mode)
  ("C-c 0" . simply-annotate-show-all))
#+end_src

*** Smart Action Usage Patterns

- *Quick annotation*: No selection, =M-s j= to annotate current line
- *Edit existing*: =C-u M-s j= on annotated text to force edit mode
- *Toggle view*: =M-s j= on annotated text to show/hide annotation buffer
- *Region annotation*: Select text, =M-s j= to create detailed annotation

*** Advanced Editing Tips

- *Bulk operations*: Use =M-s e= to edit multiple comments at once in sexp mode
- *Data migration*: Copy annotation structures between files using sexp editing
- *Precision control*: Manually adjust timestamps, IDs, or metadata via sexp editing
- *Complex threading*: Create sophisticated reply structures that aren't possible through the UI

*** Display Style Tips

- Use *fringe* mode for code files to minimize visual distraction
- Use *highlight* mode for documents where you want emphasis
- Use *both* mode for critical files requiring maximum attention
- Change styles on-the-fly with =M-s ]= based on current task

*** Performance Notes

- Annotations are loaded on-demand per buffer
- Large numbers of annotations (100+) may slightly impact performance
- Fringe mode generally has better performance than highlight mode
- **Threading**: Complex threads (10+ replies) may slow annotation buffer rendering
- **Sexp editing**: Large annotation structures may take a moment to format and parse

* TODO CSharp-setup-linux-build :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250628085057-emacs--CSharp-setup-linux-build
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-06-28 08:50>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250628085057-emacs--CSharp-setup-linux-build.jpg
:END:

Here's the best way to install VS Code on Arch Linux with full C# support:

** 1. Install Visual Studio Code
*** Option A: AUR (Recommended for full Microsoft version)

#+begin_src bash
# Using yay
yay -S visual-studio-code-bin

OR

# Using makepkg manually
git clone https://aur.archlinux.org/visual-studio-code-bin.git
cd visual-studio-code-bin
makepkg -si
#+end_src

** 2. Install .NET SDK

#+begin_src bash
# Install specific version from AUR if needed
yay -S dotnet-sdk-9.0

# Verify installation
dotnet --version
#+end_src

** 3. Install C# Extensions

#+begin_src bash
# Install C# Dev Kit and related extensions
code --install-extension ms-dotnettools.csdevkit
code --install-extension ms-dotnettools.vscodeintellicode-csharp
code --install-extension ms-dotnettools.vscode-dotnet-runtime
#+end_src

** 4. Install Additional Development Dependencies

#+begin_src bash
# Essential development tools
sudo pacman -S git base-devel

# Optional but useful for C# development
sudo pacman -S nuget mono
#+end_src

** 5. Verify Everything Works

#+begin_src bash
# Check VS Code version
code --version

# Check .NET
dotnet --version
dotnet --list-sdks

# List installed extensions
code --list-extensions | grep dotnet
#+end_src

** 6. Create a Test C# Project

#+begin_src bash
# Create and test a simple C# project
mkdir test-csharp
cd test-csharp
dotnet new console
code .
#+end_src

** Arch-Specific Tips:
*** If you encounter issues with extensions:

#+begin_src bash
# Clear extension cache
rm -rf ~/.vscode/extensions
# Then reinstall extensions
#+end_src

*** For better performance:

#+begin_src bash
# Install additional fonts for better rendering
sudo pacman -S ttf-fira-code ttf-dejavu
#+end_src

*** If you need multiple .NET versions:

#+begin_src bash
# Check available versions in AUR
yay -Ss dotnet-sdk

# Install specific versions if needed
yay -S dotnet-sdk-6.0 dotnet-sdk-7.0 dotnet-sdk-8.0
#+end_src

*** Environment setup:

Add to your =~/.bashrc= or =~/.zshrc=:
#+begin_src bash
export DOTNET_ROOT=/usr/share/dotnet
export PATH=$PATH:$DOTNET_ROOT:$DOTNET_ROOT/tools
#+end_src

** Troubleshooting:
*** If C# Dev Kit doesn't work:

1. Make sure you installed =visual-studio-code-bin= (not =code=)
2. Sign in with Microsoft account in VS Code
3. Restart VS Code after installing extensions

*** If IntelliSense is slow:

#+begin_src bash
# Increase inotify limits
echo 'fs.inotify.max_user_watches=524288' | sudo tee -a /etc/sysctl.conf
sudo sysctl -p
#+end_src

This setup will give you the complete VS Code experience on Arch Linux with full C# development capabilities, including debugging, IntelliSense, and project management!

* DONE Setting up a C# Language Server (csharp-ls) on an Air-Gapped Windows System :windows:emacs:eglot:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250627222703-emacs--Setting-up-CSharp-Language-Server-csharp-ls-on-Air-Gapped-Windows-System
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-06-27 22:27>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250627222703-emacs--Setting-up-CSharp-Language-Server-csharp-ls-on-Air-Gapped-Windows-System.jpg
:END:

For a little while now, I have been developing C# applications at work and on Windows!, possibly the perfect storm for Emacs, but actually, it copes pretty well, especially with eglot and the LSP server OmniSharp.

#+hugo: more

But recently my work setup has become even more air-gapped, and unfortunately, I reached a point where I couldn't get eglot and OmniSharp working together. I gave it a really good try, but I think the mishmash and dependency installation madness finally took a toll.

It has something to do with trying to find MSBuild.exe, but due to my potentially wonky installation, I couldn't figure out how to detect it. If Visual Studio is installed on the system, there are no problems; however, offline installation, even of the Community edition, is not an easy task.

So, the solution? Well, I thought I would try another C# LSP in the form of csharp-ls. Its deliverable form is a NuGet package, which can be extracted, placed in the relevant location, and then you're pretty much off and running!

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250627222703-emacs--Setting-up-CSharp-Language-Server-csharp-ls-on-Air-Gapped-Windows-System.jpg]]

So here is how I did it:

** Step 1: Download csharp-ls nuget Components

On a machine with internet access (which fortunately I do have access to):

*** Download csharp-ls

- Go to the [[https://www.nuget.org/packages/csharp-ls/][csharp-ls NuGet page]]
- Click "Download package" to get the =.nupkg= file
- Rename the file from =.nupkg= to =.zip=
- Extract the contents

** Step 2: Install csharp-ls (Airgapped Machine)

1. Create a directory in your Emacs installation:

   #+begin_src cmd
   mkdir "c:\path\to\emacs\bin\csharp-ls"
   #+end_src

2. Copy the extracted csharp-ls contents to this directory. The key file you need is:

   #+begin_src
   tools\net9.0\any\CSharpLanguageServer.dll
   #+end_src

** Step 3: Configure Emacs

Add this configuration to your Emacs init file:

#+begin_src elisp
;; Configure csharp-ls as the language server for C#
(setq eglot-server-programs
      '((csharp-mode . ("dotnet" "c:/path/to/emacs/bin/csharp-ls/tools/net9.0/any/CSharpLanguageServer.dll"))))
#+end_src

** Step 4: Set Up Your C# Project Structure

Basically defining a source code collection as a project in Emacs. This can be a solution file, a source code control directory or as I generally have set up, an empty .project file

** Step 5: Set up paths

This may not be needed, but for my own sanity and just in case, absorb the new directory in to the PATH and exec-path variables.

#+begin_src elisp
(when (eq system-type 'windows-nt)
  (let ((xPaths
         `(
           ,(expand-file-name "~/bin/csharp-ls/tools/net9.0/any")
           )))
    (setenv "PATH" (concat
                    (mapconcat 'identity xPaths ";")))
    (setq exec-path (append (split-string winPaths ";") xPaths (list "." exec-directory)))))
#+end_src

So it works as I had it with =OmniSharp= and that really is all I can ask for, lets see how I get on!

* DONE Ollama-Buddy 0.13.1: Curl backend support and some optimizations :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250621100507-emacs--Ollama-Buddy-0-13-1-Curl-backend-support-and-some-optimizations
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-06-21 10:05>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg
:END:

This is more of a maintenance update. The main headline is the addition of an option to select a curl-based backend for those who may encounter networking issues. By default, ollama-buddy uses built-in low-level networking calls, but if you have network issues, you can now switch to curl!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg]]

** <2025-06-21> *0.13.1*

Refactored content register processing to be more efficient and added a new Emacs package brainstorming prompt file.

** <2025-06-15> *0.13.0*

Added curl communication backend with fallback support

- Added ollama-buddy-curl.el as separate backend implementation
- Implemented backend dispatcher system in ollama-buddy-core.el
- Updated all async functions to use backend dispatcher
- Added curl backend validation and testing functions
- Maintained full compatibility with existing network process backend

When building Emacs packages that communicate with external services, network connectivity can sometimes be a pain point. While Emacs's built-in =make-network-process= works great in most cases, some users have encountered issues on certain systems or network configurations. That's why now I have added a curl-based communication backend to give you an additional option, who knows, maybe it will solve your ollama communication issues!

The original ollama-buddy implementation relied exclusively on Emacs's native network process functionality. While this works well for most users, I occasionally heard from users who experienced network process failures/flakiness on certain systems.

Rather than trying to work around these edge cases in the network process code, I took a different approach: I added curl as an alternative communication backend! This gives users a battle-tested, widely-available HTTP client as a fallback option.

Users can enable the curl backend with a simple customization:

#+begin_src elisp
(use-package ollama-buddy
  :bind
  ("C-c o" . ollama-buddy-menu)
  ("C-c O" . ollama-buddy-transient-menu-wrapper)
  :config
  ;; Load curl backend first
  (require 'ollama-buddy-curl nil t)
  
  ;; Then set the backend
  (setq ollama-buddy-communication-backend 'curl))
#+end_src

and then switch backends from the chat buffer =C-c e=

The curl backend supports everything the network backend does:

- Real-time streaming responses
- Vision model support with image attachments
- File attachments and context
- All Ollama API parameters
- Multishot model sequences

If curl is selected but not available, the system automatically falls back to the network process with a helpful warning message.

From a user perspective, the backend choice is largely transparent. The main indicators are:

- Status line shows =[C]= for curl or =[N]= for network
- Process list shows =ollama-chat-curl= vs =ollama-chat-stream= processes
- Curl backend shows "Curl Processing..." in status messages

Everything else - streaming behaviour, response formatting, error handling - works identically regardless of the backend.

** <2025-05-31> *0.12.1*

Optimized Unicode escape function to fix blocking with large file attachments

- Fixed UI blocking when sending large attached files
- Used temp buffer with delete-char/insert instead of repeated concat calls
- Reduced processing time from minutes to milliseconds for large payloads

* DONE Emacs dired with Ultra-Lightweight Visual Icons :emacs:2025:dired:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250612223745-emacs--Emacs-Dired-with-Ultra-Lightweight-Visual-Icons
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-06-12 22:37>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250612223745-emacs--Emacs-Dired-with-Ultra-Lightweight-Visual-Icons.jpg
:END:

If you spend any time browsing files in Emacs, you've probably wished for a bit more visual distinction in dired buffers?. While packages like =all-the-icons-dired= provide beautiful icon sets, they come with dependencies, font requirements, and potential compatibility issues. What if you could get meaningful visual file type indicators with just a few simple lines of pure Elisp? I have adapted the original idea provided by =Emacs-solo= and focused more on the earlier Unicode characters that are most likely to always be present in an Emacs environment.

Popular dired icon packages often require:

- Installing specific icon fonts
- Managing font fallbacks across different systems
- Dealing with alignment issues in terminal Emacs
- Large dependency chains that slow down startup
- Compatibility headaches when sharing configs

I have also noticed that Emacs can just crash if it is dealing with an icon that isn't installed on the system.

Here's an implementation that adds visual file type indicators using only standard Unicode characters. Of course the icons-map isn't exhaustive but might be a sensible minimal starting point.

#+begin_src elisp
(defvar dired-icons-map
  '(("el" . "λ") ("rb" . "◆") ("js" . "○") ("ts" . "●") ("json" . "◎") ("md" . "■") 
    ("txt" . "□") ("html" . "▲") ("css" . "▼") ("png" . "◉") ("jpg" . "◉") 
    ("pdf" . "▣") ("zip" . "▢") ("py" . "∆") ("c" . "◇") ("sql" . "▦") 
    ("mp3" . "♪") ("mp4" . "▶") ("exe" . "▪")))

(defun dired-add-icons ()
  (when (derived-mode-p 'dired-mode)
    (let ((inhibit-read-only t))
      (save-excursion
        (goto-char (point-min))
        (while (and (not (eobp)) (< (line-number-at-pos) 200))
          (condition-case nil
              (let ((line (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
                (when (and (> (length line) 10)
                           (string-match "\\([rwxd-]\\{10\\}\\)" line)
                           (dired-move-to-filename t)
                           (not (looking-at "[▶◦λ◆○●◎■□▲▼◉▣▢◇∆▦♪▪] ")))
                  (let* ((is-dir (eq (aref line (match-beginning 1)) ?d))
                         (filename (and (string-match "\\([^ ]+\\)$" line) (match-string 1 line)))
                         (icon (cond (is-dir "▶")
                                    ((and filename (string-match "\\.\\([^.]+\\)$" filename))
                                     (or (cdr (assoc (downcase (match-string 1 filename)) dired-icons-map)) "◦"))
                                    (t "◦"))))
                    (insert icon " "))))
            (error nil))
          (forward-line))))))

(add-hook 'dired-after-readin-hook 'dired-add-icons)
#+end_src

The icons use only standard Unicode geometric shapes and mathematical symbols that have been supported in every font since the 1990s. No special fonts required, it works identically in:

- Terminal Emacs
- GUI Emacs on any platform  
- Ancient and modern Emacs versions

There are some advantages to be had:

- *Zero dependencies*: Pure Elisp, no external packages
- *Tiny footprint*: 30 lines vs hundreds in full icon packages
- *Instant startup*: No font loading or icon caching
- *Robust error handling*: Gracefully skips problematic files
- *Performance limits*: Processes max 200 files to prevent freezing but of course that can be modified to taste

Once added to your config, it just works. No font updates, no package maintenance, no breaking changes from upstream dependencies.

Here is a typical example:

After:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250612223745-emacs--Emacs-Dired-with-Ultra-Lightweight-Visual-Icons.jpg]]

Before:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250612223745-emacs--Emacs-Dired-with-Ultra-Lightweight-Visual-Icons2.jpg]]

Want different icons? Just modify the =dired-icons-map=:

#+begin_src elisp
;; Prefer asterisks for code files?
("js" . "*") ("py" . "*") ("rb" . "*")

;; Like filled shapes for documents?  
("md" . "▪") ("txt" . "▪") ("pdf" . "▪")

;; Add your own file types
("log" . "□") ("cfg" . "○") ("bak" . "▫")
#+end_src

Simply copy the code into your =init.el= and off you go!

* DONE Building Your Own Orderless Style Completion in Emacs Lisp :elisp:emacs:2025:completion:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250604085817-emacs--Building-Your-Own-Orderless-Style-Completion-in-Emacs-Lisp
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-06-04 09:40>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250604085817-emacs--Building-Your-Own-Orderless-Style-Completion-in-Emacs-Lisp.jpg
:END:

While packages like =orderless= provide flexible “any word, any order” completion, sometimes you want something lightweight and easy to tweak (well I do anyway). In this post, I’ll show you how to implement a simple orderless-like completion style using only Emacs Lisp, and how to integrate it smoothly into your workflow.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250604085817-emacs--Building-Your-Own-Orderless-Style-Completion-in-Emacs-Lisp.jpg]]

Traditional completion in Emacs often matches prefixes or substrings, but sometimes you want to type a few key parts of a word, in any order, and jump straight to your target. That’s what =orderless= and similar completion styles allow. But what if you want to write your own, or experiment with the logic?, well I will show you how...

Let’s walk through the logic:

#+begin_src elisp
(defun simple-orderless-completion (string table pred point)
  "Enhanced orderless completion with better partial matching."
  (let* ((words (split-string string "[-, ]+"))
         (patterns (mapcar (lambda (word)
                             (concat "\\b.*" (regexp-quote word) ".*"))
                           words))
         (full-regexp (mapconcat 'identity patterns "")))
    (if (string-empty-p string)
        (all-completions "" table pred)
      (cl-remove-if-not
       (lambda (candidate)
         (let ((case-fold-search completion-ignore-case))
           (and (cl-every (lambda (word)
                            (string-match-p
                             (concat "\\b.*" (regexp-quote word))
                             candidate))
                          words)
                t)))
       (all-completions "" table pred)))))
#+end_src

** *What’s Happening Here?*

- *Word Splitting:*
  
  The user's input (a string) is split into words on spaces, dashes, or commas. This produces a list of "search terms." This means that, in the minibuffer, the word separator can be any of these characters. I was initially really faffing around and struggling to work out how to insert a space between words in the minibuffer, as it seems to perform some form of completion. However, I eventually figured out that =M-SPC= actually inserts a space, allowing you to separate words. I use =fido-mode=, so I'm not sure if this is the same for other minibuffer completion systems.

  After initially adding in the comma separator however I found that I actually prefer it, it is easier to access and I don't think any keywords, functions e.t.c will typically contain a comma?

- *Pattern Construction:*
  
  For each word, a regex pattern is constructed: =\\b.*WORD.*=.  
  This means: “find a word boundary, followed by any characters, then the word, then anything else.” This is a bit looser than strict word matching, and you can tune it.
  
- *Candidate Filtering:*
  
  We generate all possible completions with =all-completions= and then filter them down. For a candidate to match, all the search terms (words) must appear somewhere, in any order.

- *Case Sensitivity:*
  
  Matching respects =completion-ignore-case=, so your results will be case-insensitive if you want of course.

** *Registering and Using the Style*

To make Emacs aware of your new completion style, add it to =completion-styles-alist=:

#+begin_src elisp
(add-to-list 'completion-styles-alist
             '(simple-orderless simple-orderless-completion
                                simple-orderless-completion))
#+end_src

** *Contextual Use: Minibuffer Only*

You might not want this style everywhere (which I suspect is likely). For example, in file completion you might prefer strict prefix matching. So, let’s activate it only in the minibuffer:

#+begin_src elisp
(defun setup-minibuffer-completion-styles ()
  "Use orderless completion in minibuffer, regular completion elsewhere."
  ;; For minibuffer: use orderless first, then fallback to flex and basic
  (setq-local completion-styles '(basic simple-orderless flex substring)))

;; Hook into minibuffer setup
(add-hook 'minibuffer-setup-hook #'setup-minibuffer-completion-styles)
#+end_src

** *Tweaking and Extending*

- *Pattern Tuning:*
  
  The regexes can be made stricter or looser (e.g., remove =\\b= for more “fuzzy” matching).
  
- *Word Separators:*
  
  You can split on other characters if your workflow uses different delimiters.
  
- *Order of Styles:*

  Adjust the order in =completion-styles= to prefer your custom style over others. I found that if the =simple-orderless= style was listed first, pressing Tab to bring up the completions buffer doesn't work, which I like to use sometimes, so that is why =basic= is first.

*** *Conclusion*

With just a handful of lines, you can build your own orderless-like completion style, giving you full control and transparency. This is a great starting point for experimenting with more advanced completion logic, and a good illustration of the power of Emacs’ built-in completion framework!

* DONE Bank Buddy - Your Financial Analysis Companion for Emacs! :emacs:bank_buddy:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250528081648-emacs--Your-Financial-Analysis-Companion-for-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-05-28 08:50>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250528081648-emacs--Your-Financial-Analysis-Companion-for-Emacs.jpg
:END:

I created a new package!, here are the details:

Bank Buddy is an Emacs package that provides financial analysis and reporting capabilities for your bank statements. It processes CSV bank statement data, categorizes transactions using customizable patterns, and generates detailed reports in Org-mode format.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250528081648-emacs--Your-Financial-Analysis-Companion-for-Emacs.jpg]]

It does not depend on any external account system, and the analysis is handled by =elisp=. The only external tool that may be required is =gnuplot= to visualize the generated data.

Here is an example of the type of report that is generated (obviously using test data :))

#+attr_org: :width 300px
#+attr_html: :width 100%
https://github.com/captainflasmr/bank-buddy/blob/main/tests/bank-statement_report/bank-statement_report.org

See https://github.com/captainflasmr/bank-buddy/blob/main/docs/bank-buddy.org for the manual!

** Key Features

- *Smart Transaction Categorization*: Auto-categorizes transactions based on customizable regex patterns
- *Financial Reports*: Generates detailed reports in Org-mode with:
  - Transaction summaries and overviews
  - Spending category analysis
  - Top merchant identification
  - Monthly spending patterns with visual representation
  - Recurring subscription detection
- *Interactive Category Management*: Edit and refine categorization patterns directly from reports
- *Data Visualizations*: Generates charts and graphs using external gnuplot scripts
- *No Reliance on External Accounting System* - Analysis is all Emacs built-in
- *Asynchronous Processing*: Efficiently handles large bank statements without blocking Emacs

** Screenshots
*** Monthly Spending categories

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/financial-report--monthly-spending-categories.png]]

*** Monthly Spending categories (stacked)

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/financial-report--monthly-spending-stacked.png]]

** Quick Start

1. Export your bank statement as a CSV file
2. Edit CSV using =csv-mode= for all lines to the format DATE,DESCRIPTION,AMOUNT
3. Open CSV file
4. Run: =M-x bank-buddy-generate=
5. Open the generated report

** Generate gnuplots

Since version 0.2.0, Bank Buddy generates external gnuplot scripts that are executed via =call-process=. You need to have gnuplot installed on your system.

To install gnuplot:
- Linux: =sudo apt install gnuplot= (or equivalent for your distribution)
- macOS: =brew install gnuplot=
- Windows: Download from http://www.gnuplot.info/

The generated reports will include links to both the gnuplot script files (.gp) and data files (.dat) for each visualization. This allows for:
- Easy customization of plots by editing the gnuplot scripts
- Regeneration of plots without reprocessing the CSV data
- Better control over visualization settings

** Usage Guide
*** Understanding CSV Format

Bank Buddy expects CSV files with at least the following columns:

- Transaction date
- Transaction description
- Debit amount

Different banks format their CSV exports differently. You may need to preprocess your CSV to match this format, I would advise to use the package =csv-mode=, open up a csv file and =C-c C-k= you way to removed unwanted columns so all you have left are those described above.

*** Example CSV

#+begin_src csv
Date,Description,Amount
2024-06-30,PAYPAL TRANSFER,28.50
2024-06-28,JUST-EAT TAKEAWAY,32.99
2024-06-25,ASDA GROCERIES,78.50
2024-06-22,AUDIBLE SUBSCRIPTION,7.99
2024-06-20,THREE MOBILE,25.00
2024-06-18,RIVER-ISLAND CLOTHES,85.99
2024-06-15,SPOTIFY PREMIUM,9.99
2024-06-12,RAILWAY TICKET,42.00
2024-06-10,AMAZON PURCHASE,55.25
2024-06-07,NETFLIX SUBSCRIPTION,13.99
2024-06-05,VIRGIN-MEDIA MONTHLY,65.50
2024-06-03,NOTEMACHINE WITHDRAWAL,100.00
2024-06-01,KATHERINE ALLOWANCE,200.00
2024-05-30,DENTIST APPOINTMENT,60.00
2024-05-28,SKY-BETTING RACES,25.00
2024-05-25,WAITROSE GROCERIES,115.45
2024-05-22,NOWTV SUBSCRIPTION,9.99
2024-05-20,PAYPAL TRANSFER,40.00
2024-05-18,THREE MOBILE,25.00
2024-05-15,UBER RIDE,18.25
2024-05-12,SAINSBURYS GROCERIES,105.75
2024-05-10,AMAZON PURCHASE,32.99
2024-05-07,NETFLIX SUBSCRIPTION,13.99
2024-05-05,VIRGIN-MEDIA MONTHLY,65.50
2024-05-02,KATHERINE ALLOWANCE,200.00
2024-04-30,DELIVEROO FOOD,25.50
2024-04-28,PRIME VIDEO RENTAL,4.99
2024-04-25,PETS AT HOME,45.00
2024-04-23,RAILWAY TICKET,18.50
2024-04-20,YOUTUBE PREMIUM,11.99
2024-04-18,IKEA FURNITURE,245.99
2024-04-15,TESCO GROCERIES,68.95
2024-04-12,STARBUCKS COFFEE,9.85
2024-04-10,AMAZON PURCHASE,78.50
2024-04-07,NETFLIX SUBSCRIPTION,13.99
2024-04-05,CLAUDE SUBSCRIPTION,20.00
2024-04-03,VIRGIN-MEDIA MONTHLY,65.50
2024-04-01,KATHERINE ALLOWANCE,200.00
2024-03-30,PAYPAL TRANSFER,45.00
2024-03-28,BET365 RACES,30.00
2024-03-25,UBER RIDE,15.75
2024-03-22,WITHDRAWAL ATM,50.00
2024-03-20,THREE MOBILE,25.00
2024-03-17,SAINSBURYS GROCERIES,95.25
2024-03-15,SPECSAVERS APPOINTMENT,25.00
2024-03-12,RAILWAY TICKET,22.50
2024-03-10,AMAZON PURCHASE,28.99
2024-03-07,NETFLIX SUBSCRIPTION,13.99
2024-03-05,NATWEST-BANK-REFERENCE RENT,750.00
2024-03-03,NEXT RETAIL-LTD,125.00
2024-03-01,VIRGIN-MEDIA MONTHLY,65.50
2024-02-28,YOUTUBE PREMIUM,11.99
2024-02-25,SKY SUBSCRIPTION,45.99
2024-02-23,ASDA GROCERIES,92.45
2024-02-20,DISNEY+ SUBSCRIPTION,7.99
2024-02-18,PAYPAL TRANSFER,35.99
2024-02-15,TESCO GROCERIES,75.40
2024-02-12,WATERSTONES BOOK,15.99
2024-02-10,AMAZON PURCHASE,65.75
2024-02-07,NETFLIX SUBSCRIPTION,13.99
2024-02-05,ROYAL-MAIL POSTAGE,8.95
2024-02-03,RAILWAY TICKET,35.45
2024-02-01,KATHERINE ALLOWANCE,200.00
2024-01-30,UBER RIDE,12.50
2024-01-28,STARBUCKS COFFEE,4.95
2024-01-25,THREE MOBILE,25.00
2024-01-20,AMAZON PURCHASE,45.30
2024-01-18,SAINSBURYS GROCERIES,88.75
2024-01-15,NETFLIX SUBSCRIPTION,13.99
2024-01-12,PAYPAL TRANSFER,22.45
2024-01-10,VIRGIN-MEDIA MONTHLY,65.50
2024-01-07,SKY-BETTING RACES,20.00
2024-01-05,PAYPAL TRANSFER,55.99
#+end_src

*** Generating a Report

To generate a financial report =M-x bank-buddy-generate-report=

You'll be prompted to select an input CSV file and specify the output Org file.

The package processes the data asynchronously and a buffer will appear reporting on the analysis progress, so Emacs remains responsive even with large CSV files.

When processing is complete, you'll be asked if you want to open the generated report.

*** Understanding the Report

A typical Bank Buddy report includes:

**** Summary Overview

- Total transactions analyzed
- Date range
- Total, average daily, and weekly spending

**** Top Spending Categories

- Ranked list of spending categories
- Total amount, percentage, and monthly/yearly averages
- Links to generated gnuplot scripts and data files

**** Monthly Spending Patterns

- Month-by-month spending visualization
- Category breakdown for each month
- Highest and lowest spending months
- Links to visualization files (*.gp, *.dat)

**** Monthly Category Breakdowns

- Detailed charts for each month showing spending by category
- Consistent color coding across months for easy comparison
- Links to individual gnuplot scripts for customization

**** Top Merchants

- Your highest-spending merchants
- Total amount, percentage, and monthly/yearly averages
- Links to generated visualization files

**** Recurring Subscriptions

- Detected recurring payments
- Estimated monthly cost
- Frequency analysis (weekly, bi-weekly, monthly, annual)

**** Transaction Size Distribution

- Analysis of transaction sizes (under £10, £10-50, £50-100, over £100)

**** Unmatched Transactions

- List of transactions that didn't match specific categories
- Suggested patterns to add to your customization

*** Managing Transaction Categories

Bank Buddy comes with predefined category patterns, but you'll likely want to customize these for your personal transactions. The package includes an interactive mode for managing categories.

When viewing a report, you can:

1. Navigate to an unmatched transaction (in the "Unmatched Transactions" section)
2. Press =C-c C-a= to add it to a category
3. Choose an existing category or create a new one
4. Optionally save the updated category definitions to your init file
5. Regenerate the report to see the changes

To manage existing categories or add new ones manually, customize =bank-buddy-core-cat-list-defines=.

*** Category Format

Categories are defined as patterns in the form:

#+begin_src elisp
(REGEX-PATTERN CATEGORY-CODE)
#+end_src

Where:
- =REGEX-PATTERN= is a regular expression that matches transaction descriptions
- =CATEGORY-CODE= is a short code representing the category (e.g., "fod" for food)

For example:
#+begin_src elisp
("amazon\\|amz" "amz")  ; Amazon purchases
("netflix\\|spotify\\|youtube" "str")  ; Streaming services
#+end_src

You can customize category codes and their display names by modifying =bank-buddy-core-category-names=.

*** Updating and Regenerating Reports

If you add or modify category patterns after generating a report:

1. With the report open, enable Bank Buddy Category mode if not already active: =M-x bank-buddy-cat-mode=
2. Press =C-c C-r= to regenerate the report with the updated categories

The report will be refreshed with the new categorization rules.

** Example Workflow

- *Generate Initial Report* =M-x bank-buddy-generate-report=

- *Review Unmatched Transactions*
   Navigate to the "Unmatched Transactions" section of the report.

- *Categorize Transactions*
   - Place cursor on an unmatched transaction
   - =C-c C-a= to add it to a category
   - Choose an existing category or create a new one

- *Regenerate Report*
   - =C-c C-r= to see your changes

- *Save Category Definitions*
   When prompted, choose to save your category definitions to your init file.

** Customization
*** Core Settings

#+begin_src elisp
;; Exclude large transactions from analysis
(setq bank-buddy-core-exclude-large-txns t)
(setq bank-buddy-core-large-txn-threshold 2000)

;; Number of occurrences to detect subscriptions
(setq bank-buddy-core-subscription-min-occurrences 3)

;; Number of top items to display
(setq bank-buddy-core-top-spending-categories 5)
(setq bank-buddy-core-top-merchants 5)
#+end_src

*** Customizing Category Patterns

You can customize the category patterns by setting =bank-buddy-core-cat-list-defines=:

#+begin_src elisp
(customize-set-variable 'bank-buddy-core-cat-list-defines
  '(("amazon\\|amz" "amz")
    ("netflix\\|spotify" "str")
    ("uber\\|lyft" "txi")
    ("sainsburys\\|tesco\\|asda" "fod")
    ;; Add your own patterns here
    (".*" "o")))  ; Catch-all pattern should be last
#+end_src

*** Customizing Category Names

Category codes are mapped to human-readable names via =bank-buddy-core-category-names=:

#+begin_src elisp
(customize-set-variable 'bank-buddy-core-category-names
  '(("amz" . "Amazon")
    ("str" . "Streaming Services")
    ("txi" . "Taxi & Rideshare")
    ("fod" . "Groceries")
    ;; Add your own mappings here
    ("o" . "Other")))
#+end_src

*** Customizing Subscription Detection

Define subscription patterns for better detection of recurring payments:

#+begin_src elisp
(customize-set-variable 'bank-buddy-core-subscription-patterns
  '(("NETFLIX" . "Netflix")
    ("SPOTIFY" . "Spotify")
    ("AMAZON PRIME" . "Amazon Prime")
    ;; Add your own patterns here
    ))
#+end_src

** Advanced Usage
*** Integration with Other Financial Tools

Bank Buddy reports are generated as Org-mode files, making them compatible with other Org-based tools:

- Export to HTML, PDF, or other formats with Org export functions
- Use =org-capture= to add notes to specific transactions or categories

*** Custom Visualization

Bank Buddy generates visualizations using external gnuplot scripts. You can customize these by:

1. Editing the generated .gp files in the report directory
2. Creating your own gnuplot scripts based on the generated .dat files
3. Running the scripts manually with =gnuplot filename.gp=

*** Keyboard Shortcuts

When viewing a report with =bank-buddy-cat-mode= enabled:

- =C-c C-a=: Add the transaction at point to a category
- =C-c C-r=: Regenerate the report with current category definitions

** Caveats and Tips

- *CSV Format*: Bank Buddy expects a CSV with date, description, and amount columns
- *Performance*: For very large CSV files (10K+ rows), the async processing helps but may still take time
- *Categorization*: Start with broad patterns and refine as needed
- *Visualization*: Ensure gnuplot is installed on your system for chart generation
- *Saving Patterns*: Always save your category patterns to persist between sessions

** Comparison with Other Financial Packages

Several Emacs packages exist for financial management, but they serve different purposes. Here's how Bank Buddy compares to other notable financial packages:

*** Ledger-mode

[[https://github.com/ledger/ledger-mode][Ledger-mode]] is an Emacs interface to the command-line Ledger accounting system.

*Key differences:*
- Ledger is a complete double-entry accounting system; Bank Buddy is focused on bank statement analysis
- Ledger requires manual transaction entry or carefully formatted imports; Bank Buddy automates categorization
- Ledger offers more comprehensive accounting features (accounts, assets, liabilities); Bank Buddy focuses on spending insights
- Bank Buddy provides visual spending breakdowns and charts; Ledger focuses on accurate accounting

*When to use Ledger:* For complete personal finance tracking, investments, budgeting, and double-entry accounting.  
*When to use Bank Buddy:* For quick analysis of bank statements and visualizing spending patterns.

*** HLedger-mode

[[https://github.com/narendraj9/hledger-mode][HLedger-mode]] is an Emacs major mode for working with hledger, a plain-text accounting system similar to Ledger.

*Key differences:*
- HLedger, like Ledger, is a full double-entry accounting system; Bank Buddy focuses on bank statement analysis
- HLedger requires manual transaction entry or formatted imports; Bank Buddy automates categorization
- HLedger offers comprehensive accounting features (multiple currencies, time reporting); Bank Buddy emphasizes spending insights
- Bank Buddy provides visual spending breakdowns; HLedger focuses on textual reports and balances

*When to use HLedger-mode:* For detailed personal finance tracking, multi-currency support, and generating various financial reports.  
*When to use Bank Buddy:* For quick analysis of bank statements and visualizing spending patterns without learning a full accounting system.

*** Elbank

[[https://github.com/NicolasPetton/Elbank][Elbank]] is a personal finance reporting tool for Emacs that uses Weboob to fetch data from bank websites.

*Key differences:*
- Elbank can automatically fetch transactions from supported banks; Bank Buddy works with CSV exports
- Elbank focuses on reporting and visualization; Bank Buddy offers both analysis and reporting
- Elbank requires Weboob setup and configuration; Bank Buddy works directly with CSV files
- Bank Buddy provides customizable transaction categorization; Elbank may rely on bank-provided categories

*When to use Elbank:* For automated tracking of multiple bank accounts with direct data fetching and basic reporting.  
*When to use Bank Buddy:* For detailed analysis and categorization of bank statements, especially when working with CSV exports or when bank integration isn't available or desired.

*** Beancount-mode

[[https://github.com/beancount/beancount-mode][Beancount-mode]] is an Emacs mode for Beancount, another plain-text accounting system.

*Key differences:*
- Beancount, like Ledger, is a full double-entry accounting system
- Beancount has stricter syntax requirements than Ledger
- Bank Buddy offers automatic categorization and reporting, while Beancount requires manual entry
- Beancount generates sophisticated reports, but requires more setup and knowledge

*When to use Beancount:* For precise, auditable personal accounting with strict validation.  
*When to use Bank Buddy:* For simple spending analysis without learning accounting principles.

*** csv-mode and orgtbl-mode

Some users analyze financial CSV data using built-in Emacs packages like csv-mode combined with org-table functionality.

*Key differences:*
- These are general-purpose tools that require manual customization for financial analysis
- Bank Buddy provides specialized, financial-specific analysis and visualization
- Bank Buddy automatically categorizes transactions based on patterns
- Bank Buddy generates reports without manual processing

*When to use csv/orgtbl-mode:* For custom, one-off analysis of financial data.  
*When to use Bank Buddy:* For consistent, repeatable analysis of bank statements.

** Roadmap :roadmap:

#+RESULTS:
| TODO                      | DOING                                                 | DONE                   |
|---------------------------+-------------------------------------------------------+------------------------|
| Add Paypal break down csv | Highlight bank lines not matched for iterative tweaks | Asynchronous operation |
| Add large sum outlays     | Generate test data and unit test                      |                        |
| Budget Tracking           | Data Visualization                                    |                        |
| AI-Powered Categorization | Better gnuplot autogeneration of plots                |                        |
|                           | Custom Category Mapping                               |                        |

* DONE Ollama Buddy 0.12.0: User Prompt Library, File Attachments, Vision and Context Tracking :ollama_buddy:ollama:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250523135757-emacs--Ollama-Buddy-0-12-0-User-Prompt-Library-File-Attachments-Vision-Context-Tracking
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-05-23 14:10>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg
:END:

There have been quite a few updates recently. The main highlights include support for attachments, so you can push a file to the chat directly from =dired= for potential inclusion in your next query.

Vision support has been added for models that can handle it. If you supply the path to an image file in the chat, it will be processed. This means you can now, for example, extract text from images using models like =o:gemma3:4b=.

I've also introduced the ability to save user system prompts. If you have a favorite prompt, or have crafted one that works especially well for you, you can now save it by category and title in a simple Org format for later recall. Prompt recall now works the same way as Fabric patterns and Awesome ChatGPT prompts. This makes it much easier to display the currently used system prompt concisely in the status bar, as it will be based on the prompt title (and thus likely the role).

What else? Oh yes, I received a request for better context tracking. Now, when context is nearing full capacity, or has exceeded it, it will be indicated in the status bar!

That’s probably it for the major changes. There was also some refactoring, but you probably don't care about that. Anyway, here is the full list of changes:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg]]

** <2025-05-22> *0.12.0*

Full system prompt in the status bar replaced with a more meaningful simple role title

- Added system prompt metadata tracking with title, source, and timestamp registry
- Implemented automatic title extraction and unified completing-read interface
- Enhanced fabric/awesome prompt integration with proper metadata handling
- Improved transient menu organization and org-mode formatting with folding
- Added system prompt history display and better error handling for empty files
- Transient menu has been simplified and reorganised

Previously, the header status bar would show truncated system prompt text like =[You are a helpful assistant wh...]=, making it difficult to quickly identify which prompt was active. Now, the display shows meaningful role titles with source indicators:

- =[F:Code Reviewer]= - Fabric pattern
- =[A:Linux Terminal]= - Awesome ChatGPT prompt  
- =[U:Writing Assistant]= - User-defined prompt

The system now intelligently extracts titles from prompt content by recognizing common patterns like "You are a...", "Act as...", or "I want you to act as...". When these patterns aren't found, it generates a concise title from the first few words.

Behind the scenes, Ollama Buddy now maintains a registry of all system prompts with their titles, sources, and timestamps. This enables new features like system prompt history viewing and better organization across Fabric patterns, Awesome ChatGPT prompts, and user-defined prompts.

The result is a cleaner interface that makes it immediately clear which role your AI assistant is currently embodying, without cluttering the status bar with long, truncated text.

** <2025-05-21> *0.11.1*

Quite a bit of refactoring to generally make this project more maintainable and I have added a starter kit of user prompts.

- Color System Reworking
  - Removed all model color-related functions and variables
  - Removed dependency on =color.el=
  - Replaced with =highlight-regexp= and hashing to =^font-lock= faces, so now using a more native built-in solutions for model colouring rather than shoe-horning in overlays.

- UI Improvements
  - Simplified the display system by leveraging Org mode
  - Added org-mode styling for output buffers
  - Added =org-hide-emphasis-markers= and =org-hide-leading-stars= settings
  - Changed formatting to use Org markup instead of text properties
  - Converted plain text headers to proper Org headings
  - Replaced color properties with Org emphasis (bold)

- History Management Updates
  - Streamlined history editing functionality
  - Improved model-specific history editing
  - Refactored history display and navigation

- System Prompts
  - Added library of system prompts in these categories:
    - analysis (3 prompts)
    - coding (5 prompts)
    - creative (3 prompts)
    - documentation (3 prompts)
    - emacs (10 prompts)
    - general (3 prompts)
    - technical (3 prompts)
    - writing (3 prompts)

** <2025-05-19> *0.11.0*

Added user system prompts management

- You can now save, load and manage system prompts
- Created new transient menu for user system prompts (C-c s)
- Organized prompts by categories with org-mode format storage
- Supported prompt editing, listing, creation and deletion
- Updated key bindings to integrate with existing functionality
- Added prompts directory customization with defaults

This feature makes it easier to save, organize, and reuse your favorite system prompts when working with Ollama language models.

System prompts are special instructions that guide the behavior of language models. By setting effective system prompts, you can:

- Define the AI's role (e.g., "You are a helpful programming assistant who explains code clearly")
- Establish response formats
- Set the tone and style of responses
- Provide background knowledge for specific domains

The new =ollama-buddy-user-prompts= module organizes your system prompts in a clean, category-based system:

- *Save your prompts* - Store effective system prompts you've crafted for future use
- *Categorize* - Prompts are organized by domains like "coding," "writing," "technical," etc.
- *Quick access* - Browse and load your prompt library with completion-based selection
- *Edit in org-mode* - All prompts are stored as org files with proper metadata
- *Manage with ease* - Create, edit, list, and delete prompts through a dedicated transient menu

The new functionality is accessible through the updated key binding =C-c s=, which opens a dedicated transient menu with these options:

- *Save current (S)* - Save your active system prompt
- *Load prompt (L)* - Choose a previously saved prompt
- *Create new (N)* - Start fresh with a new prompt
- *List all Prompts (l)* - View your entire prompt library
- *Edit prompt (e)* - Modify an existing prompt
- *Delete prompt (d)* - Remove prompts you no longer need

If you work frequently with Ollama models, you've likely discovered the power of well-crafted system prompts. They can dramatically improve the quality and consistency of responses. With this new management system, you can:

- Build a personal library of effective prompts
- Maintain context continuity across sessions
- Share prompts with teammates
- Refine your prompts over time

** <2025-05-14> *0.10.0*

Added file attachment system for including documents in conversations

- Added file attachment support with configurable file size limits (10MB default) and supported file types
- Implemented session persistence for attachments in save/load functionality  
- Added attachment context inclusion in prompts with proper token counting
- Created comprehensive attachment management commands:
  - Attach files to conversations
  - Show current attachments in dedicated buffer
  - Detach specific files
  - Clear all attachments
- Added Dired integration for bulk file attachment
- Included attachment menu in transient interface (C-c 1)
- Updated help text to document new attachment keybindings
- Enhanced context calculation to include attachment token usage

You can now seamlessly include text files, code, documentation, and more directly in your conversations with local AI models!

Simply use =C-c C-a= from the chat buffer to attach any file to your current conversation.

The attached files become part of your conversation context, allowing the AI to reference, analyze, or work with their contents directly.

The transient menu has also been updated with a new *Attachment Menu*

#+begin_src 
*File Attachments*
  a Attach file
  w Show attachments
  d Detach file
  0 Clear all attachments
#+end_src

Your attachments aren't just dumped into the conversation - they're intelligently integrated:

- *Token counting* now includes attachment content, so you always know how much context you're using
- *Session persistence* means your attachments are saved and restored when you save/load conversations
- *File size limits* (configurable, 10MB default) prevent accidentally overwhelming your context window

Managing attached files is intuitive with dedicated commands:

- =C-c C-w= - View all current attachments in a nicely formatted org mode buffer, folded to each file
- =C-c C-d= - Detach specific files when you no longer need them
- =C-c 0= - Clear all attachments at once
- =C-c 1= - Access the full attachment menu via a transient interface

Working in Dired? No problem! You can attach files directly from your file browser:

- Mark multiple files and attach them all at once
- Attach the file at point with a single command

Use the configuration as follows:

#+begin_src elisp
(eval-after-load 'dired
  '(progn
     (define-key dired-mode-map (kbd "C-c C-a") #'ollama-buddy-dired-attach-marked-files)))
#+end_src

** <2025-05-12> *0.9.50*

Added context size management and monitoring

- Added configurable context sizes for popular models (llama3.2, mistral, qwen, etc.)
- Implemented real-time context usage display in status bar
- Can display in text or bar display types
- Added context size thresholds with visual warnings
- Added interactive commands for context management:
  - =ollama-buddy-show-context-info=: View all model context sizes
  - =ollama-buddy-set-model-context-size=: Manually configure model context
  - =ollama-buddy-toggle-context-percentage=: Toggle context display
- Implemented context size validation before sending prompts
- Added token estimation and breakdown (history/system/current prompt)
- Added keybindings: C-c $ (set context), C-c % (toggle display), C-c C (show info)
- Updated status bar to show current/max context with fontification

I've added context window management and monitoring capabilities to Ollama Buddy!

This update helps you better understand and manage your model's context usage, preventing errors and optimizing your conversations.

Enable it with the following:

#+begin_src elisp
(setq ollama-buddy-show-context-percentage t)
#+end_src

*** Usage

After implementing these changes:

1. *Text mode*: Shows =1024/4096= style display
2. *Bar mode* (default): Shows =███████░░░░ 2048= style display
3. Use =C-c 8= to toggle between modes
4. The *Text mode* will change fontification based on your thresholds:
   - Normal: regular fontification
   - (85%+): underlined and bold
   - (100%+): inverse video and bold
5. The *Bar mode* will just fill up as normal

The progress bar will visually represent how much of the context window you're using, making it easier to see at a glance when you're approaching the limit.

*** Implementation Details
**** Context Size Detection

Determining a model's context size proved more complex than expected. While experimenting with parsing model info JSON, I discovered that context size information can be scattered across different fields. Rather than implementing a complex JSON parser (which may come later), I chose a pragmatic approach:

I created a new =defcustom= variable =ollama-buddy-fallback-context-sizes= that includes hard-coded values for popular Ollama models. The fallback mechanism is deliberately simple: substring matching followed by a sensible default of 4096 tokens.

#+begin_src elisp
(defcustom ollama-buddy-fallback-context-sizes
  '(("llama3.2:1b" . 2048)
    ("llama3:8b" . 4096)
    ("tinyllama" . 2048)
    ("phi3:3.8b" . 4096)
    ("gemma3:1b" . 4096)
    ("gemma3:4b" . 8192)
    ("llama3.2:3b" . 8192)
    ("llama3.2:8b" . 8192)
    ("llama3.2:70b" . 8192)
    ("starcoder2:3b" . 8192)
    ("starcoder2:7b" . 8192)
    ("starcoder2:15b" . 8192)
    ("mistral:7b" . 8192)
    ("mistral:8x7b" . 32768)
    ("codellama:7b" . 8192)
    ("codellama:13b" . 8192)
    ("codellama:34b" . 8192)
    ("qwen2.5-coder:7b" . 8192)
    ("qwen2.5-coder:3b" . 8192)
    ("qwen3:0.6b" . 4096)
    ("qwen3:1.7b" . 8192)
    ("qwen3:4b" . 8192)
    ("qwen3:8b" . 8192)
    ("deepseek-r1:7b" . 8192)
    ("deepseek-r1:1.5b" . 4096))
  "Mapping of model names to their default context sizes.
Used as a fallback when context size can't be determined from the API."
  :type '(alist :key-type string :value-type integer)
  :group 'ollama-buddy)
#+end_src

This approach may not be perfectly accurate for all models, but it's sufficient for getting the core functionality working. More importantly, as a =defcustom=, users can easily customize these values for complete accuracy with their specific models. Users can also set context values within the chat buffer through =C-c C= (Show Context Information) for each individual model if desired.

This design choice allowed me to focus on the essential features without getting stuck on complex context retrieval logic.

One final thing!, if the ~num_ctx: Context window size in tokens~ is set, then that number will also be taken into consideration.  An assumption will be made that the model is honouring the context size requested and will incorporated into the context calculations accordingly.

**** Token Estimation

For token counting, I've implemented a simple heuristic: each word (using string-split) is multiplied by 1.3. This follows commonly recommended approximations and works well enough in practice. While this isn't currently configurable, I may add it as a customization option in the future.

*** How to Use Context Management in Practice

The =C-c C= (Show Context Information) command is central to this feature. Rather than continuously monitoring context size while you type (which would be computationally expensive and potentially distracting), I've designed the system to calculate context on-demand when you choose.

**** Typical Workflows

*Scenario 1: Paste-and-Send Approach*

Let's say you want to paste a large block of text into the chat buffer. You can simply:

1. Paste your content
2. Press the send keybinding
3. If the context limit is exceeded, you'll get a warning dialog asking whether to proceed anyway

*Scenario 2: Preemptive Checking*

For more control, you can check context usage before sending:

1. Paste your content
2. Run =C-c C= to see the current context breakdown
3. If the context looks too high, you have several options:
   - Trim your current prompt
   - Remove or simplify your system prompt
   - Edit conversation history using Ollama Buddy's history modification features
   - Switch to a model with a larger context window

*Scenario 3: Manage the Max History Length*

Want tight control over context size without constantly monitoring the real-time display? Since conversation history is part of the context, you can simply limit =ollama-buddy-max-history-length= to control the total context size.

For example, when working with small context windows, set =ollama-buddy-max-history-length= to 1. This keeps only the last exchange (your prompt + model response), ensuring your context remains small and predictable, perfect for maintaining control without manual monitoring.

*Scenario 4: Parameter num_ctx: Context window size in tokens*

Simply set this parameter and off you go!

*** Current Status: Experimental

Given the potentially limiting nature of context management, I've set this feature to *disabled by default*.

But to enable set the following :

#+begin_src elisp
(setq ollama-buddy-show-context-percentage t)
#+end_src

This means:

- Context checks won't prevent sending prompts
- Context usage won't appear in the status line
- However, calculations still run in the background, so =C-c C= (Show Context Information) remains functional

As the feature matures and proves its value, I may enable it by default. For now, consider it an experimental addition that users can opt into.

*** More Details

The status bar now displays your current context usage in real-time. You'll see a fraction showing used tokens versus the model's maximum context size (e.g., "2048/8192"). The display automatically updates as your conversation grows.

Context usage changes fontification to help you stay within limits:

- *Normal font*: Normal usage (under 85%)
- *Bold and Underlined*: Approaching limit (85-100%)
- *Inversed*: At or exceeding limit (100%+)

Before sending prompts that exceed the context limit, Ollama Buddy now warns you and asks for confirmation. This prevents unexpected errors and helps you manage long conversations more effectively.

There are now three new interactive commands:

=C-c $= - Set Model Context Size. Manually configure context sizes for custom or fine-tuned models.

=C-c %= - Toggle Context Display. Show or hide the context percentage in the status bar.
  
=C-c C= - Show Context Information. View a detailed breakdown of:

- All model context sizes
- Current token usage by category (history, system prompt, current prompt)
- Percentage usage

-----

The system estimates token counts for:

- *Conversation history*: All previous messages
- *System prompts*: Your custom instructions
- *Current input*: The message you're about to send

This gives you a complete picture of your context usage before hitting send.

The context monitoring is not enabled by default.

** <2025-05-05> *0.9.44*

- Sorted model names alphabetically in intro message
- Removed multishot writing to register name letters

For some reason, when I moved the .ollama folder to an external disk, the models returned with api/tags were inconsistent, which meant it broke consistent letter assignment. I'm not sure why this happened, but it is probably sensible to sort the models alphabetically anyway, as this has the benefit of naturally grouping together model families.

I also removed the multishot feature of writing to the associated model letter. Now that I have to accommodate more than 26 models, incorporating them into the single-letter Emacs register system is all but impossible. I suspect this feature was not much used, and if you think about it, it wouldn't have worked anyway with multiple model shots, as the register letter associated with the model would just show the most recent response. Due to these factors, I think I should remove this feature. If someone wants it back, I will probably have to design a bespoke version fully incorporated into the ollama-buddy system, as I can't think of any other Emacs mechanism that could accommodate this.

** <2025-05-05> *0.9.43*

Fix model reference error exceeding 26 models #15

Update =ollama-buddy= to handle more than 26 models by using prefixed combinations for model references beyond 'z'. This prevents errors in =create-intro-message= when the local server hosts a large number of models.

** <2025-05-03> *0.9.42*

Added the following to recommended models:

- qwen3:0.6b
- qwen3:1.7b
- qwen3:4b
- qwen3:8b

and fixed pull model

** <2025-05-02> *0.9.41*

Refactored model prefixing again so that when using only ollama models no prefix is applied and is only applied when online LLMs are selected (for example claude, chatGPT e.t.c)

I think this makes more sense and is cleaner for I suspect the majority who may use this package are probably more interested in just using ollama models and the prefix will probably be a bit confusing.

This could be a bit of a breaking change once again I'm afraid for those ollama users that have switched and are now familiar with prefixing "o:", sorry!

** <2025-05-02> *0.9.40*

Added vision support for those ollama models that can support it!

Image files are now detected within a prompt and then processed if a model can support vision processing. Here's a quick overview of how it works:

1. *Configuration*: Users can configure the application to enable vision support and specify which models and image formats are supported.  Vision support is enabled by default.
   
2. *Image Detection*: When a prompt is submitted, the system automatically detects any image files referenced in the prompt.
   
3. *Vision Processing*: If the model supports vision, the detected images are processed in relation to the defined prompt. Note that the detection of a model being vision capable is defined in =ollama-buddy-vision-models= and can be adjusted as required.

4. In addition, a menu item has been added to the custom ollama buddy menu :

   #+begin_src 
   [I] Analyze an Image
   #+end_src

When selected, it will allow you to describe a chosen image. At some stage, I may allow integration into =dired=, which would be pretty neat. :)

* DONE The Smallest of Productivity Gains by Instantly Opening Dired Files when isearching :emacs:dired:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250513085926-emacs--Instantly-Open-Dired-Files-with-Isearch-and-Enter
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-05-13 09:20>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250513085926-emacs--Instantly-Open-Dired-Files-with-Isearch-and-Enter.jpg
:END:

If you’re an Emacs user (which I know you are), especially one who lives in =dired-mode=, you’re probably familiar with the quick power of =isearch= for finding files or directories. But if you’re like me, you might have noticed a tiny speed bump in the workflow: after finding a file or directory with =isearch=, you would typically have to hit =<enter>= to exit the search, and then =<enter>= again to open the entry. That’s two steps for something that feels like it should be one and this has been a very minor annoyance for me for a very long time now.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250513085926-emacs--Instantly-Open-Dired-Files-with-Isearch-and-Enter.jpg]]

I had a little time to shave some more yak hair, so lets try and address this!

The solution I came up with was to add a bit of advice to =isearch-exit=, so now, when you’re in =dired-mode= and you use =isearch= to locate a file or directory, pressing =<enter>= will both exit the search *and* immediately open the file or directory, no need for a second confirmation.

Here’s the magic!

#+begin_src emacs-lisp
(defadvice isearch-exit (after dired-enter-directory-or-file activate)
  "In dired mode, enter directory or open file after isearch."
  (when (eq major-mode 'dired-mode)
    (let ((file (dired-get-file-for-visit)))
      (when file
        (dired-find-file)))))
#+end_src

The only thing I am a little worried about are the side effects, but I guess we shall see...

And another thing, now my =dired= navigation is one step smoother; how much time generally is it going to save me? Was it worth the effort?.

Let’s say, conservatively, that I have pressed that extra Enter 100 times each day. Each press takes, say, 150 ms, accounting for human reaction times, even though it isn’t really a reaction, more of a muscle memory response.

Let’s do the calculations! I have no idea why I’m doing this, but maybe I can validate the amount of time I spent on this for future time-saving gains. Maybe it will make me feel better about the countless hours of yak shaving I have done over many years (with Emacs, of course, although I do have a yak in the garden shed that really needs some attention!)

So, the savings are as follows:

- *Day:* 15 seconds  
- *Week:* 105 seconds  
- *Month:* 7 minutes  
- *Year:* 1 hour 24 minutes

Well, the yearly total is probably about the amount of time I actually took to implement this, so that means in a year I will be making productivity gains! Sweeeeeeet!

* TODO Setting Up a Local Package Archive for Emacs :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250508150623-emacs--Setting-Up-a-Local-Package-Archive-for-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-05-08 15:06>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250508150623-emacs--Setting-Up-a-Local-Package-Archive-for-Emacs.jpg
:END:

A local package archive allows you to test packages as if they were coming from an official repository like MELPA, but with your local files. Here's a detailed guide on how to set one up:

** 1. Create the Archive Directory Structure

First, create a directory structure for your local archive:

#+begin_src bash
mkdir -p ~/.emacs.d/my-local-elpa/archive-contents.d
#+end_src

** 2. Prepare Your Package

Your package should be organized according to the Emacs package format:

#+begin_src 
my-package/
├── my-package.el  # Main file with package headers
├── my-package-utils.el  # Optional additional files
└── ... other files ...
#+end_src

Make sure your main =.el= file includes proper package headers:

#+begin_src elisp
;;; my-package.el --- Description of my package  -*- lexical-binding: t; -*-

;; Author: Your Name <your.email@example.com>
;; Version: 0.1.0
;; Package-Requires: ((emacs "25.1") (dependency1 "1.0") ...)
;; Keywords: convenience
;; URL: https://github.com/yourusername/my-package

;;; Commentary:
;; Brief description of what your package does.

;;; Code:
...
;;; my-package.el ends here
#+end_src

** 3. Create the Package Archive Files
*** 3.1. Build your package tarball

#+begin_src bash
cd /path/to/my-package
tar -cf ../my-package-0.1.0.tar --exclude=.git --exclude=.gitignore .
gzip ../my-package-0.1.0.tar
mv ../my-package-0.1.0.tar.gz ~/my-local-elpa/
#+end_src

*** 3.2. Create the package descriptor

Create a file in =~/my-local-elpa/archive-contents.d/my-package= with this content:

#+begin_src elisp
(1 . [my-package
      (0 1 0)  ; Version
      ((emacs "25.1") (dependency1 "1.0")) ; Requirements
      "Description of my package" ; Description
      tar ; Package type
      nil]) ; Extra info
#+end_src

*** 3.3. Generate the archive-contents file

Create a simple script to generate the archive-contents file:

#+begin_src elisp
(require 'package)

(let ((default-directory "~/.emacs.d/my-local-elpa/")
      package-archive-contents)
  (dolist (file (directory-files "archive-contents.d" t "^[^\\.]"))
    (with-temp-buffer
      (insert-file-contents file)
      (let ((pkg-desc (read (current-buffer))))
        (add-to-list 'package-archive-contents pkg-desc))))
  (with-temp-file "archive-contents"
    (pp package-archive-contents (current-buffer))))
#+end_src

Save this as =~/.emacs.d/generate-archive.el= and run it with:

#+begin_src bash
emacs --batch -l ~/generate-archive.el
#+end_src

** 4. Configure Emacs to Use Your Local Archive

Add to your init file:

#+begin_src elisp
(require 'package)
(add-to-list 'package-archives '("local" . "file:///home/yourusername/my-local-elpa/"))
(package-initialize)
#+end_src

** 5. Use with use-package

Now you can use your local package:

#+begin_src elisp
(use-package my-package
  :ensure t
  :pin local)
#+end_src

** Automation Tip

For easier testing, you can create a Makefile in your package directory:

#+begin_src makefile
VERSION=0.1.0
PACKAGE_NAME=my-package
ARCHIVE_DIR=~/my-local-elpa

.PHONY: install

install:
	@echo "Building package..."
	tar -cf ../$(PACKAGE_NAME)-$(VERSION).tar --exclude=.git --exclude=.gitignore .
	gzip ../$(PACKAGE_NAME)-$(VERSION).tar
	mv ../$(PACKAGE_NAME)-$(VERSION).tar.gz $(ARCHIVE_DIR)/
	@echo "Updating archive-contents..."
	emacs --batch -l ~/generate-archive.el
	@echo "Package $(PACKAGE_NAME)-$(VERSION) installed to local archive"
#+end_src

With this setup, you can run =make install= to update your local archive whenever you make changes to your package.

Would you like me to explain any specific aspect of this process in more detail?

* DONE Discovering Treasures in Emacs-solo :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250507201431-emacs--Discovering-Treasures-in-Emacs-solo
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-05-07 21:45>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250507201431-emacs--Discovering-Treasures-in-Emacs-solo.jpg
:END:

While exploring [[https://github.com/LionyxML/emacs-solo][Emacs-solo]], I was struck by how closely its philosophy aligned with my own [[https://github.com/captainflasmr/Emacs-DIYer][Emacs-DIYer]] project. The parallels were sometimes uncanny, for example, we had independently chosen identical keybindings like "M-s g" for grep functionality. I had been also considering "M-s f" for my find variant and was looking for a home for =recentf=, potentially at "M-g r". There were also some ideas around using other finding tools such as =ripgrep= and =fd= as a callout to some external tools and there were many other similarities.

#+hugo: more

I was particularly intrigued to see =newsticker= included, as I had recently adopted it as an =elfeed= replacement. The =ace-window= alternative implementation also closely mirrored my own single-defun approach.

So, with my first pass through, I have picked out the following goodies to be purloined and incorporated into =Emacs-DIYer=

- dired icon replacements
- Git gutter status overlay
- Hide completion buffer when icomplete in buffer
- ollama alternative directly from ansi-term

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250507201431-emacs--Discovering-Treasures-in-Emacs-solo.jpg]]

-----

Firstly, the dired icon replacement provides visual clarity without requiring the =all-the-icons= packages. While perhaps not essential, it gives me a comfy feel and I think these icons significantly improve the Emacs experience, particularly for frequent dired users like myself.

I pretty much just copied the entire =emacs-solo-dired-icons= section but stripped out the =use-package= as I'm trying to keep =Emacs-DIYer= compatible with older versions of Emacs.  This worked straight out the box (like all the other integrations) and I just needed to make sure I have the requisite font collection installed.

-----

The git status indicator in the dired gutter was a welcome addition I hadn't previously implemented or even considered. It provides immediate visual feedback that feels natural and intuitive, especially coming from a background of extensive version control experience.

Having used =subversion= for over 20 years (before transitioning to =TortoiseSVN= and then =magit= and =vc=), I was already accustomed to status characters like "M" indicating modified files and other single key status key definitions seem consistent to my previous experience, and isn't it great to see them visible in dired!

In summary, this integration complements my existing modeline status indicator, along with =vc= and gives me both file-specific and directory-level version control visibility, noice!

-----

I had been working on replacing =corfu/company= with in-buffer completion, but hadn't solved how to hide the completion buffer when using =icomplete=. My settings already closely matched those in Emacs-solo, but the critical missing piece was this elegant advice:

#+begin_src elisp
(if icomplete-in-buffer
    (advice-add 'completion-at-point
                :after #'minibuffer-hide-completions))
#+end_src

Now it feels much cleaner and I might start using it rather than =corfu= from now on.

-----

The final act of pilfering is to incorporate a simple =ollama= integration.

Before creating my [[https://github.com/captainflasmr/ollama-buddy][Ollama Buddy]] package, I had explored integrating =ollama= through a shell and I had also come to the conclusion that using =ansi-term= was really the only quick solution, but I just couldn't figure out the implementation details.  However, the experience ultimately led me to take an alternative approach, writing a small implementation to interface with =ollama= from an Emacs buffer, which eventually gave rise to =Ollama Buddy=.

The =Emacs-solo= =ansi-term= solution feels surprisingly well-integrated once you become comfortable switching between line and character modes. I've now incorporated this as an alternative to my API-based implementation, providing two no-dependency options for local LLM access!

I plan to further explore =Emacs-solo=, particularly for additional =vc= enhancements. This first pass has already yielded valuable improvements to =Emacs-DIYer=, and this has been a valuable exercise to learn from another project with such similar design principles.

* DONE Ollama-Buddy 0.9.38: Unload Models, Hide AI Reasoning, and Clearly View Modified Parameters on each request :ollama_buddy:ollama:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250501133351-emacs--Ollama-Buddy-0-9-38-Unload-Models-Hide-AI-Reasoning-and-Clearly-View-Modified-Parameters-on-each-request
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-05-01 13:33>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg
:END:

More improvements to =ollama-buddy= https://github.com/captainflasmr/ollama-buddy

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg]]

** <2025-04-29> *0.9.38*

Added model unloading functionality to free system resources

- Add unload capability for individual models via the model management UI
- Create keyboard shortcut (C-c C-u) for quick unloading of all models
- Display running model count and unload buttons in model management buffer

Large language models consume significant RAM and GPU memory while loaded. Until now, there wasn't an easy way to reclaim these resources without restarting the Ollama server entirely. This new functionality allows you to:

- Free up GPU memory when you're done with your LLM sessions
- Switch between resource-intensive tasks more fluidly
- Manage multiple models more efficiently on machines with limited resources
- Avoid having to restart the Ollama server just to clear memory

There are several ways to unload models with the new functionality:

1. *Unload All Models*: Press =C-c C-u= to unload all running models at once (with confirmation)

2. *Model Management Interface*: Access the model management interface with =C-c W= where you'll find:
   - A counter showing how many models are currently running
   - An "Unload All" button to free all models at once
   - Individual "Unload" buttons next to each running model

3. *Quick Access in Management Buffer*: When in the model management buffer, simply press =u= to unload all models

The unloading happens asynchronously in the background, with clear status indicators so you can see when the operation completes.

** <2025-04-25> *0.9.37*

- Display modified parameters in token stats

Enhanced the token statistics section to include any modified parameters, providing a clearer insight into the active configurations. This update helps in debugging and understanding the runtime environment.

** <2025-04-25> *0.9.36*

Added Reasoning/Thinking section visibility toggle functionality

- Introduced the ability to hide reasoning/thinking sections during AI responses, making the chat output cleaner and more focused on final results
- Added a new customizable variable =ollama-buddy-hide-reasoning= (default: nil) which controls visibility of reasoning sections
- Added =ollama-buddy-reasoning-markers= to configure marker pairs that encapsulate reasoning sections (supports multiple formats like <think></think> or ----)
- Added =ollama-buddy-toggle-reasoning-visibility= interactive command to switch visibility on/off
- Added keybinding =C-c V= for toggling reasoning visibility in chat buffer 
- Added transient menu option "V" for toggling reasoning visibility
- When reasoning is hidden, a status message shows which section is being processed (e.g., "Think..." or custom marker names)
- Reasoning sections are automatically detected during streaming responses
- Header line now indicates when reasoning is hidden with "REASONING HIDDEN" text
- All changes preserve streaming response functionality while providing cleaner output

This feature is particularly useful when working with AI models that output their "chain of thought" or reasoning process before providing the final answer, allowing users to focus on the end results while still having the option to see the full reasoning when needed.

* DONE Ollama-Buddy 0.9.35: Grok, Gemini Integration and Enhanced Sessions :ollama_buddy:ollama:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-04-24 09:20>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg
:END:

Several improvements in the latest Ollama Buddy updates (versions 0.9.21 through 0.9.35):

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250424085731-emacs--Ollama-Buddy-0-9-35-Grok-Gemini-Integration-Enhanced-Sessions.jpg]]

** 🎉 New AI Integrations with Grok and Gemini

- Google's Gemini is now complementing existing support for Claude, ChatGPT (OpenAI), and Ollama models. Setting up is straightforward and consistent with other integrations.
- Just like the existing integrations, Grok can now be easily configured with your API key.

#+hugo: more

** 🔗 Improved Remote LLM Architecture

LLM internal decoupling, making Ollama Buddy's core logic independent from any specific remote LLM. Each LLM integration now functions as a self-contained extension, significantly simplifying future additions and maintenance.

** 🎯 Standardized Model Prefixing

Now there are more remote LLMs into the mix I thought it was probably time to more clearly distinguish between model collections, so I have defined the following prefixes:

- Ollama:  =o:=
- ChatGPT: =a:=
- Claude:  =c:=
- Gemini:  =g:=
- Grok:    =k:=

This change helps ensure clarity, especially when recalling previous sessions. Note: existing session files will need the Ollama prefix (=o:=) added manually if you encounter issues recalling older sessions.

** 💾 Enhanced Session Management

Saving session now makes a little more sense and is more consistent:

- Automatic timestamped session names (you can still set your own).
- Sessions now also save as =org= files alongside the original =elisp= files, allowing for richer recall and easy inspection later.
- The current session name appears dynamically in your modeline, offering quick context.

** 🛠️ Additional Improvements

- UTF-8 encoding fixes for remote LLM stream responses.
- Refactored history and model management so all the latest models are available for selection.  This is currently most relevant for remote LLMs which often change their model selection.
- History view/edit functionality merged into one keybinding

-----

and here is the change history

** <2025-04-21> *0.9.35*

Added Grok support

Integration is very similar to other remote AIs:

#+begin_src elisp
(use-package ollama-buddy
  :bind
  ("C-c o" . ollama-buddy-menu)
  ("C-c O" . ollama-buddy-transient-menu-wrapper)
  :custom
  (ollama-buddy-grok-api-key
   (auth-source-pick-first-password :host "ollama-buddy-grok" :user "apikey"))
  :config
  (require 'ollama-buddy-grok nil t))
#+end_src

** <2025-04-20> *0.9.33*

Fixed utf-8 encoding stream response issues from remote LLMs.

** <2025-04-19> *0.9.32*

Finished the remote LLM decoupling process, meaning that the core =ollama-buddy= logic is now not dependent on any remote LLM, and each remote LLM package is self-contained and functions as a unique extension.

** <2025-04-18> *0.9.31*

Refactored model prefixing logic and cleaned up

- Standardized model prefixing by introducing distinct prefixes for Ollama (=o:=), OpenAI (=a:=), Claude (=c:=), and Gemini (=g:=) models.
- Centralized functions to get full model names with prefixes across different model types.
- Removed redundant and unused variables related to model management.

Note that there may be some breaking changes here especially regarding session recall as all models will now have a prefix to uniquely identify their type.  For =ollama= recall, just edit the session files to prepend the ollama prefix of "o:"

** <2025-04-17> *0.9.30*

Added Gemini integration!

As with the Claude and ChatGPT integration, you will need to add something similar to them in your configuration. I currently have the following set up to enable access to the remote LLMs:

#+begin_src elisp
(use-package ollama-buddy
  :bind
  ("C-c o" . ollama-buddy-menu)
  ("C-c O" . ollama-buddy-transient-menu-wrapper)
  :custom
  (ollama-buddy-openai-api-key
   (auth-source-pick-first-password :host "ollama-buddy-openai" :user "apikey"))
  (ollama-buddy-claude-api-key
   (auth-source-pick-first-password :host "ollama-buddy-claude" :user "apikey"))
  (ollama-buddy-gemini-api-key
   (auth-source-pick-first-password :host "ollama-buddy-gemini" :user "apikey"))
  :config
  (require 'ollama-buddy-openai nil t)
  (require 'ollama-buddy-claude nil t)
  (require 'ollama-buddy-gemini nil t))
#+end_src

Also with the previous update all the latest model names will be pulled, so there should be a full comprehensive list for each of the main remote AI LLMs!

** <2025-04-16> *0.9.23*

Refactored history and model management for remote LLMs

- Now pulling in latest model list for remote LLMs (so now ChatGPT 4.1 is available!)
- Removed redundant history and model management functions from =ollama-buddy-claude.el= and =ollama-buddy-openai.el=. Replaced them with shared implementations to streamline code and reduce duplication

** <2025-04-15> *0.9.22*

Enhanced session management

- Refactored =ollama-buddy-sessions-save= to autogenerate session names using timestamp and model.
- Improved session saving/loading by integrating org file handling.
- Updated mode line to display current session name dynamically.

Several improvements to session management, making it more intuitive and efficient for users. Here's a breakdown of the new functionality:

When saving a session, Ollama Buddy now creates a default name using the current timestamp and model name, users can still provide a custom name if desired.

An org file is now saved alongside the original elisp session file. This allows for better session recall as all interactions will be pulled back with the underlying session parameters still restored as before. There is an additional benefit in not only recalling precisely the session and any additional org interactions but also quickly saving to an org file for potential later inspection. Along with the improved autogenerated session name, this means it is much faster and more intuitive to save a snapshot of the current chat interaction.

The modeline now displays the current session name!

** <2025-04-11> *0.9.21*

Add history edit/view toggle features, so effectively merging the former history display into the history edit functionality.

* DONE Flex Matching with isearch :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250415150114-emacs--Flex-Matching-With-Isearch
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-04-17 09:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250415150114-emacs--Flex-Matching-With-Isearch.jpg
:END:

I'm having issues with =isearch=!

I've been using =fido-mode= for a while now (I'm one of those weirdos who transitioned from the Vertico/Marginalia/Orderless stack back to an Emacs built-in) and have become accustomed to the flexible matching that =fido= offers. For example, I often shorten commands to find them, such as:

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250415150114-emacs--Flex-Matching-With-Isearch.jpg]]

It is very common for me to search in a buffer for strings that contain a dash (especially now I am doing a lot more elisp programming), and I keep instinctively fido-shortening the search (so searching without the dash). Each time, =isearch= says no (or fails), so I have to awkwardly reach out for the "-" and go back and perform the search again.

What if there was a more flexible way to perform an in-buffer search? Well, of course, there is, and that is the =isearch-regexp= variants. I have seen some people just binding this to their main =isearch= because, why not? Most of the time, the search will be identical, and there is always the opportunity for a more flexible search using ".*".

Let's run an example. I would like to search for the first occurrence of =use-package= in my config. Let's see how many keys we can get down to for an efficient search and how easy ergonomically they are to get to (excluding the possibility of some annoyingly similar matching lines in the config)

Firstly, let's try =isearch= - you would have to type up to at least "use-pa" (probably).

Now for =isearch-regex= - you would type "us.*p" (probably) or of course just the same as =isearch=, so "use-pa". This is better but a bit awkward to access the "*" and you would have to be quite aware of what you were searching for and the rough split of words.

If this were translated into a form of =fido= search, you would type at least "usep" (probably), a similar number of characters, but no awkward punctuation (so faster to type) and the find is more flexible and for me now, more familiar.

As far as I'm aware, by default =fido= uses some form of flex matching (but not quite flex), which has been good enough for me for a while now. So, how do I get this form of matching using =isearch= and it being in-buffer?

After a little investigation, there are packages out there in Emacs-land for some fuzzy searching, and the most relevant seemed to be =flex-isearch=. I'm not sure I quite got it working for me, but looking through the code, I thought I could distil some concepts into simple defuns. I learned that you can actually slot any search function at the backend of isearch, so let's transform a normal search into something on steroids that would give us a flexible search, =fido= style!

#+begin_src elisp
(defvar flex-isearch-group-size 3
  "Number of initial characters to group together for more accurate flex searching.")

(defun flex-isearch-regexp-compile (string)
  "Convert a search string to a more intelligent flex-matching regexp.
The first `flex-isearch-group-size` characters are grouped together for more accurate matching."
  (let* ((parts (split-string string " " t))
         (compile-part
          (lambda (part)
            (let ((grouped (substring part 0 (min flex-isearch-group-size (length part))))
                  (rest (substring part (min flex-isearch-group-size (length part)))))
              (concat
               (regexp-quote grouped)
               (mapconcat
                (lambda (char)
                  (let ((c (char-to-string char)))
                    (cond
                     ((and (>= char ?A) (<= char ?Z))
                      (concat "[^" c "\n]*" c))
                     ((and (>= char ?a) (<= char ?z))
                      (concat "[^" c (upcase c) "\n]*[" c (upcase c) "]"))
                     (t
                      (concat "[^" (regexp-quote c) "\n]*" (regexp-quote c))))))
                rest
                "")
               "[^-_[:alnum:]\n]*")))))
    (concat
     "\\b"
     (mapconcat compile-part parts "[^-_[:alnum:]\n]+"))))

(defun flex-isearch-search-fun ()
  "Return the appropriate search function for flex searching."
  (if isearch-forward 'flex-isearch-forward 'flex-isearch-backward))

(defun flex-isearch-forward (string &optional bound noerror count)
  "Flex search forward for STRING."
  (let ((regexp (flex-isearch-regexp-compile string)))
    (re-search-forward regexp bound t)))

(defun flex-isearch-backward (string &optional bound noerror count)
  "Flex search backward for STRING."
  (let ((regexp (flex-isearch-regexp-compile string)))
    (re-search-backward regexp bound t)))

(setq isearch-search-fun-function 'flex-isearch-search-fun)
#+end_src

With my first attempt at this, the search at times seemed to settle on more candidates than I would have liked, but I thought, "I generally always know at least the first 2 or 3 characters that I'm searching for, at which point things get a little fuzzy" (pun intended). So, can I group the first few letters as part of the search, thus narrowing down the candidate list?

The answer is yes, yes I can.

The code above is a first attempt and with all these things, I shall play around with it and see if it works for me. At the moment, this seems to give me a more =fido-iish= feel when searching in-buffer with =isearch=, and no awkward search punctuation in sight!. So, using the examples above I can now find "use-package" in my config with a simple "usep".

I shall report back in a later post to see if it has settled into my workflow, or whether there is an annoyance that I just cannot put up with so it will have to be discarded, along with my other myriad of Emacs experiments!

* DONE Ollama-Buddy 0.9.20: Curated AI Prompting with Awesome ChatGPT Prompts :ollama_buddy:ollama:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250409134339-emacs--Ollama-Buddy-0-9-20-Curated-AI-Prompting-with-Awesome-ChatGPT-Prompts
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-04-09 13:43>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250325093201-emacs--Ollama-Buddy-0-9-11-Experimental-ChatGPT-Integration-Customizable-AI-Streaming-and-Texinfo-documentation.jpg
:END:

- Added =ollama-buddy-awesome.el= to integrate Awesome ChatGPT Prompts.

=ollama-buddy-awesome= is an =ollama-buddy= extension that integrates the popular [[https://github.com/f/awesome-chatgpt-prompts][Awesome ChatGPT Prompts]] repository, allowing you to leverage hundreds of curated prompts for various tasks and roles right within your Emacs environment, I thought that since I have integrated the =fabric= set of curated prompts, so then why not these!

#+hugo: more 

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250325093201-emacs--Ollama-Buddy-0-9-11-Experimental-ChatGPT-Integration-Customizable-AI-Streaming-and-Texinfo-documentation.jpg]]

There is a video demonstration here : https://www.youtube.com/watch?v=5A4bTvjmPeo

*** Key Features

1. *Seamless Sync*: Automatically fetch the latest prompts from the GitHub repository, ensuring you always have access to the most up-to-date collection.

2. *Smart Categorization*: Prompts are intelligently categorized based on their content, making it easy to find the perfect prompt for your task.

3. *Interactive Selection*: Choose prompts through Emacs' familiar completion interface, with category and title information for quick identification.

4. *Effortless Application*: Apply selected prompts as system prompts in ollama-buddy with a single command, streamlining your AI-assisted workflow.

5. *Prompt Management*: List available prompts, preview their content, and display full prompt details on demand.

*** Getting Started

To access the Awesome ChatGPT prompts, just select the transient menu as normal and select "[a] Awesome ChatGPT Prompts", this will fetch the prompts and prepare everything for your first use and give you a transient menu as follows:

#+begin_example
Actions
[s] Send with Prompt
[p] Set as System Prompt
[l] List All Prompts
[c] Category Browser
[S] Sync Latest Prompts
[q] Back to Main Menu
#+end_example

Now available are a vast array of role-based and task-specific prompts, enhancing your =ollama-buddy= interactions in Emacs!

* DONE Ollama-Buddy 0.9.17: Claude Support, Asynchronous Operations and Responses to Registers :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250330164641-emacs--Ollama-Buddy-0.9.16-Claude-Support-Asynchronous-Operations-and-Responses-to-Registers
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-04-02 17:15>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250325093201-emacs--Ollama-Buddy-0-9-11-Experimental-ChatGPT-Integration-Customizable-AI-Streaming-and-Texinfo-documentation.jpg
:END:

I’ve added experimental support for Claude AI, aligning its implementation with my support for ChatGPT, to pave the way for external AI templating which should make it easier to integrate new models in the future. Like the ChatGPT implementation, it doesn’t stream tokens in real time but instead outputs the final result all at once. However, after testing it further, I’m actually starting to prefer it. The response speed is so fast that not seeing a real-time “Typing” indicator isn’t a big deal. I think that streaming feels more relevant for local LLMs running through =ollama=, where token generation is slower, making real-time output more useful.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250325093201-emacs--Ollama-Buddy-0-9-11-Experimental-ChatGPT-Integration-Customizable-AI-Streaming-and-Texinfo-documentation.jpg]]

Secondly, the Texinfo manual for this package now magically installs itself when pulling from MELPA. I fluked this!, I just thought it was sensible to create a =docs= directory and then plonked an info file there. After looking into it, I found that MELPA performs some extra processing when handling Emacs documentation. It automatically scans common documentation directories like =docs= and grabs the =.info= file, pretty neat! This means you can now browse =ollama-buddy='s functionality directly through =info=. 

Next up, I realized I wasn’t efficiently handling =ollama= model operations like delete, pull, and copy. I was currently process-calling =ollama= and passing through arguments as if I was on the command line.  This was functional, but wasn’t ideal and wasn't stimulating the =ollama= API for these operations correctly, or even at all.  After reassessing my design, I came to the realization that I was in fact using four different methods to communicate with =ollama=:

1. =curl= 
2. Direct process calls 
3. =url.el= 
4. =make-network-process= 

At first, I leaned on =curl= since it was straightforward and matched the official =ollama= examples. My approach with a project such as this is generally to get things working quickly and then refine/iterate later. However, once I had a solid design (and design principles!), I wanted to eliminate external dependencies like =curl=. This lead me to explore =url.el=, but initially I couldn't seem to get my head round it / get it working - and I decided to go for the nuclear option of =make-network-process= for network-level flexibility.  Later, I revisited =url.el= for Claude and ChatGPT support, rewriting the implementation to use =url-retrieve=, but decided generally to keep =make-network-process= for =ollama= interactions as it was still Emacs built-in and actually I'm more familiar with the lower level network concepts as having wrestled with them over many years at work.

Anyway, back to the stimulating of the =ollama= API for model operations.

I considered leveraging my existing =url.el= based =ollama-buddy--make-request= function, but quickly realized it used =url-request-data=, which blocks execution. This wasn't an issue for quick requests like model info or tags (although could be), but for long-running tasks like model pulls and general model operations it risked freezing Emacs!

Switching to =url-retrieve= solved this, as it runs asynchronously, however, =url-retrieve= only triggers its callback at the end of the request, making real-time progress tracking difficult. To address this, I implemented =run-with-timer=, ensuring persistent status updates in the header-line which now allows for multiple operations, including pull, copy, delete, even simultaneously.

Now that I’m using =ollama-buddy= as my primary Emacs AI assistant, I’m refining my AI workflow. Since my design is centered around the chat buffer, all interactions and outputs end up there. But what about quick tasks like proofreading text or refactoring code? Ideally, I want a workflow that aligns with =ollama-buddy='s principles, meaning no direct in-buffer edits (though future me might change their mind!). 

For example, if I want to tighten a rambling paragraph (is this one? :), I currently send it via the custom menu to the chat buffer with a proofreading tag. However, retrieving the output requires jumping to the chat buffer, copying it, switching back, deleting the original, and then pasting the revision - too many steps. 

To streamline this, I’ve now implemented a feature that writes the latest response to a customizable register, this way, I can simply delete the original text and insert the improved version without extra navigation.

Note: I have remapped the =insert-register= default keybinding of =C-x r i= to =M-a=, as by default I am writing to register ?a and =M-a a= seems more comfortable.

** <2025-04-01> *0.9.17*

- Added link to =ollama-buddy= info manual from the chat buffer and transient menu as MELPA has now picked it up and installed it!

** <2025-03-28> *0.9.16*

- Added =ollama-buddy-fix-encoding-issues= to handle text encoding problems.
- Refactored and streamline fabric pattern description handling.
- Removed unused fabric pattern categories to enhance maintainability.

** <2025-03-28> *0.9.15*

- Implement asynchronous operations for model management
  - Introduce non-blocking API requests for fetching, copying, and deleting models
- Add caching mechanisms to improve efficiency
  - Cache model data to reduce redundant API calls
  - Manage cache expiration with timestamps and time-to-live settings
- Update status line to reflect ongoing background operations
- Ensure smooth user interaction by minimizing wait times and enhancing performance

** <2025-03-26> *0.9.13*

- Added automatic writing of last response to a register
- Added M-r to search through prompt history

I was just thinking about a general workflow aspect and that is getting responses out of the =ollama-buddy= chat buffer.  Of course if you are already there then it will be easier, but even then the latest prompt, which is probably the one you are interested in will still have to be copied to the kill ring.

This issue is even more pronounced when you are sending text from other buffers to the chat.

So, the solution I have put in place is to always write the last response to a register of your choice.  I always think registers are an underused part of Emacs, I already have repurposed them for the multishot, so why not always make the last response available.

For example, you want to proofread a sentence, you can mark the text, send to the chat using the custom menu to proofread then the response will be available in maybe register "a".  The chat buffer will be brought up if not already visible so you can validate the output, then pop back to your buffer, delete the paragraph and insert the register "a"?, maybe.  I am going to put this in as I suspect no-one uses registers anyway and if they do, they can push the response writing register away using =ollama-buddy-default-register=, I don't think this will do any harm, and actually it is something I may starting using more often.

As a side note, I also need to think about popping into the chat buffer with a buffer text push to the chat, should I do it?, not sure yet, still getting to grips with the whole workflow aspect, so will need a little more time to see what works.

Also as a side note to this ramble, the general register prefix is annoyingly long =C-x r i <register>= so I have rebound in my config to =M-a=, as I never want to go back a sentence and also if I just write to the default "a" register then it feels ergonomically fast.

** <2025-03-25> *0.9.12*

- Added experimental Claude AI support!
- removed curl and replaced with url.el for online AI integration

A very similar implementation as for ChatGPT.

To activate, set the following:

#+begin_src elisp
(require 'ollama-buddy-claude nil t)
(ollama-buddy-claude-api-key "<extremely long key>")
#+end_src

* DONE Ollama-Buddy 0.9.11: Experimental ChatGPT Integration, Customizable Streaming and Texinfo documentation :ollama_buddy:ollama:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250325093201-emacs--Ollama-Buddy-0-9-11-Experimental-ChatGPT-Integration-Customizable-AI-Streaming-and-Texinfo-documentation
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-03-25 10:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250325093201-emacs--Ollama-Buddy-0-9-11-Experimental-ChatGPT-Integration-Customizable-AI-Streaming-and-Texinfo-documentation.jpg
:END:

This week in [[https://github.com/captainflasmr/ollama-buddy][ollama-buddy]] updates, I have mostly been experimenting with ChatGPT integration! Yes, it is not a local LLM, so not ollama, hence entirely subverting the whole notion and fundamental principles of this package! This I know, and I don't care; I'm having fun. I use ChatGPT and would rather use it in Emacs through the now-familiar =ollama-buddy= framework, so why not? I'm also working on Claude integration too.

#+hugo: more

My original principles of a no-config Emacs ollama integration still hold true, as by default, you will only see ollama models available. But with a little tweak to the configuration, with a require here and an API key there, you can now enable communication with an online AI. At the moment, I use Claude and ChatGPT, but if I can get Claude working, I might think about just adding in a basic template framework to easily slot in others. At the moment, there is a little too much internal ollama-buddy faffing to incorporate these external AIs into the main package, but I'm sure I can figure out a way to accommodate separate elisp external AIs.

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250325093201-emacs--Ollama-Buddy-0-9-11-Experimental-ChatGPT-Integration-Customizable-AI-Streaming-and-Texinfo-documentation.jpg]]

In other =ollama-buddy= news, I have now added support for the =stream= variable in the ollama API. By default, I had streaming on, and I guess why wouldn't you? It is a chat, and you would want to see "typing" or tokens arriving as they come in?. But to support more of the API, you can toggle it on and off, so if you want, you can sit there and wait for the response to arrive in one go and maybe it can be less distracting (and possibly more efficient?).

Just a note back on the topic of online AI offerings: to simplify those integrations, I just disabled streaming for the response to arrive in one shot. Mainly, I just couldn't figure out the ChatGPT streaming, and for an external offering, I wasn't quite willing to spend more time on it, and due to the speed of these online behemoths, do you really need to see each token come in as it arrives?

Oh, there is something else too, something I have been itching to do for a while now, and that is to write a Texinfo document so a manual can be viewed in Emacs. Of course, this being an AI-based package, I fed in my =ollama-buddy= files and got Claude to generate one for me (I have a baby and haven't the time!). Reading through it, I think it turned out pretty well :) It hasn't been made automatically available on MELPA yet, as I need to tweak the recipe, but you can install it for yourself.

Anyways, see below for the changelog gubbins:

** <2025-03-24> *0.9.11*

Added the ability to toggle streaming on and off

- Added customization option to enable/disable streaming mode
- Implemented toggle function with keybindings (C-c x) and transient menu option
- Added streaming status indicator in the modeline

The latest update introduces the ability to toggle between two response modes:

- *Streaming mode (default)*: Responses appear token by token in real-time, giving you immediate feedback as the AI generates content.
- *Non-streaming mode*: Responses only appear after they're fully generated, showing a "Loading response..." placeholder in the meantime.

While watching AI responses stream in real-time is often helpful, there are situations where you might prefer to see the complete response at once:

- When working on large displays where the cursor jumping around during streaming is distracting
- When you want to focus on your work without the distraction of incoming tokens until the full response is ready

The streaming toggle can be accessed in several ways:

1. Use the keyboard shortcut =C-c x=
2. Press =x= in the transient menu
3. Set the default behaviour through customization:
   #+begin_src elisp
   (setq ollama-buddy-streaming-enabled nil) ;; Disable streaming by default
   #+end_src

The current streaming status is visible in the modeline indicator, where an "X" appears when streaming is disabled.

** <2025-03-22> *0.9.10*

Added experimental OpenAI support!

Yes, that's right, I said I never would do it, and of course, this package is still very much =ollama=-centric, but I thought I would just sneak in some rudimentary ChatGPT support, just for fun!

It is a very simple implementation, I haven't managed to get streaming working, so Emacs will just show "Loading Response..." as it waits for the response to arrive. It is asynchronous, however, so you can go off on your Emacs day while it loads (although being ChatGPT, you would think the response would be quite fast!)

By default, OpenAI/ChatGPT will not be enabled, so anyone wanting to use just a local LLM through =ollama= can continue as before. However, you can now sneak in some experimental ChatGPT support by adding the following to your Emacs config as part of the =ollama-buddy= set up.

#+begin_src elisp
(require 'ollama-buddy-openai nil t)
(setq ollama-buddy-openai-api-key "<big long key>")
#+end_src

and you can set the default model to ChatGPT too!

#+begin_src elisp
(setq ollama-buddy-default-model "GPT gpt-4o")
#+end_src

With this enabled, chat will present a list of ChatGPT models to choose from. The custom menu should also now work with chat, so from anywhere in Emacs, you can push predefined prompts to the =ollama= buddy chat buffer now supporting ChatGPT.

There is more integration required to fully incorporate ChatGPT into the =ollama= buddy system, like token rates and history, etc. But not bad for a first effort, methinks!

Here is my current config, now mixing ChatGPT with =ollama= models:

#+begin_src elisp
(use-package ollama-buddy
  :bind
  ("C-c o" . ollama-buddy-menu)
  ("C-c O" . ollama-buddy-transient-menu-wrapper)
  :custom
  (ollama-buddy-openai-api-key "<very long key>")
  (ollama-buddy-default-model "GPT gpt-4o")
  :config
  (require 'ollama-buddy-openai nil t)
  (ollama-buddy-update-menu-entry
   'refactor-code :model "qwen2.5-coder:7b")
  (ollama-buddy-update-menu-entry
   'git-commit :model "qwen2.5-coder:3b")
  (ollama-buddy-update-menu-entry
   'describe-code :model "qwen2.5-coder:3b")
  (ollama-buddy-update-menu-entry
   'dictionary-lookup :model "llama3.2:3b")
  (ollama-buddy-update-menu-entry
   'synonym :model "llama3.2:3b")
  (ollama-buddy-update-menu-entry
   'proofread :model "GPT gpt-4o")
  (ollama-buddy-update-menu-entry
   'custom-prompt :model "deepseek-r1:7b"))
#+end_src

** <2025-03-22> *0.9.9*

Added texinfo documentation for future automatic installation through MELPA and created an Emacs manual.

If you want to see what the manual would look like, just download the docs directory from github, cd into it, and run:

#+begin_src bash
make
sudo make install-docs
#+end_src

Then calling up =info= =C-h i= and ollama buddy will be present in the Emacs menu, or just select =m= and search for =Ollama Buddy=

For those interested in the manual, I have converted it into html format, which is accessible here:

[[file:docs/ollama-buddy.org]]

It has been converted using the following command:

#+begin_src bash
makeinfo --html --no-split ollama-buddy.texi -o ollama-buddy.html
pandoc -f html -t org -o ollama-buddy.org ollama-buddy.html
#+end_src

** <2025-03-20> *0.9.9*

Intro message with model management options (select, pull, delete) and option for recommended models to pull

- Enhance model management and selection features
- Display models available for download but not yet pulled

* DONE Ollama-Buddy 0.9.8: Transient Menu, Model Managing, GGUF Import, fabric Prompts and History Editing :ollama_buddy:ollama:ai:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250319145359-emacs--Ollama-Buddy-0-9-8-Transient-Menu-Model-managing-GGUF-import-fabric-prompts
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-03-19 16:08>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250319145359-emacs--Ollama-Buddy-0-9-8-Transient-Menu-Model-managing-GGUF-import-fabric-prompts.jpg
:END:

This week in [[https://github.com/captainflasmr/ollama-buddy][ollama-buddy]] updates, I have been continuing on the busy bee side of things.

The headlines are :

- Transient menu - yes, I know I said I would never do it, but, well I did and as it turns out I kinda quite like it and works especially well when setting parameters.
- Support for =fabric= prompts presets - mainly as I thought generally user curated prompts was a pretty cool idea, and now I have system prompts implemented it seemed like a perfect fit.  All I needed to do was to pull the patterns directory and then parse accordingly, of course Emacs is good at this.
- GGUF import - I don't always pull from ollama's command line, sometimes I download a GGUF file, it is a bit of a process to import to ollama, create a model file, run a command, e.t.c, but now you can import from within =dired=!
- More support for the =ollama= API - includes model management, so pulling, stopping, deleting and more!
- Conversation history editing - as I store the history in a hash table, I can easily just display an alist, and editing can leverage the =sexp= usual keybindings and then load back in to the variable.
- Parameter profiles - When implementing the transient menu I thought it might be fun to try parameter profiles where a set of parameters can be applied in a block for each preset.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250319145359-emacs--Ollama-Buddy-0-9-8-Transient-Menu-Model-managing-GGUF-import-fabric-prompts.jpg]]

And now for the detail, version by version...

** <2025-03-19> *0.9.8*

Added model management interface to pull and delete models

- Introduced `ollama-buddy-manage-models` to list and manage models.
- Added actions for selecting, pulling, stopping, and deleting models.

You can now manage your Ollama models directly within Emacs with =ollama-buddy=

With this update, you can now:

- *Browse Available Models* – See all installed models at a glance.  
- *Select Models Easily* – Set your active AI model with a single click.  
- *Pull Models from Ollama Hub* – Download new models or update existing ones.  
- *Stop Running Models* – Halt background processes when necessary.  
- *Delete Unused Models* – Clean up your workspace with ease.  

1. *Open the Model Management Interface*  
   Press *=C-c W=* to launch the new *Model Management* buffer or through the transient menu.

2. *Manage Your Models*  
   - Click on a model to *select* it.  
   - Use *"Pull"* to fetch models from the Ollama Hub.  
   - Click *"Stop"* to halt active models.  
   - Use *"Delete"* to remove unwanted models.

3. *Perform Quick Actions*  
   - *=g=* → Refresh the model list.  
   - *=i=* → Import a *GGUF model file*.  
   - *=p=* → Pull a new model from the *Ollama Hub*.  

When you open the management interface, you get a structured list like this:

#+begin_src 
Ollama Models Management
=======================

Current Model: mistral:7b
Default Model: mistral:7b

Available Models:
  [ ] llama3.2:1b  Info  Pull  Delete
  [ ] starcoder2:3b  Info  Pull  Delete
  [ ] codellama:7b  Info  Pull  Delete
  [ ] phi3:3.8b  Info  Pull  Delete
  [x] llama3.2:3b  Info  Pull  Delete Stop

Actions:
[Import GGUF File]  [Refresh List]  [Pull Model from Hub]
#+end_src

Previously, managing Ollama models required manually running shell commands. With this update, you can now *do it all from Emacs*, keeping your workflow smooth and efficient!

** <2025-03-19> *0.9.7*

- Added GGUF file import and Dired integration

Import GGUF Models into Ollama from =dired= with the new =ollama-buddy-import-gguf-file= function. In =dired= just navigate to your file and press =C-c i= or =M-x ollama-buddy-import-gguf-file= to start the import process. This eliminates the need to manually input file paths, making the workflow smoother and faster.

The model will then be immediately available in the =ollama-buddy= chat interface.

** <2025-03-18> *0.9.6*

- Added a transient menu containing all commands currently presented in the chat buffer
- Added fabric prompting support, see https://github.com/danielmiessler/fabric
- Moved the presets to the top level so they will be present in the package folder

Ollama Buddy now includes a transient-based menu system to improve usability and streamline interactions. Yes, I originally stated that I would never do it, but I think it compliments my crafted simple textual menu and the fact that I have now defaulted the main chat interface to a simple menu.

This can give the user more options for configuration, they can use the chat in advanced mode where the keybindings are presented in situ, or a more minimal basic setup where the transient menu can be activated.  For my use-package definition I current have the following set up, with the two styles of menus sitting alongside each other :

  #+begin_src elisp
  :bind
  ("C-c o" . ollama-buddy-menu)
  ("C-c O" . ollama-buddy-transient-menu)
  #+end_src

The new menu provides an organized interface for accessing the assistant’s core functions, including chat, model management, roles, and Fabric patterns. This post provides an overview of the features available in the Ollama Buddy transient menus.

Yes that's right also =fabric= patterns!, I have decided to add in auto syncing of the patterns directory in https://github.com/danielmiessler/fabric

Simply I pull the patterns directory which contain prompt guidance for a range of different topics and then push them through a completing read to set the =ollama-buddy= system prompt, so a special set of curated prompts can now be applied right in the =ollama-buddy= chat!

Anyways, here is a description of the transient menu system.

*** What is the Transient Menu?

The transient menu in Ollama Buddy leverages Emacs' =transient.el= package (the same technology behind Magit's popular interface) to create a hierarchical, discoverable menu system. This approach transforms the user experience from memorizing numerous keybindings to navigating through logical groups of commands with clear descriptions.

*** Accessing the Menu

The main transient menu can be accessed with the keybinding =C-c O= when in an Ollama Buddy chat buffer. You can also call it via =M-x ollama-buddy-transient-menu= from anywhere in Emacs.

*** What the Menu Looks Like

When called, the main transient menu appears at the bottom of your Emacs frame, organized into logical sections with descriptive prefixes. Here's what you'll see:

#+begin_src 
|o(Y)o| Ollama Buddy
[Chat]             [Prompts]            [Model]               [Roles & Patterns]
o  Open Chat       l  Send Region       m  Switch Model       R  Switch Roles
O  Commands        s  Set System Prompt v  View Model Status  E  Create New Role
RET Send Prompt    C-s Show System      i  Show Model Info    D  Open Roles Directory
h  Help/Menu       r  Reset System      M  Multishot          f  Fabric Patterns
k  Kill/Cancel     b  Ollama Buddy Menu

[Display Options]          [History]              [Sessions]             [Parameters]
A  Toggle Interface Level  H  Toggle History      N  New Session         P  Edit Parameter
B  Toggle Debug Mode       X  Clear History       L  Load Session        G  Display Parameters
T  Toggle Token Display    V  Display History     S  Save Session        I  Parameter Help
U  Display Token Stats     J  Edit History        Q  List Sessions       K  Reset Parameters
C-o Toggle Markdown->Org                          Z  Delete Session      F  Toggle Params in Header
c  Toggle Model Colors                                                   p  Parameter Profiles
g  Token Usage Graph
#+end_src

This visual layout makes it easy to discover and access the full range of Ollama Buddy's functionality. Let's explore each section in detail.

*** Menu Sections Explained
**** Chat Section

This section contains the core interaction commands:

- *Open Chat (o)*: Opens the Ollama Buddy chat buffer
- *Commands (O)*: Opens a submenu with specialized commands
- *Send Prompt (RET)*: Sends the current prompt to the model
- *Help/Menu (h)*: Displays the help assistant with usage tips
- *Kill/Cancel Request (k)*: Cancels the current ongoing request

**** Prompts Section

These commands help you manage and send prompts:

- *Send Region (l)*: Sends the selected region as a prompt
- *Set System Prompt (s)*: Sets the current prompt as a system prompt
- *Show System Prompt (C-s)*: Displays the current system prompt
- *Reset System Prompt (r)*: Resets the system prompt to default
- *Ollama Buddy Menu (b)*: Opens the classic menu interface

**** Model Section

Commands for model management:

- *Switch Model (m)*: Changes the active LLM
- *View Model Status (v)*: Shows status of all available models
- *Show Model Info (i)*: Displays detailed information about the current model
- *Multishot (M)*: Sends the same prompt to multiple models

**** Roles & Patterns Section

These commands help manage roles and use fabric patterns:

- *Switch Roles (R)*: Switch to a different predefined role
- *Create New Role (E)*: Create a new role interactively
- *Open Roles Directory (D)*: Open the directory containing role definitions
- *Fabric Patterns (f)*: Opens the submenu for Fabric patterns

When you select the Fabric Patterns option, you'll see a submenu like this:

#+begin_src 
Fabric Patterns (42 available, last synced: 2025-03-18 14:30)
[Actions]             [Sync]              [Categories]          [Navigation]
s  Send with Pattern  S  Sync Latest      u  Universal Patterns q  Back to Main Menu
p  Set as System      P  Populate Cache   c  Code Patterns
l  List All Patterns  I  Initial Setup    w  Writing Patterns
v  View Pattern Details                   a  Analysis Patterns
#+end_src

**** Display Options Section

Commands to customize the display:

- *Toggle Interface Level (A)*: Switch between basic and advanced interfaces
- *Toggle Debug Mode (B)*: Enable/disable JSON debug information
- *Toggle Token Display (T)*: Show/hide token usage statistics
- *Display Token Stats (U)*: Show detailed token usage information
- *Toggle Markdown->Org (C-o)*: Enable/disable conversion to Org format
- *Toggle Model Colors (c)*: Enable/disable model-specific colors
- *Token Usage Graph (g)*: Display a visual graph of token usage

**** History Section

Commands for managing conversation history:

- *Toggle History (H)*: Enable/disable conversation history
- *Clear History (X)*: Clear the current history
- *Display History (V)*: Show the conversation history
- *Edit History (J)*: Edit the history in a buffer

**** Sessions Section

Commands for session management:

- *New Session (N)*: Start a new session
- *Load Session (L)*: Load a saved session
- *Save Session (S)*: Save the current session
- *List Sessions (Q)*: List all available sessions
- *Delete Session (Z)*: Delete a saved session

**** Parameters Section

Commands for managing model parameters:

- *Edit Parameter (P)*: Opens a submenu to edit specific parameters
- *Display Parameters (G)*: Show current parameter settings
- *Parameter Help (I)*: Display help information about parameters
- *Reset Parameters (K)*: Reset parameters to defaults
- *Toggle Params in Header (F)*: Show/hide parameters in header
- *Parameter Profiles (p)*: Opens the parameter profiles submenu

When you select the Edit Parameter option, you'll see a comprehensive submenu of all available parameters:

#+begin_src 
Parameters
[Generation]                [More Generation]          [Mirostat]
t  Temperature              f  Frequency Penalty       M  Mirostat Mode
k  Top K                    s  Presence Penalty        T  Mirostat Tau
p  Top P                    n  Repeat Last N           E  Mirostat Eta
m  Min P                    x  Stop Sequences
y  Typical P                l  Penalize Newline
r  Repeat Penalty

[Resource]                  [More Resource]            [Memory]
c  Num Ctx                  P  Num Predict             m  Use MMAP
b  Num Batch                S  Seed                    L  Use MLOCK
g  Num GPU                  N  NUMA                    C  Num Thread
G  Main GPU                 V  Low VRAM
K  Num Keep                 o  Vocab Only

[Profiles]                  [Actions]
d  Default Profile          D  Display All
a  Creative Profile         R  Reset All
e  Precise Profile          H  Help
A  All Profiles             F  Toggle Display in Header
                            q  Back to Main Menu
#+end_src

*** Parameter Profiles

Ollama Buddy includes predefined parameter profiles that can be applied with a single command. When you select "Parameter Profiles" from the main menu, you'll see:

#+begin_src 
Parameter Profiles
Current modified parameters: temperature, top_k, top_p
[Available Profiles]
d  Default
c  Creative
p  Precise

[Actions]
q  Back to Main Menu
#+end_src

*** Commands Submenu

The Commands submenu provides quick access to specialized operations:

#+begin_src 
Ollama Buddy Commands
[Code Operations]       [Language Operations]    [Pattern-based]         [Custom]
r  Refactor Code        l  Dictionary Lookup     f  Fabric Patterns      C  Custom Prompt
d  Describe Code        s  Synonym Lookup        u  Universal Patterns   m  Minibuffer Prompt
g  Git Commit Message   p  Proofread Text        c  Code Patterns

[Actions]
q  Back to Main Menu
#+end_src

*** Direct Keybindings

For experienced users who prefer direct keybindings, all transient menu functions can also be accessed through keybindings with the prefix of your choice (or =C-c O= when in the chat minibuffer) followed by the key shown in the menu. For example:

- =C-c O s= - Set system prompt
- =C-c O m= - Switch model
- =C-c O P= - Open parameter menu

*** Customization

The transient menu can be customized by modifying the =transient-define-prefix= definitions in the package. You can add, remove, or rearrange commands to suit your workflow.

** <2025-03-17> *0.9.5*

Added conversation history editing

- Added functions to edit conversation history (=ollama-buddy-history-edit=, =ollama-buddy-history-save=, etc.).
- Updated =ollama-buddy-display-history= to support history editing.
- Added keybinding =C-c E= for history editing.

Introducing conversation history editing!!

*Key Features*

Now, you can directly modify past interactions, making it easier to refine and manage your =ollama-buddy= chat history.

Previously, conversation history was static, you could view it but not change it. With this update, you can now:

- Edit conversation history directly in a buffer.
- Modify past interactions for accuracy or clarity.
- Save or discard changes with intuitive keybindings (=C-c C-c= to save, =C-c C-k= to cancel).
- Edit the history of all models or a specific one.

Simply use the new command *=C-c E=* to open the conversation history editor. This will display your past interactions in an editable format (alist). Once you’ve made your changes, press =C-c C-c= to save them back into Ollama Buddy’s memory.

and with a universal argument you can leverage =C-c E= to edit an individual model.

** <2025-03-17> *0.9.1*

New simple basic interface is available.

As this package becomes more advanced, I've been adding more to the intro message, making it increasingly cluttered. This could be off-putting for users who just want a simple interface to a local LLM via Ollama.

Therefore I have decided to add a customization option to simplify the menu.

Note: all functionality will still be available through keybindings, so just like Emacs then! :)

Note: some could see this initially as a breaking change as the intro message will look different, but rest assured all the functionality is still there (just to re-emphasize), so if you have been using it before and want the original functionality/intro message, just set :

#+begin_src 
(setq ollama-buddy-interface-level 'advanced)
#+end_src

#+begin_src elisp
(defcustom ollama-buddy-interface-level 'basic
  "Level of interface complexity to display.
'basic shows minimal commands for new users.
'advanced shows all available commands and features."
  :type '(choice (const :tag "Basic (for beginners)" basic)
                (const :tag "Advanced (full features)" advanced))
  :group 'ollama-buddy)
#+end_src

By default the menu will be set to Basic, unless obviously set explictly in an init file.  Here is an example of the basic menu:

#+begin_src 
,*** Welcome to OLLAMA BUDDY

,#+begin_example
 ___ _ _      n _ n      ___       _   _ _ _
|   | | |__._|o(Y)o|__._| . |_ _ _| |_| | | |
| | | | | .  |     | .  | . | | | . | . |__ |
|___|_|_|__/_|_|_|_|__/_|___|___|___|___|___|
,#+end_example

,**** Available Models

  (a) another:latest     (d) jamesio:latest
  (b) funnyname2:latest  (e) tinyllama:latest
  (c) funnyname:latest   (f) llama:latest

,**** Quick Tips

- Ask me anything!                    C-c C-c
- Change model                        C-c m
- Cancel request                      C-c k
- Browse prompt history               M-p/M-n
- Advanced interface (show all tips)  C-c A
#+end_src

and of the more advanced version

#+begin_src 
,*** Welcome to OLLAMA BUDDY

,#+begin_example
 ___ _ _      n _ n      ___       _   _ _ _
|   | | |__._|o(Y)o|__._| . |_ _ _| |_| | | |
| | | | | .  |     | .  | . | | | . | . |__ |
|___|_|_|__/_|_|_|_|__/_|___|___|___|___|___|
,#+end_example

,**** Available Models

  (a) another:latest     (d) jamesio:latest
  (b) funnyname2:latest  (e) tinyllama:latest
  (c) funnyname:latest   (f) llama:latest

,**** Quick Tips

- Ask me anything!                    C-c C-c
- Show Help/Token-usage/System-prompt C-c h/U/C-s
- Model Change/Info/Cancel            C-c m/i/k
- Prompt history                      M-p/M-n
- Session New/Load/Save/List/Delete   C-c N/L/S/Y/W
- History Toggle/Clear/Show           C-c H/X/V
- Prompt to multiple models           C-c l
- Parameter Edit/Show/Help/Reset      C-c P/G/I/K
- System Prompt/Clear   C-u/+C-u +C-u C-c C-c
- Toggle JSON/Token/Params/Format     C-c D/T/Z/C-o
- Basic interface (simpler display)   C-c A
- In another buffer? M-x ollama-buddy-menu
#+end_src

** <2025-03-17> *0.9.0*

Added command-specific parameter customization

- Added :parameters property to command definitions for granular control
- Implemented functions to apply and restore parameter settings
- Added example configuration to refactor-code command

With the latest update, you can now define specific parameter sets for each command in the menu, enabling you to optimize each AI interaction for its particular use case.

Different AI tasks benefit from different parameter settings. When refactoring code, you might want a more deterministic, precise response (lower temperature, higher repetition penalty), but when generating creative content, you might prefer more variation and randomness (higher temperature, lower repetition penalty). Previously, you had to manually adjust these parameters each time you switched between different types of tasks.

The new command-specific parameters feature lets you pre-configure the optimal settings for each use case. Here's how it works:

*** Key Features

- *Per-Command Parameter Sets*: Define custom parameter values for each command in your menu
- *Automatic Application*: Parameters are applied when running a command and restored afterward
- *Non-Destructive*: Your global parameter settings remain untouched
- *Easy Configuration*: Simple interface for adding or updating parameters

*** Example Configuration

#+begin_src elisp
;; Define a command with specific parameters
(refactor-code
 :key ?r
 :description "Refactor code"
 :prompt "refactor the following code:"
 :system "You are an expert software engineer..."
 :parameters ((temperature . 0.2) (top_p . 0.7) (repeat_penalty . 1.3))
 :action (lambda () (ollama-buddy--send-with-command 'refactor-code)))

;; Add parameters to an existing command
(ollama-buddy-add-parameters-to-command 'git-commit
 :temperature 0.4
 :top_p 0.9
 :repeat_penalty 1.1)

;; Update properties and parameters at once
(ollama-buddy-update-command-with-params 'describe-code
 :model "codellama:latest"
 :parameters '((temperature . 0.3) (top_p . 0.8)))
#+end_src

This feature is particularly useful for:

1. *Code-related tasks*: Lower temperature for more deterministic code generation
2. *Creative writing*: Higher temperature for more varied and creative outputs
3. *Technical explanations*: Balanced settings for clear, accurate explanations
4. *Summarization tasks*: Custom parameters to control verbosity and focus

** <2025-03-16> *0.8.5*

Added system prompt support for commands

- Introduced `:system` field to command definitions.
- Added `ollama-buddy-show-system-prompt` to view active system prompt.
- Updated UI elements to reflect system prompt status.

Previously, individual menu commands in =ollama-buddy= only included a user prompt. Now, each command can define a *system prompt*, which provides background context to guide the AI's responses. This makes interactions more precise and tailored.  

*Key Features*

- *System prompts per command*: Specify background instructions for each AI-powered command using the new =:system= field.  
- *View active system prompt*: Use =C-c C-s= to display the current system prompt in a dedicated buffer.  
- *Updated UI elements*: The status line now indicates whether a system prompt is active.  

A helper function has also been added to update the default menu, for example, you might want to tweak a couple of things:

#+begin_src elisp
(use-package ollama-buddy
  :bind ("C-c o" . ollama-buddy-menu)
  :custom
  (ollama-buddy-default-model "llama3.2:3b")
  :config
  (ollama-buddy-update-menu-entry
   'refactor-code
   :model "qwen2.5-coder:7b"
   :system "You are an expert software engineer who improves code and only mainly using the principles exhibited by Ada")
  (ollama-buddy-update-menu-entry
   'git-commit
   :model "qwen2.5-coder:3b"
   :system "You are a version control expert and mainly using subversion"))
#+end_src

* DONE Ollama-Buddy 0.8.0 - Added System Prompts, Model Info and simpler menu model assignment :ollama_buddy:ollama:ai:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250314132104-emacs--Ollama-Buddy-0-8-0-Added-System-Prompts-Model-Info-and-simpler-menu-model-assignment
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-03-14 13:21>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250314132104-emacs--Ollama-Buddy-0-8-0-Added-System-Prompts-Model-Info-and-simpler-menu-model-assignment.jpg
:END:

More improvements to =ollama-buddy= https://github.com/captainflasmr/ollama-buddy

The main addition is that of system prompts, which allows setting the general tone and guidance of the overall chat.  Currently the system prompt can be set at any time and turned on and off but I think to enhance my model/command for each menu item concept, I could also add a :system property to the menu alist definition to allow even tighter control of a menu action to prompt response.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250314132104-emacs--Ollama-Buddy-0-8-0-Added-System-Prompts-Model-Info-and-simpler-menu-model-assignment.jpg]]

Also now I have parameter functionality working for fine grained control, I could add these individual parameters for each menu command, for example the =temperature= could be very useful in this case to play around with the randomness/casualness of the response.

The next improvement will likely involve adding support for interacting more directly with Ollama to create and pull models. However, I'm still unsure whether performing this within Emacs is the best approach, I could assume that all models are already set up in Ollama.  

That said, importing a GGUF file might be a useful feature, possibly from within =dired=. Currently, this process requires multiple steps: creating a simple model file that points to the GGUF file on disk, then running the =ollama create= command to import it. Streamlining this workflow could enhance usability.  

Then maybe on to embeddings, of which I currently have no idea, haven't read up on it, nuffin, but that is something to look forward to! :)

Anyways, here is the latest set of updates to Ollama Buddy:

** <2025-03-14> *0.8.0*

Added system prompt support

- Added =ollama-buddy--current-system-prompt= variable to track system prompts
- Updated prompt area rendering to distinguish system prompts
- Modified request payload to include system prompt when set
- Enhanced status bar to display system prompt indicator
- Improved help menu with system prompt keybindings

So this is system prompt support in Ollama Buddy!, allowing you to set and manage system-level instructions for your AI interactions. This feature enables you to define a *persistent system prompt* that remains active across user queries, providing better control over conversation context.  

*Key Features*

You can now designate any user prompt as a system prompt, ensuring that the AI considers it as a guiding instruction for future interactions. To set the system prompt, use:  

#+begin_src bash
C-u C-c C-c
#+end_src

*Example:*

1. Type:

#+begin_src bash
Always respond in a formal tone.
#+end_src

2. Press =C-u C-c C-c= This prompt is now set as the *system prompt* and any further chat ollama responses will adhere to the overarching guidelines defined in the prompt.

If you need to clear the system prompt and revert to normal interactions, use:  

#+begin_src bash
C-u C-u C-c C-c
#+end_src

*How It Works*

- The active *system prompt* is stored and sent with each user prompt.  
- A "S" indicator appears in the status bar when a system prompt is active.  
- The request payload now includes the system role, allowing AI to recognize persistent instructions.  

*Demo*

Set the system message to:

You must always respond in a single sentence.

Now ask the following:

Tell me why Emacs is so great!

Tell me about black holes

clear the system message and ask again, the responses should now be more verbose!!

#+attr_org: :width 300px
#+attr_html: :width 100%
#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/ollama-buddy-screen-recording_015.gif]]

** <2025-03-13> *0.7.4*

Added model info command, update keybindings

- Added `ollama-buddy-show-raw-model-info` to fetch and display raw JSON details 
  of the current model in the chat buffer.
- Updated keybindings:
  - `C-c i` now triggers model info display.
  - `C-c h` mapped to help assistant.
  - Improved shortcut descriptions in quick tips section.
- Removed unused help assistant entry from menu.
- Changed minibuffer-prompt key from `?i` to `?b`.

** <2025-03-12> *0.7.3*

Added function to associate models with menu commands

- Added =ollama-buddy-add-model-to-menu-entry= autoload function
- Enabled dynamic modification of command-model associations

This is a helper function that allows you to associate specific models with individual menu commands.

Configuration to apply a model to a menu entry is now straightforward, in your Emacs init file, add something like:

#+begin_src elisp
(with-eval-after-load 'ollama-buddy
  (ollama-buddy-add-model-to-menu-entry 'dictionary-lookup "tinyllama:latest")
  (ollama-buddy-add-model-to-menu-entry 'synonym "tinyllama:latest"))
#+end_src

This configures simpler tasks like dictionary lookups and synonym searches to use the more efficient TinyLlama model, while your default model will still be used for more complex operations.

** <2025-03-12> *0.7.2*

Added menu model colours back in and removed some redundant code

* DONE Ollama-Buddy 0.7.1 - Org-mode Chat, Parameter Control and JSON Debugging :ollama_buddy:ollama:emacs:ai:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250311180746-emacs--Ollama-Buddy-0-7-1-Org-mode-Chat-Parameter-Control-and-JSON-Debugging
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-03-11 18:07>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250311180746-emacs--Ollama-Buddy-0-7-1-Org-mode-Chat-Parameter-Control-and-JSON-Debugging.jpg
:END:

Continuing the development of my local =ollama= LLM client called =ollama-buddy=...

https://github.com/captainflasmr/ollama-buddy

The basic functionality, I think, is now there (and now literally zero configuration required).  If a default model isn't set I just pick the first one, so LLM chat can take place immediately.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250311180746-emacs--Ollama-Buddy-0-7-1-Org-mode-Chat-Parameter-Control-and-JSON-Debugging.jpg]]

Now I'm getting more into this chat client malarkey, my original idea of a very minimal chat client to interface to =ollama= is starting to skew into supporting as much of the =ollama= RESTful API as possible.  Hence in this update a more advanced approach is creeping in, including setting up various subtle model parameters and providing a debugging window to monitor incoming raw JSON (pretty printed of course).  Hopefully, these features will remain tucked away for advanced users, I’ve done my best to keep them unobtrusive (but not *too* hidden). The tool is still designed to be a helpful companion to interface to =ollama= through Emacs, just now with more powerful options under the hood.

Also a note about converting the chat buffer into org-mode.  My original intention was to keep the chat buffer as a very simple almost "no mode" buffer, with just text and nothing else.  However, with more consideration, I felt that converting this buffer into org-mode actually held quite a few benefits:

- Each prompt could be a heading, hence outlining and folding can be activated!
- Navigation between prompts now comes for free (especially if you are using =org-use-speed-commands=)
- The org ox export backend now allows us to export to formats of many different kinds

I'm sure there are more as this list isn't quite the "quite a few benefits" I was hoping for :(

I have a local keymap defined with some ollama-buddy specific keybindings, and as of yet I haven’t encountered any conflicts with commonly used =org-mode= bindings but we shall see how it goes. I think for this package it is important to have a quick chatting mechanism, and what is faster than a good keybind?

Finally, just a note on the pain of implementing a good prompt mechanism.  I had a few goes at it and I think I now have an acceptable robust solution.  I kept running into little annoying edge cases and I ended up having to refactor quite a bit.  My original idea for this package involved a simple “mark region and send” as at the time I had a feeling that the implementation of a good prompt mechanism would be tough - how right I was!.  Things got even trickier with the move to =org-mode=, since each prompt heading should contain meaningful content for clean exports and I had to implement a mechanism to replace prompts intelligently. For example, if the model is swapped and the previous prompt is blank, it gets replaced, though, of course, even this has its own edge cases - gives a new meaning to prompt engineering! :)

Anyways, listed below are my latest changes, with a little deeper dive into more "interesting" implementations, my next ideas are a little more advanced and are kanban'd into my github README at https://github.com/captainflasmr/ollama-buddy for those that are interested.

** <2025-03-11> *0.7.1*

Added debug mode to display raw JSON messages in a debug buffer

- Created new debug buffer to show raw JSON messages from Ollama API
- Added toggle function to enable/disable debug mode (ollama-buddy-toggle-debug-mode)
- Modified stream filter to log and pretty-print incoming JSON messages
- Added keybinding C-c D to toggle debug mode
- Updated documentation in welcome message

** <2025-03-11> *0.7.0*

Added comprehensive Ollama parameter management

- Added customization for all Ollama option API parameters with defaults
- Only send modified parameters to preserve Ollama defaults
- Display active parameters with visual indicators for modified values
- Add keybindings and help system for parameter management
- Remove redundant temperature controls in favor of unified parameters

Introduced parameter management capabilities that give you complete control over your Ollama model's behavior through the options in the ollamas API.

Ollama's API supports a rich set of parameters for fine-tuning text generation, from controlling creativity with =temperature= to managing token selection with =top_p= and =top_k=. Until now, Ollama Buddy only exposed the =temperature= parameter, but this update unlocks the full potential of Ollama's parameter system!

*** Key Features:

- *All Parameters* - set all custom options for the ollama LLM at runtime
- *Smart Parameter Management*: Only modified parameters are sent to Ollama, preserving the model's built-in defaults for optimal performance
- *Visual Parameter Interface*: Clear display showing which parameters are active with highlighting for modified values

** Keyboard Shortcuts

Parameter management is accessible through simple keyboard shortcuts from the chat buffer:

- =C-c P= - Edit a parameter
- =C-c G= - Display current parameters
- =C-c I= - Show parameter help
- =C-c K= - Reset parameters to defaults

** <2025-03-10> *0.6.1*

Refactored prompt handling so each org header line should now always have a prompt for better export

- Added functionality to properly handle prompt text when showing/replacing prompts
- Extracted inline lambdas in menu actions into named functions
- Added fallback for when no default model is set

** <2025-03-08> *0.6.0*

Chat buffer now in org-mode

- Enabled =org-mode= in chat buffer for better text structure
- Implemented =ollama-buddy--md-to-org-convert-region= for Markdown to Org conversion
- Turn org conversion on and off
- Updated keybindings =C-c C-o= to toggle Markdown to Org conversion

*Key Features*  

1. The chat buffer is now in =org-mode= which gives the buffer enhanced readability and structure. Now, conversations automatically format user prompts and AI responses with *org-mode headings*, making them easier to navigate.

2. Of course with org-mode you will now get the additional benefits for free, such as:

   - outlining
   - org export
   - heading navigation
   - source code fontification

3. Previously, responses in *Ollama Buddy* were displayed in markdown formatting, which wasn’t always ideal for *org-mode users*. Now, you can automatically convert Markdown elements, such as bold/italic text, code blocks, and lists, into proper org-mode formatting.  This gives you the flexibility to work with markdown or org-mode as needed.  

* DONE Ollama-Buddy V0.5.1 - Session/History/Role Management, Real-Time Token Tracking and More! :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250307133856-emacs--Ollama-Buddy-Version-0-5-1
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-03-07 13:50>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250224154229-emacs--Ollama-Buddy-Now-On-MELPA.jpg
:END:

I've been a busy little bee in the last few days, so quite a few improvements to =ollama-buddy=, my Emacs LLM =ollama= client, they are listed below:

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/ollama-buddy-banner.jpg]]

** <2025-03-07> *0.5.1*

Added temperature control

- Implemented temperature control parameter
- Added menu commands for setting (T), resetting (0)
- Added keybindings (C-c t/T/0) for quick temperature adjustments
- Updated header line and prompt displays to show current temperature
- Included temperature info in welcome screen with usage guidance

This addition gives users fine-grained control over the creativity and randomness of their AI responses through a new temperature variable.

This update adds several convenient ways to control temperature in Ollama-Buddy:

*Key Features*

1. *Direct Temperature Setting*: Use =C-c t= from the chat buffer or the menu command =[T]= to set an exact temperature value between 0.0 and 2.0.

2. *Preset Temperatures*: Quickly switch between common temperature presets with =C-c T= from the chat buffer:
   - Precise (0.1) - For factual responses
   - Focused (0.3) - For deterministic, coherent outputs
   - Balanced (0.7) - Default setting
   - Creative (0.9) - For more varied, creative responses

3. *Reset to Default*: Return to the default temperature (0.7) with =C-c 0= or the menu command =[0]=.

4. *Visual Feedback*: The current temperature is displayed in the header line and before each response, so you always know what setting you're using.

** <2025-03-06> *0.5.0*

Implemented session management, so you can now save your conversations and bring them back with the relevant context and chat history!

- Chat history is now maintained separately for each model
- Added session new/load/save/delete/list functionality
- A switch in context can now be achieved by any of the following methods:
  - Loading a previous session
  - Creating a new session
  - Clearing history on the current session
  - Toggling history on and off

*Key Benefits*

- More relevant responses when switching between models
- Prevents context contamination across different models
- Clearer session management and organization

*Key Features*

1. *Session Management*

With session management, you can now:

- *Save session* with =ollama-buddy-sessions-save= (or through the ollama-buddy-menu) Preserve your current conversation with a custom name
- *Load session* with =ollama-buddy-sessions-load= (or through the ollama-buddy-menu) Return to previous conversations exactly where you left off
- *List all sessions* with =ollama-buddy-sessions-list= (or through the ollama-buddy-menu) View all saved sessions with metadata including timestamps and models used
- *Delete session* with =ollama-buddy-sessions-delete= (or through the ollama-buddy-menu) Clean up sessions you no longer need
- *New session* with =ollama-buddy-sessions-new=  (or through the ollama-buddy-menu) Begin a clean slate without losing your saved sessions

2. *Menu Commands*

The following commands have been added to the =ollama-buddy-menu=:

- =E= New session
- =L= Load session
- =S= Save session
- =Y= List sessions
- =K= Delete session

** <2025-03-04> *0.4.1*

Added a sparse version of =ollama-buddy= called =ollama-buddy-mini=, see the github repository for the elisp file and a description in =README-mini.org=

** <2025-03-03> *0.4.0*

Added conversation history support and navigation functions

- Implemented conversation history tracking between prompts and responses
- Added configurable history length limits and visual indicators
- Created navigation functions to move between prompts/responses in buffer

*Key Features*

1. *Conversation History*

Ollama Buddy now maintains context between your interactions by:

- Tracking conversation history between prompts and responses
- Sending previous messages to Ollama for improved contextual responses
- Displaying a history counter in the status line showing conversation length
- Providing configurable history length limits to control memory usage

You can control this feature with:

#+begin_src elisp
;; Enable/disable conversation history (default: t)
(setq ollama-buddy-history-enabled t)

;; Set maximum conversation pairs to remember (default: 10)
(setq ollama-buddy-max-history-length 10)

;; Show/hide the history counter in the header line (default: t)
(setq ollama-buddy-show-history-indicator t)
#+end_src

2. *Enhanced Navigation*

Moving through longer conversations is now much easier with:

- Navigation functions to jump between prompts using C-c n/p

3. *Menu Commands*

Three new menu commands have been added:

- =H=: Toggle history tracking on/off
- =X=: Clear the current conversation history
- =V=: View the full conversation history in a dedicated buffer

** <2025-03-02> *0.3.1*

Enhanced model colour contrast with themes, allowing =ollama-buddy-enable-model-colors= to be enabled by default.

** <2025-03-01> *0.3.0*

Added real-time token usage tracking and display

- Introduce variables to track token counts, rates, and usage history
- Implement real-time token rate updates with a timer
- Add a function to display token usage statistics in a dedicated buffer
- Allow toggling of token stats display after responses
- Integrate token tracking into response processing and status updates
- Ensure cleanup of timers and tracking variables on completion or cancellation

*Key Features*

1. *Menu Commands*

   The following command has been added to the =ollama-buddy-menu=:

   - =t= Show a summary of token model usage stats

** <2025-02-28> *0.2.4*

Added model-specific color highlighting

- Introduce `ollama-buddy-enable-model-colors` (default: nil) to toggle model-based color highlighting.
- Assign consistent colors to models based on string hashing.
- Apply colors to model names in the menu, status, headers, and responses.
- Add `ollama-buddy-toggle-model-colors` command to toggle this feature.

This enhancement aims to improve user experience by visually distinguishing different AI models within the interface.

Note: I am likely to use both *colour* and *color* interchangeably in the following text! :)

*Key Features*

1. *Model-Specific Colors*
   
   - A new customizable variable, =ollama-buddy-enable-model-colors=, allows users to enable or disable model-specific colors.
   - Colors are generated based on a model's name using a hashing function that produces consistent and visually distinguishable hues.
   - However there could be an improvement regarding ensuring the contrast is sufficient and hence visibility maintained with differing themes.

2. *Interactive Color Toggle*
   - Users can toggle model-specific colors with the command =ollama-buddy-toggle-model-colors=, providing flexibility in interface customization.

4. *Colored Model Listings*
   - Model names are now displayed with their respective colors in various parts of the interface, including:
     - The status line
     - Model selection menus
     - Command definitions
     - Chat history headers

5. *Menu Commands*

The following command hashing been added to the =ollama-buddy-menu=:

- =C= Toggle colors

** <2025-02-28> *0.2.3*

Added Prompt History Support

- Prompts are now integrated into the Emacs history mechanism which means they persist across sessions.  
- Use =M-p= to navigate prompt history, and =M-p= / =M-n= within the minibuffer to insert previous prompts.  

*Key Features*

- Persistent prompt history
- A new variable, =ollama-buddy--prompt-history=, now keeps track of past prompts. This means you can quickly recall and reuse previous queries instead of retyping them from scratch.
- =M-p= - recall a previous prompt in the buffer which will bring up the minibuffer for prompt history selection.
- Minibuffer =M-p= / =M-n= - Navigate through past prompts when prompted for input.

** <2025-02-27> *0.2.2*

Added support for role-based presets

- Introduced `ollama-buddy-roles-directory` for storing role preset files.
- Implemented interactive functions to manage roles:
  - `ollama-buddy-roles-switch-role`
  - `ollama-buddy-role-creator-create-new-role`
  - `ollama-buddy-roles-open-directory`
- Added ability to create and switch between role-specific commands.
- Updated menu commands to include role management options.

This enhancement allows you to create, switch, and manage role-specific command configurations, which basically generates differing menu layouts and hence command options based on your context, making your workflow more personalized and efficient.  

*What Are Role-Based Presets?*

Roles in Ollama Buddy are essentially *profiles* tailored to specific tasks. Imagine you're using Ollama Buddy for:  

- *Coding assistance* with one set of prompts
- *Creative writing* with a different tone and response style
- *Generating Buffy Style Quips* - just a fun one!

With this update, you can now create presets for each of these contexts and switch between them seamlessly without manually re-configuring settings every time. On each switch of context and hence role, a new ollama buddy menu will be generated with the associated keybinding attached to the relevant context commands.

*Key Features*

*1. Store Your Custom Roles*

A new directory =ollama-buddy-roles-directory= (defaulting to =~/.emacs.d/ollama-buddy-presets/=) now holds your role presets. Each role is saved as an =.el= file containing predefined *commands*, *shortcuts*, and *model preferences*.  

*2. Easily Switch Between Roles*

With =M-x ollama-buddy-roles-switch-role= you can pick from available role presets and swap effortlessly between them (or use the menu item from =ollama-buddy-menu=)

*3. Create Custom Roles with Unique Commands*

You can now define *custom commands* for each role with =M-x ollama-buddy-role-creator-create-new-role= (or the menu item from =ollama-buddy-menu=)

This interactive function allows you to:  

- Assign menu shortcuts to commands  
- Describe command behaviour  
- Set a default AI model  
- Define a system prompt for guiding responses  

Once saved, your new role is ready to load anytime!  

*4. Open Role Directory in Dired*

Need to tweak a role manually? A simple, run =M-x ollama-buddy-roles-open-directory= or of course also from the =ollama-buddy-menu= which opens the presets folder in *dired*, where you can quickly edit, copy, or delete role configurations.

*5. Preconfigured presets are available if you'd like to use a ready-made setup.*

- ollama-buddy--preset__buffy.el
- ollama-buddy--preset__default.el
- ollama-buddy--preset__developer.el
- ollama-buddy--preset__janeway.el
- ollama-buddy--preset__translator.el
- ollama-buddy--preset__writer.el

If these files are put in the =ollama-buddy-roles-directory= then the role selection menu will pass through completing-read, and present the following:

{buffy | default | developer | janeway | translator | writer}

With the selection regenerating the =ollama-buddy-menu= accordingly, and off you go.

*6. Menu commands*

The following commands have been added to the =ollama-buddy-menu=:

- =R= Switch Role
- =N= Create New Role
- =D= Open Roles Directory

* TODO Streamlining the Selected-Window-Accent-Mode in Emacs :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250304162617-emacs--Streamlining-the-Selected-Window-Accent-Mode-in-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-03-04 16:26>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250304162617-emacs--Streamlining-the-Selected-Window-Accent-Mode-in-Emacs.jpg
:END:

Today, I'm examining a significant refactoring of my =selected-window-accent-mode= package, which has been transformed from a feature-rich but complex tool to highlight the selected-window into a leaner, more focused implementation.

** What is Selected Window Accent Mode?

For those unfamiliar with this package, =selected-window-accent-mode= is a utility that visually distinguishes your currently active Emacs window by applying accent colors to its fringes, mode line, and other UI elements. This is particularly useful when working with multiple split windows, as it makes it immediately clear which window has focus.

** The Evolution: From Complex to Streamlined

Let's have a look at my streamlining and explore the key differences between the original version and the streamlined implementation.

*** 1. Reduced Dependencies

*Original Version:*
#+begin_src elisp
(require 'json)
(require 'color)
(require 'transient)
#+end_src

*Streamlined Version:*
#+begin_src elisp
(require 'color)
#+end_src

The new implementation drops the dependencies on =json= and =transient=, eliminating functionality related to JSON parsing (for pywal integration) and the transient interface. This makes the package lighter and reduces potential compatibility issues.

*** 2. Removed Advanced Features

Several advanced features have been removed from the streamlined version:

- *Pywal Integration*: The ability to use colors from pywal-generated palettes
- *Background Blending*: The feature to blend accent colors with window backgrounds
- *Complementary Colors*: The ability to automatically generate complementary foreground colors
- *Header Line Handling*: Special logic for header line formatting and heights

Just a note on the *Header Line Handling* - Due to technical limitations of the current implementation of Emacs it wasn't quite possible to create a tiling window manager full surrounding border, although I do have hope as I read somewhere that a header-line-active and header-line-inactive was being considered.  I also ran into problems when trying to preserve any buffer that already utilized the header-line.  So my solution?, is to just remove the calculation so in fact the 'tiling highlighting option now generates an accent around 3 sides, like a bucket!

*** 3. Simplified Color Handling

The original version had complex color manipulation functions:

#+begin_src elisp
(defun selected-window-accent--increment-color-brightness (hex-color factor)...)
(defun selected-window-accent--decrement-color-brightness (hex-color factor)...)
(defun selected-window-accent--invert-color (hex-color)...)
(defun selected-window-accent--set-foreground-color (bg-color)...)
(defun selected-window-accent-blend-colors (color1 color2 alpha)...)
#+end_src

These have been consolidated into a single, straightforward function in the new version:

#+begin_src elisp
(defun selected-window-accent--determine-foreground (bg-color)
  "Determine appropriate foreground color based on BG-COLOR brightness."
  (if (string-greaterp bg-color "#888888") "#000000" "#ffffff"))
#+end_src

*** 5. Cleaner Window Handling

The core =selected-window-accent= function has been streamlined significantly. The original version was approximately 120 lines, while the new implementation achieves the same core functionality in about 70 lines. The window handling code is more focused and easier to follow.

*** 6. Simpler Command Interface

The original package used a transient interface (similar to Magit) for its commands.

#+begin_src elisp
(transient-define-prefix selected-window-accent-transient ()
  "Transient for selected window accent."
  ["Selected Window Accent"
   ["Main"
    ("s" "Switch Style" selected-window-accent-switch-selected-window-accent-style)
    ...]])
#+end_src

The streamlined version replaces this with a simple keymap:

#+begin_src elisp
(defvar selected-window-accent-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "w") 'selected-window-accent-switch-style)
    ...
    map)
  "Keymap for selected-window-accent commands.")
#+end_src

** What Was Lost?

While the streamlined version is more efficient, it does sacrifice some functionality:

- *Foreground Color Controls*: The ability to fine-tune foreground colors with incremental adjustments
- *Complementary Color Generation*: Automatic creation of complementary color schemes
- *Background Blending*: The feature to blend accent colors with window backgrounds
- *Configuration Export*: The function to export current settings to a buffer
- *Pywal Integration*: The ability to use colors from pywal-generated palettes
- *Transient Interface*: The more sophisticated command menu

If you want to use the more function rich version, I would recommend pulling a previous version.

** Is the Simpler Version Better?

Whether the streamlined version is "better" depends on your needs:

- If you want a lightweight, focused tool that simply highlights your active window without fuss, the new version is ideal
- If you need fine-grained control over color schemes, pywal integration, or other advanced features, you might prefer the original version

* DONE Ollama Buddy Version 0.2.1 - Same prompt to multiple LLMs and choose best answer! :ollama_buddy:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250302093517-emacs--Ollama-Buddy-Version-0-2-1
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-03-02 09:35>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250224154229-emacs--Ollama-Buddy-Now-On-MELPA.jpg
:END:

Some improvements to my ollama LLM package...

With the new *multishot mode*, you can now send a prompt to multiple models in sequence, and compare their responses, the results are also available in named registers.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/ollama-buddy-banner.jpg]]

*Letter-Based Model Shortcuts*

Instead of manually selecting models, each available model is now assigned a *letter* (e.g., =(a) mistral=, =(b) gemini=). This allows for quick model selection when sending prompts or initiating a *multishot sequence*.

*Multishot Execution (=C-c C-l=)*

Ever wondered how different models would answer the same question? With *Multishot Mode*, you can:

- Send your prompt to a sequence of models in one shot.  
- Track progress as responses come in.  
- Store each model’s response in a *register*, making it easy to reference later, each assigned model letter corresponds to the named register.

*Status Updates*

When running a multishot execution, the status now updates dynamically:

- *"Multi Start"* when the sequence begins.  
- *"Processing..."* during responses.  
- *"Multi Finished"* when all models have responded.  

*How It Works*

1. *=C-c C-l=* to start a multishot session in the chat buffer.
2. Type a sequence of model letters (e.g., =abc= to use models =mistral=, =gemini=, and =llama=).  
3. The selected models will process the prompt *one by one*.  
4. The responses will be saved to registers of the same named letter for recalling later.


#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/ollama-buddy-screen-recording_007.gif]]

* DONE Installing Emacs 30.1 On Arch and SUSE :emacs:30_1:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250226140529-emacs--Installing-30_1-On-Arch
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-02-26 14:05>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250226140529-emacs--Installing-30_1-On-Arch.jpg
:END:

Seems to be a common post at the moment, so I thought I would quickly put out there how I updated to Emacs 30.1.

I use an Arch spin called Garuda, running SwayWM, so as its on wayland, this for me is simple, just update the system using =pacman -Syu= and =emacs-wayland= will pull in 30.1 automatically!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250226140529-emacs--Installing-30_1-On-Arch.jpg]]

For my other environments, or if I want to build old versions of Emacs from source, I use the following script:

#+begin_src bash
#!/bin/bash

# Directory for Emacs builds
BUILD_ROOT="$HOME/emacs-builds"
INSTALL_ROOT="$HOME/emacs-versions"

# Build dependencies for different distributions
ARCH_BUILD_DEPS="base-devel gtk2 gtk3 libxpm libjpeg-turbo libpng libtiff giflib libxml2 gnutls librsvg"
SLES_BUILD_DEPS="gcc gcc-c++ make automake gtk2-devel gtk3-devel libXpm-devel libjpeg8-devel libpng16-devel libtiff-devel giflib-devel libxml2-devel gnutls-devel cairo-devel harfbuzz-devel librsvg-devel"

# 27.2 2021-03-25
# 28.2 2022-09-12
# 29.4 2024-06-22
VERSIONS=(
    "emacs-27.2"
    "emacs-28.2"
    "emacs-29.4"
    "emacs-30.1"
)

# Detect OS
detect_os() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS=$NAME
    else
        OS=$(uname -s)
    fi
}

function prepare_environment() {
    echo "Creating build directories..."
    mkdir -p "$BUILD_ROOT"
    mkdir -p "$INSTALL_ROOT"
    
    detect_os
    echo "Detected OS: $OS"
    
    case "$OS" in
        ,*"SLED"*|"SLES"*|*"SUSE"*)
            echo "Installing build dependencies for SUSE SLES..."
            sudo zypper refresh
            sudo zypper install -y pattern-devel-base-devel
            sudo zypper install -y $SLES_BUILD_DEPS
            ;;
        ,*"Garuda"*)
            echo "Installing build dependencies for Arch Linux..."
            sudo pacman -Syu --needed --noconfirm $ARCH_BUILD_DEPS
            
            # Check if we have yay for AUR access (optional)
            if ! command -v yay &> /dev/null; then
                echo "Installing yay (AUR helper)..."
                cd /tmp
                git clone https://aur.archlinux.org/yay.git
                cd yay
                makepkg -si --noconfirm
            fi
            ;;
        ,*)
            echo "Unsupported OS detected: $OS"
            echo "Please install build dependencies manually and continue."
            read -p "Press Enter to continue or Ctrl+C to abort..."
            ;;
    esac
}

function build_emacs() {
    local version=$1
    local build_dir="$BUILD_ROOT/$version"
    local install_dir="$INSTALL_ROOT/$version"
    
    echo "Building $version..."
    
    # Download and extract
    cd "$BUILD_ROOT"
    if [ ! -f "$version.tar.gz" ]; then
        wget "https://ftp.gnu.org/gnu/emacs/$version.tar.gz"
    fi
    
    # Clean previous build if exists
    rm -rf "$build_dir"
    tar xzf "$version.tar.gz"
    
    # Configure and build
    cd "$version"
    
    # Different configure flags for different versions
    if [[ "$version" == "emacs-24.5" || "$version" == "emacs-25.3" ]]; then
        # Older versions use GTK2
        ./configure \
            --prefix="$install_dir" \
            --with-x-toolkit=gtk2 \
            --with-xpm \
            --with-jpeg \
            --with-png \
            --with-gif \
            --with-tiff \
            --with-gnutls \
            --with-xml2 \
            --with-rsvg
    else
        # Newer versions use GTK3
        ./configure \
            --prefix="$install_dir" \
            --with-x-toolkit=gtk3 \
            --with-xpm \
            --with-jpeg \
            --with-png \
            --with-gif \
            --with-tiff \
            --with-gnutls \
            --with-xml2 \
            --with-cairo \
            --with-harfbuzz \
            --with-rsvg
    fi
    
    # Use all available cores for compilation
    make -j$(nproc)
    make install
    
    echo "$version installed to $install_dir"
}

function create_pkgbuild() {
    # Only create PKGBUILD for Arch Linux
    if [[ "$OS" != *"Arch Linux"* ]]; then
        echo "PKGBUILD creation is only supported on Arch Linux"
        return 1
    fi

    local version=$1
    local version_num=${version#emacs-}
    
    echo "Creating PKGBUILD for $version..."
    mkdir -p "$BUILD_ROOT/pkgbuilds/$version"
    cd "$BUILD_ROOT/pkgbuilds/$version"
    
    cat > PKGBUILD << EOF
# Maintainer: Your Name <your.email@example.com>
pkgname=$version
pkgver=$version_num
pkgrel=1
pkgdesc="GNU Emacs version $version_num"
arch=('x86_64')
url="https://www.gnu.org/software/emacs/"
license=('GPL3')
depends=('gtk3' 'libxpm' 'libjpeg-turbo' 'libpng' 'giflib' 'libtiff' 'libxml2' 'gnutls')
makedepends=('base-devel')
provides=("emacs-$version_num")
conflicts=("emacs")
source=("https://ftp.gnu.org/gnu/emacs/emacs-\$pkgver.tar.gz")
sha256sums=('SKIP')

build() {
    cd "\$srcdir/emacs-\$pkgver"
    ./configure \\
        --prefix=/usr \\
        --sysconfdir=/etc \\
        --libexecdir=/usr/lib \\
        --localstatedir=/var \\
        --with-x-toolkit=gtk3 \\
        --with-xpm \\
        --with-jpeg \\
        --with-png \\
        --with-gif \\
        --with-tiff \\
        --with-gnutls \\
        --with-xml2
    make
}

package() {
    cd "\$srcdir/emacs-\$pkgver"
    make DESTDIR="\$pkgdir" install
}
EOF
}

# Main execution
echo "This script provides two methods to build Emacs:"
echo "1. Direct compilation (traditional)"
echo "2. Using makepkg (Arch Linux only)"
read -p "Which method do you prefer? (1/2): " build_method

case $build_method in
    1)
        prepare_environment
        for version in "${VERSIONS[@]}"; do
            build_emacs "$version"
        done
        
        # Create convenience symlinks
        mkdir -p "$HOME/bin"
        echo "Creating version-specific symlinks..."
        for version in "${VERSIONS[@]}"; do
            ln -sf "$INSTALL_ROOT/$version/bin/emacs" "$HOME/bin/emacs-${version#emacs-}"
        done
        ;;
        
    2)
        detect_os
        if [[ "$OS" != *"Arch Linux"* ]]; then
            echo "makepkg method is only supported on Arch Linux"
            exit 1
        fi
        prepare_environment
        for version in "${VERSIONS[@]}"; do
            create_pkgbuild "$version"
            echo "PKGBUILD created for $version"
            echo "To build, cd to $BUILD_ROOT/pkgbuilds/$version and run 'makepkg -si'"
        done
        ;;
        
    ,*)
        echo "Invalid option selected"
        exit 1
        ;;
esac

echo "Build complete. You can run specific versions using:"
for version in "${VERSIONS[@]}"; do
    echo "emacs-${version#emacs-}"
done
#+end_src

* DONE Ollama Buddy - Now On MELPA! :emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250224154229-emacs--Ollama-Buddy-Now-On-MELPA
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-02-24 15:42>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250224154229-emacs--Ollama-Buddy-Now-On-MELPA.jpg
:END:

 #+begin_src sh
 ___ _ _      n _ n      ___       _   _ _ _
|   | | |__._|o(Y)o|__._| . |_ _ _| |_| | | |
| | | | | .  |     | .  | . | | | . | . |__ |
|___|_|_|__/_|_|_|_|__/_|___|___|___|___|___|
 #+end_src

https://github.com/captainflasmr/ollama-buddy

A friendly Emacs interface for interacting with Ollama models. This package provides a convenient way to integrate Ollama’s local LLM capabilities directly into your Emacs workflow with little or no configuration required.

Latest improvements:

- Chat buffer now more prompt based rather than ad-hoc using C-c C-c to send and C-c C-k to cancel
- Connection monitor now optional, ollama status visibility now maintained by strategic status checks simplifying setup.
- Can now change models from chat buffer using C-c C-m
- Updated intro message with ascii logo
- Suggested default "C-c o" for =ollama-buddy-menu=
- defcustom ollama-buddy-command-definitions now will work in the customization interface.
- The presets directory on github contains elisp files that can be evaluated to generate a role-based menu.
- Added to MELPA, install using the following:

#+begin_src elisp
(use-package ollama-buddy
  :bind ("C-c o" . ollama-buddy-menu))
#+end_src

- and to add initial model:

#+begin_src elisp
(use-package ollama-buddy
   :bind ("C-c o" . ollama-buddy-menu)
   :custom ollama-buddy-default-model "llama3.2:1b")
#+end_src

#+hugo: more 

---

Roadmap :

- DOING Multi-shot prompt to multiple LLMS to choose best answer

- DOING Customizable Role-Based Menu Preset Generation System

- DOING Distinguishing commands associated with LLMs using colours

For any more information just have a look at the github README!

* TODO Improving the Ollama Buddy Experience: Enhanced Prompt Handling and the Future

After spending some time using Ollama Buddy, I’ve decided to slightly break one of my original design principles!  

Relying solely on Emacs' select-region mechanism to send text to the chat buffer, especially when sending messages from within the chat buffer itself, started to feel a little clunky and cumbersome over time. What initially seemed like a clean and simple approach began to disrupt the flow of interaction, particularly during longer conversations.

My original reasons for enforcing a select-region-only mechanism were:  

1. Ensuring that users had full control over delineating text.  
2. Simplifying the implementation by using region boundaries to define the chat query.  
3. Staying as close as possible to Emacs' core interaction model (I'm not quite sure what I mean by this!)
4. Improving conversation flow, especially within the chat buffer.  
5. Avoiding the perceived complexity of implementing a dedicated command-line-style prompt.
6. I wanted to keep things simple and avoid implementing a full chat buffer mode, but doesn’t that mean I still need to set up a mode to link a local keymap?

However, after further use and testing, I now see the value in introducing a more natural and efficient way to interact within the chat buffer, and as it turned out, the prompt mechanism wasn't as difficult as i thought to implement and so far it is still fairly lightweight, around 600 lines.

I have simply defined a local keymap in the chat buffer and decided on =C-c C-c= to submit the requests based on the text entered after the prompt.  This now feels a little easier and more intuitive.

---

I do, however, have further plans for Ollama Buddy, here are some ideas:

** 1. Customizable Role-Based Menus Preset System

Since I’ve decoupled the menu system into a =defcustom= alist, users could theoretically define custom menu configurations within an =.el= file and evaluate them. This opens up the possibility of:  

- Having multiple files represent different menus.  
- Assigning different menus to different roles.  
- Using =completing-read= to select a role based on a chosen filename format with part of the filename containing the role name (maybe use a =denote= type of format?).  The elisp file will be evaluated which will produce a new menu based on the role selected.

Technically, this shouldn’t be too difficult, and the existing alist-based menu generation system already works well.

I might generate some of my own role preset menus for common tasks, or common roles, developer, writer e.t.c.  Also as I wanted to make Ollama Buddy a little on the fun side, why not some fun presets!!, the possibilities could be endless :)

** 2. Enhancing Menu Clarity: Distinguishing LLMs Effectively

Since each menu command can be linked to a specific LLM, it would be helpful to clearly display the model associated with each menu item. However, this raises a few design challenges:  

- Simply displaying model names alongside each menu item could clutter the interface, especially with long model names.  
- While the current auto-generated menus can accommodate long names, excessive width could make navigation cumbersome.  

 Possible Solutions:
 
- Assign a unique letter/number to each LLM and update the menu items accordingly.  
- Experiment with color coding:  
  - Hash LLM names to generate (theoretically) unique colors.  
  - Colorize menu items based on these hashes.  
  - Adjust contrast dynamically to ensure readability across different themes.  

I plan to explore the color-based approach, as it could provide a visually intuitive way to distinguish models without overcrowding the menu.  

* TODO Enhancing vc-mode in Emacs: Showing Git Branches and Tracked Files
** Displaying Git Branches in the Header Line

When working with Git repositories in Emacs, I often found myself wanting to know which branch I was on without running external commands. The standard =vc-dir= buffer (opened with =C-x v d=) shows your repo status but doesn't prominently display branch information.

Here's the solution I implemented:

#+begin_src elisp
(defun my/vc-dir-show-branches ()
  "Show Git branches in the header line of the *vc-dir* buffer."
  (when (and (boundp 'vc-dir-backend) (eq vc-dir-backend 'Git))
    (let* ((default-directory (if (boundp 'vc-dir-directory) 
                                  vc-dir-directory 
                                default-directory))
           (branches (replace-regexp-in-string "* " "*"
                                               (string-join
                                                (split-string
                                                 (shell-command-to-string "git branch") "\n" t "\\s-*")
                                                " "))))
      (setq-local header-line-format 
                  (propertize (concat "  " branches) 'face '(:inherit bold))))))

;; Add the function to vc-dir-mode-hook
(add-hook 'vc-dir-mode-hook #'my/vc-dir-show-branches)
#+end_src

This function does a few key things:

1. Checks if we're in a Git repository
2. Gets a list of branches using =git branch=
3. Formats the output, replacing "* " with "*" to indicate the current branch
4. Sets the header-line-format to display the branch list in bold

The result is a clean, always-visible list of branches at the top of your =vc-dir= buffer, with the active branch marked by an asterisk.

** Keeping Branch Display Updated

The above function works great, but there's a catch - when you switch branches, the header doesn't automatically update. Let's fix that with a bit of advice:

#+begin_src elisp
;; Define advice function for refreshing branches after switching
(defun my/after-vc-switch-branch (&rest _args)
  "Update branch display in all vc-dir buffers after switching branches."
  (dolist (buf (buffer-list))
    (with-current-buffer buf
      (when (derived-mode-p 'vc-dir-mode)
        (my/vc-dir-show-branches)))))

;; Add the advice to vc-switch-branch function
(advice-add 'vc-switch-branch :after #'my/after-vc-switch-branch)
#+end_src

This bit of code:

1. Creates an advice function that runs after branch switching
2. Loops through all open buffers
3. Updates the branch display in any that are =vc-dir= buffers

With this addition, the branch list updates automatically whenever you use =vc-switch-branch=, keeping your UI in sync with your actual Git state.

** Showing All Tracked Files

By default, =vc-dir= shows only files with changes. But sometimes I want to see *all* tracked files, especially in complex repositories. Here's my solution:

#+begin_src elisp
(defun my/vc-dir-show-tracked-files ()
  "Show all tracked files in the current vc-dir buffer."
  (interactive)
  (when (and (derived-mode-p 'vc-dir-mode)
             (eq vc-dir-backend 'Git))
    (let* ((default-directory (if (boundp 'vc-dir-directory) 
                                  vc-dir-directory 
                                default-directory))
           (files (split-string 
                   (shell-command-to-string "git ls-files")
                   "\n" t)))
      (vc-dir-refresh)
      (dolist (file files)
        (let ((full-path (expand-file-name file default-directory)))
          (vc-dir-show-fileentry file))))))

;; Bind it to a key in vc-dir-mode
(with-eval-after-load 'vc-dir
  (define-key vc-dir-mode-map (kbd "T") 'my/vc-dir-show-tracked-files))
#+end_src

This function:

1. Gets all tracked files using =git ls-files=
2. Refreshes the =vc-dir= buffer to start with a clean slate
3. Adds each tracked file to the display using =vc-dir-show-fileentry=
4. Binds the function to the "T" key in =vc-dir-mode=

Now with a simple keypress, I can toggle between seeing just modified files and seeing all tracked files.

* DONE Why I Switched from Magit to VC-Mode (and How It Works for Me) :vc_mode:emacs:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250221075427-emacs--Why-I-Switched-from-Magit-to-VC-Mode
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-02-21 07:54>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250221075427-emacs--Why-I-Switched-from-Magit-to-VC-Mode.jpg
:END:

I am currently using =vc-mode= for my source code configuration needs.  I wouldn’t call myself a die-hard =vc-mode= user, (at least not yet!). To earn that title, I think I would need years of experience with it and scoffing at this newfangled thing they call =magit=, while my muscle memory recoils at the thought of reading and interacting with a transient menu!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250221075427-emacs--Why-I-Switched-from-Magit-to-VC-Mode.jpg]]

If that were the case, I’d fully embrace the label of a die-hard holdout. But in reality, that just isn't true.

My version control history has been, well, complicated, or to put it another way, quite simple. It largely revolves around that ancient system known as Subversion (=svn=), and leveraging it through the good old command line. It wasn’t until the past couple of years that I even stepped into the Emacs version control ecosystem. So where to start? Naturally, I had heard a lot of praise for =magit=.

First question (and I suspect the usual question): how do you even pronounce it? A soft "g" like in *magic*? That sounds better, even if it doesn’t make much sense. Then again, given that I’d likely never discuss it with colleagues at work, pronunciation hardly matters.

Anyway, I happily "magited" for a year or so (ironically, I think I learned more about Git's command line through =magit= than I would have otherwise). I would have continued using it too, except I decided to make a mental paradigm shift regarding my use in Emacs in general.

I had reached a point where I think I knew enough Emacs Lisp to start replacing many external packages with custom functions. It was a personal challenge, an opportunity to deepen my understanding of =elisp= and tackle more advanced customization. What better way to learn than by replacing something like =ace-window=? As it turns out, most of these substitutions were fairly straightforward.

But =magit=? Now that was a tough one. Should I create my own transient menu?, or a more basic menu system? It’s Git, so that could quickly become a tangled mess of options. At the same time, I couldn’t ignore my need for Subversion support at work. =magit=, as great as it is, is Git-only (though =git svn= exists).

Wouldn’t it be nice if there was a version control system that seamlessly handled multiple backends?

Turns out (as we already know), Emacs has one built-in and that is =vc-mode=.

I’ve now been using =vc-mode= for about a year. I still appreciate =magit=, but for my current workflow, balancing Git for personal projects and Subversion at work, =vc-mode= gets the job done.

I'm not generally using Git in any advanced fashion anyway and if I do need to drop into the command line then I can just open up a terminal in emacs.

Yes =vc-mode= has its limitations, for example, why is creating a tag not part of the default keymap of =vc-dir=?, actually I think it is and I vaguely remember activating it through =vc-create-branch=, was it a universal argument?, I can't remember, but how about just doing things the old-fashioned way, =M-x vc-create-tag=?, that works fine for me.  Maybe in the not too near future I can yak shave that away anyway! :)

So far with =vc-mode= I’ve made some small improvements, which I shall share in future blog posts:

- Adding the ability to toggle tracked files on and off.  
- Displaying the current branch permanently in the =vc-dir= header line.  

And actually the =vc-mode= tweaks above were the original topic of this post, but I seem to have rambled on long enough...

* DONE Ollama Buddy - Local LLM Integration for Emacs :ollama:llm:github:emacs:ai:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250207092636-emacs--Ollama-Buddy-Local-LLM-Integration-for-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-02-07 09:40>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250207092636-emacs--Ollama-Buddy-Local-LLM-Integration-for-Emacs.jpg
:END:

I have been playing around with local LLMs recently through ollama and decided to create the basis for an Emacs package to focus on interfacing to ollama specifically. My idea here is to implement something very minimal and as light-weight as possible and that could be run out-of-the-ollamabox with no configuration (obviously the ollama server just needs to be running). I have a deeper dive into my overall design thoughts and decisions in the github README and there are some simple demos:"hello"

https://github.com/captainflasmr/ollama-buddy

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250207092636-emacs--Ollama-Buddy-Local-LLM-Integration-for-Emacs.jpg]]

---

** Overview

A friendly Emacs interface for interacting with Ollama models. This package provides a convenient way to integrate Ollama's local LLM capabilities directly into your Emacs workflow with little or no configuration required.

The name is just something a little bit fun and it seems to always remind me of the "bathroom buddy" from the film Gremlins (although hopefully this will work better than that seemed to!)

** Screenshots / Demos

Note that all the demos are in real time.

*Switching to a better model*

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/ollama-buddy/img/ollama-buddy-screen-recording_001.gif]]

*More conversational*

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/ollama-buddy/img/ollama-buddy-screen-recording_002.gif]]

*Describing code with different models*

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/ollama-buddy/img/ollama-buddy-screen-recording_003.gif]]

*Describing code with a more advanced model*

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/ollama-buddy/img/ollama-buddy-screen-recording_004.gif]]

*The Menu*

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/ollama-buddy/img/ollama-buddy-screenshot_001.png]]

** Summary of my design ethos

- *Focused Design Philosophy*
  
  - Dedicated solely to Ollama integration (unlike general-purpose LLM packages)
  - Intentionally lightweight and minimal setup
  - Particularly suitable for air-gapped systems
  - Avoids complex backends and payload configurations

- *Interface Design Choices*
  
  - Flexible, customizable menu through defcustom
  - Easy-to-extend command system via simple alist modifications
  - Region-based interaction model across all buffers

- *Buffer Implementation*
  
  - Simple, editable chat buffer approach
  - Avoids complex modes or bespoke functionality
  - Trying to leverage standard Emacs text editing capabilities

- *User Experience*
  
  - "AI assistant" style welcome interface
  - Zero-config startup possible
  - Built-in status monitoring and model listing
  - Simple tutorial-style introduction

- *Technical Simplicity*
  
  - REST-based Ollama
  - Quickly switch between small local LLMs
  - Backwards compatibility with older Emacs versions
  - Minimal dependencies
  - Straightforward configuration options

** Design ethos expanded / why create this package?

The Ollama Emacs package ecosystem is still emerging. Although there are some great implementations available, they tend to be LLM jack-of-all-trades, catering to various types of LLM integrations, including, of course, the major online offerings.

Recently, I have been experimenting with a local solution using =ollama=. While using =ollama= through the terminal interface with =readline= naturally leans toward Emacs keybindings, there are a few limitations:

- Copy and paste do not use Emacs keybindings like readline navigation. This is due to the way key codes work in terminals, meaning that copying and pasting into Emacs would require using the mouse!
- Searching through a terminal with something like Emacs =isearch= can vary depending on the terminal.
- Workflow disruption occur when copying and pasting between Emacs and =ollama=.
- There is no easy way to save a session.
- It is not using Emacs!

I guess you can see where this is going. The question is: how do I integrate a basic query-response mechanism to =ollama= into Emacs? This is where existing LLM Emacs packages come in, however, I have always found them to be more geared towards online models with some packages offering experimental implementations of =ollama= integration. In my case, I often work on an air-gapped system where downloading or transferring packages is not straightforward. In such an environment, my only option for LLM interaction is =ollama= anyway. Given the limitations mentioned earlier of interacting with =ollama= through a terminal, why not create a dedicated =ollama= Emacs package that is very simple to set up, very lightweight and leverages Emacs's editing capabilities to provide a basic query response interface to =ollama=?

I have found that setting up =ollama= within the current crop of LLM Emacs packages can be quite involved. I often struggle with the setup, I get there in the end, but it feels like there's always a long list of payloads, backends, etc., to configure. But what if I just want to integrate Emacs with =ollama=? It has a RESTful interface, so could I create a package with minimal setup, allowing users to define a default model in their init file (or select one each time if they prefer)?  It could also query the current set of loaded models through the =ollama= interface and provide a =completing-read= type of model selection, with potentially no model configuration needed!

Beyond just being lightweight and easy to configure, I also have another idea: a flexible menu system. For a while, I have been using a simple menu-based interface inspired by transient menus. However, I have chosen not to use =transient= because I want this package to be compatible with older Emacs versions. Additionally, I haven’t found a compelling use case for a complex transient menu and I prefer a simple, opaque top level menu.

To achieve this, I have decided to create a flexible =defcustom= menu system. Initially, it will be configured for some common actions, but users can easily modify it through the Emacs customization interface by updating a simple alist.

For example, to refactor code through an LLM, a prepended text string of something like "Refactor the following code:" is usually applied. To proofread text, "Proofread the following:" could be prepended to the body of the query. So, why not create a flexible menu where users can easily add their own commands? For instance, if someone wanted a command to uppercase some text (even though Emacs can already do this), they could simply add the following entry to the =ollama-buddy-menu-items= alist:

#+begin_src elisp
(?u . ("Upcase" 
       (lambda () (ollama-buddy--send "convert the following to uppercase:"))))
#+end_src

Then the menu would present a menu item "Upcase" with a "u" selection, upcasing the selected region.  You could go nuts with this, and in order to double down on the autogeneration of a menu concept, I have provided a =defcustom= =ollama-buddy-menu-columns= variable so you can flatten out your auto-generated menu as much as you like!

This is getting rambly, but another key design consideration is how prompts should be handled and in fact how do I go about sending text from within Emacs?. Many implementations rely on a chat buffer as the single focal point, which seems natural to me, so I will follow a similar approach.

I've seen different ways of defining a prompt submission mechanism, some using <RET>, others using a dedicated keybinding like C-c <RET>, so, how should I define my prompting mechanism? I have a feeling this could get complicated, so lets use the KISS principle, also, how should text be sent from within Emacs buffers? My solution? simply mark the text and send it, not just from any Emacs buffer, but also within the chat window. It may seem slightly awkward at first (especially in the chat buffer, where you will have to create your prompt and then mark it), but it provides a clear delineation of text and ensures a consistent interface across Emacs. For example, using M-h to mark an element requires minimal effort and greatly simplifies the package implementation. This approach also allows users to use the **scratch** buffer for sending requests if so desired!

Many current implementations create a chat buffer with modes for local keybindings and other features. I have decided not to do this and instead, I will provide a simple editable buffer (ASCII text only) where all =ollama= interactions will reside. Users will be able to do anything in that buffer; there will be no bespoke Ollama/LLM functionality involved. It will simply be based on a =special= buffer and to save a session?, just use =save-buffer= to write it to a file, Emacs to the rescue again!

Regarding the minimal setup philosophy of this package, I also want to include a fun AI assistant-style experience. Nothing complicated, just a bit of logic to display welcome text, show the current =ollama= status, and list available models. The idea is that users should be able to jump in immediately. If they know how to install/start =ollama=, they can install the package without any configuration, run `M-x ollama-buddy-menu`, and open the chat. At that point, the "AI assistant" will display the current =ollama= status and provide a simple tutorial to help them get started.

The backend?, well I decided simply to use =curl= to stimulate the =ollama= RESTful API, so you will need =curl= to be installed.

I have other thoughts regarding the use of local LLMs versus online AI behemoths. The more I use =ollama= with Emacs through this package, the more I realize the potential of smaller, local LLMs. This package allows for quick switching between these models while maintaining a decent level of performance on a regular home computer. I could, for instance, load up =qwen-coder= for code-related queries (I have found the 7B Q4/5 versions to work particularly well) and switch to a more general model for other queries, such as =llama= or even =deepseek-r1=.

Phew! That turned into quite a ramble, maybe I should run this text through =ollama-buddy= for proofreading! :)

** AI assistant

A simple text information screen will be presented on the first opening of the chat, or when requested through the menu system:

#+begin_src sh
====================  n_____n  ====================
==================== | o Y o | ====================

    ╭──────────────────────────────────────╮
    │              Welcome to               │
    │             OLLAMA BUDDY              │
    │       Your Friendly AI Assistant      │
    ╰──────────────────────────────────────╯

    Hi there!

    ollama RUNNING

    I'm here to help you with:

    - Code refactoring and analysis
    - Writing clear commit messages
    - Proofreading and text improvements
    - And much more!

    Quick Start/Tips:

    - Try typing a prompt in this buffer
    - Select/mark all prompt text (select region)
    - M-x ollama-buddy-menu
    - Select menu item
    - Now wait for ollama to do its magic!
    - You can switch models anytime with [m]
    - Use [x] to cancel a running request
    - You can send to this chat from any buffer

-------------------- | @ Y @ | --------------------
#+end_src

** Features

- Interactive menu-driven interface
- Dedicated chat buffer with streaming responses
- Easy model switching
- Quick actions for common tasks:
  - Code refactoring
  - Git commit message generation
  - Code description
  - Text proofreading
  - Text summarization
- Cute ASCII art separators for chat messages
- Region-based interaction with any buffer

** Whats New
*** <2025-02-07>

Added query finished message.

*** <2025-02-06>

- Initial release
- Basic chat functionality
- Menu-driven interface
- Region-based interactions
- Model switching support

** Prerequisites

- [[https://ollama.ai/][Ollama]] installed and running locally
- Emacs 27.1 or later
- =curl= command-line tool

** Installation
*** Manual Installation

Clone this repository:

#+BEGIN_SRC shell
git clone https://github.com/captainflasmr/ollama-buddy.git
#+END_SRC

Add to your =init.el=:

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "path/to/ollama-buddy")
(require 'ollama-buddy)
#+END_SRC

*** MELPA (Coming Soon)

#+BEGIN_SRC emacs-lisp
(use-package ollama-buddy
  :ensure t
  :bind ("C-c l" . ollama-buddy-menu))
#+END_SRC

** Usage

1. Start your Ollama server locally
2. Use =M-x ollama-buddy-menu= or the default keybinding =C-c l= to open the menu
3. Select your preferred model using the [m] option
4. Select text in any buffer
5. Choose an action from the menu:

| Key | Action             | Description                                 |
|-----+--------------------+---------------------------------------------|
| o   | Open chat buffer   | Opens the main chat interface               |
| m   | Swap model         | Switch between available Ollama models      |
| h   | Help assistant     | Display help message                        |
| l   | Send region        | Send selected text directly to model        |
| r   | Refactor code      | Get code refactoring suggestions            |
| g   | Git commit message | Generate commit message for changes         |
| d   | Describe code      | Get code explanation                        |
| p   | Proofread text     | Check text for improvements                 |
| z   | Make concise       | Reduce wordiness while preserving meaning   |
| c   | Custom Prompt      | Enter bespoke prompt through the minibuffer |
| x   | Kill request       | Cancel current Ollama request               |
| q   | Quit               | Exit the menu                               |

** Key Bindings

| Key     | Description            |
|---------+------------------------|
| =C-c l= | Open ollama-buddy menu |

** Customization

#+begin_src emacs-lisp :results table :colnames '("Custom variable" "Description") :exports results
  (let ((rows))
    (mapatoms
     (lambda (symbol)
       (when (and (string-match "^ollama-buddy-"
                                (symbol-name symbol))
                  (not (string-match "--" (symbol-name symbol)))
                  (or (custom-variable-p symbol)
                      (boundp symbol)))
         (push `(,symbol
                 ,(car
                   (split-string
                    (or (get (indirect-variable symbol)
                             'variable-documentation)
                        (get symbol 'variable-documentation)
                        "")
                    "\n")))
               rows))))
    rows)
#+end_src

#+RESULTS:
| Custom variable            | Description                                            |
|----------------------------+--------------------------------------------------------|
| ollama-buddy-menu-columns  | Number of columns to display in the Ollama Buddy menu. |
| ollama-buddy-menu-items    | Menu items definition for Ollama Buddy.                |
| ollama-buddy-current-model | Default Ollama model to use.                           |
| ollama-buddy-separator-1   | Separator used for Ollama LLM output, variant 1.       |
| ollama-buddy-separator-2   | Separator used for Ollama LLM output, variant 2.       |

Customize the package to the default startup using:

#+begin_src elisp
(setq ollama-buddy-current-model "qwen-4q:latest")

;; Change number of menu columns
(setq ollama-buddy-menu-columns 4)

;; Customize separators
(setq ollama-buddy-separator-1 "Your custom separator here")
(setq ollama-buddy-separator-2 "Another custom separator")
#+end_src

Available customization options:

** Contributing

Contributions are welcome! Please:
1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Open a pull request

** License

[[https://opensource.org/licenses/MIT][MIT License]]

** Acknowledgments

- [[https://ollama.ai/][Ollama]] for making local LLM inference accessible
- Emacs community for continuous inspiration

** Issues

Report issues on the [[https://github.com/captainflasmr/ollama-buddy/issues][GitHub Issues page]]

** Alternative LLM based packages

To the best of my knowledge, there are currently a few Emacs packages related to Ollama, though the ecosystem is still relatively young:

1. *llm.el* (by Jacob Hacker)
   - A more general LLM interface package that supports Ollama as one of its backends
   - GitHub: https://github.com/ahyatt/llm
   - Provides a more abstracted approach to interacting with language models
   - Supports multiple backends including Ollama, OpenAI, and others

2. *gptel* (by Karthik Chikmagalur)
   - While primarily designed for ChatGPT and other online services, it has experimental Ollama support
   - GitHub: https://github.com/karthink/gptel
   - Offers a more integrated chat buffer experience
   - Has some basic Ollama integration, though it's not the primary focus

3. *chatgpt-shell* (by xenodium)
   - Primarily designed for ChatGPT, but has some exploration of local model support
   - GitHub: https://github.com/xenodium/chatgpt-shell
   - Not specifically Ollama-focused, but interesting for comparison

4. *ellama*

   - TODO

** Alternative package comparison

Let's compare ollama-buddy to the existing solutions:

1. *llm.el*
   
   - *Pros*:
     
     - Provides a generic LLM interface
     - Supports multiple backends
     - More abstracted and potentially more extensible
       
   - *Cons*:
     
     - Less Ollama-specific
     - More complex configuration
     - Might have overhead from supporting multiple backends

   =ollama-buddy= is more:
   
   - Directly focused on Ollama
   - Lightweight and Ollama-native
   - Provides a more interactive, menu-driven approach
   - Simpler to set up for Ollama specifically

2. *gptel*
   
   - *Pros*:
     
     - Sophisticated chat buffer interface
     - Active development
     - Good overall UX
       
   - *Cons*:
     
     - Primarily designed for online services
     - Ollama support is experimental
     - More complex architecture

   =ollama-buddy= differentiates by:
   
   - Being purpose-built for Ollama
   - Offering a more flexible, function-oriented approach
   - Providing a quick, lightweight interaction model
   - Having a minimal, focused design

3. *chatgpt-shell*
   
   - *Pros*:
     
     - Mature shell-based interaction model
     - Rich interaction capabilities
       
   - *Cons*:
     
     - Not truly Ollama-native
     - Primarily focused on online services
     - More complex setup

   =ollama-buddy= stands out by:
   
   - Being specifically designed for Ollama
   - Offering a simpler, more direct interaction model
   - Providing a quick menu-based interface
   - Having minimal dependencies

4. *ellama*

   - TODO

* DONE Copying completion candidate to the clipboard :embark:emacs:elisp:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250130074049-emacs--Copy-icomplete-candidate-to-clipboard
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-01-30 07:40>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250130074049-emacs--Copy-icomplete-candidate-to-clipboard.jpg
:END:

In my continuing quest to replace all my external use packages with my own elisp versions so I can still follow my current workflow on an air-gapped system, I would like to replace a single function I use often from =embark=

=embark= allows an action in a certain context, and there are a lot of actions to choose from, but I found I was generally using very few, so to remove my reliance on =embark= I think I can implement these actions myself.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20250130074049-emacs--Copy-icomplete-candidate-to-clipboard.jpg]]

The main one is to copy the current completion candidate.  For example, I might be searching for a function name, so =describe-function= function for example, ha!, I just did it!, using =describe-function= to select =describe-function= and then copying to the clipboard to then paste in to this blog article!

Well that is it, so lets code it up:

#+begin_src elisp
(defun my-icomplete-copy-candidate ()
  "Copy the current Icomplete candidate to the kill ring."
  (interactive)
  (let ((candidate (car completion-all-sorted-completions)))
    (when candidate
      (kill-new (substring-no-properties candidate))
      (let ((copied-text candidate))
        (run-with-timer 0 nil (lambda () 
          (message "Copied: %s" copied-text)))
        (abort-recursive-edit)))))
        
(global-set-key (kbd "C-c ,") 'find-file-at-point)
(define-key minibuffer-local-completion-map (kbd "C-c ,") 'my-icomplete-copy-candidate)
#+end_src

Note of course that I use the built-in =fido-mode= and therefore =icomplete= so there might be possibly a different implementation if you were using something like vertico for example.

Also as a bonus, note that I have added another common =embark= action and that is to navigate to a file at point. Fortunately Emacs has this function built-in so I again bound to my former standard =embark= activation key.

* DONE Creating a small local elisp rainbow-mode solution :emacs_core:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241209081021-emacs--Emacs-core-rainbow-mode
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-01-25 07:50>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241209081021-emacs--Emacs-core-rainbow-mode.jpg
:END:

In this post, as part of my ongoing mission to replace all (or as many as possible) external packages with pure elisp, I’ll demonstrate how to implement a lightweight alternative to the popular =rainbow-mode= package, which highlights hex colour codes in all their vibrant glory.  I use this quite often, especially when "ricing" my tiling window setup.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241209081021-emacs--Emacs-core-rainbow-mode.jpg]]

Instead of relying on =rainbow-mode=, lets create a custom Emacs function to colourize hex values in the buffer, along with another function to clear these highlights. We'll also bind this functionality to modes like =prog-mode=, =org-mode=, and =conf-space-mode=.

---

Hexadecimal colour codes (like =#ff0000= for red, =#00ff00= for green, etc.) often appear in programming, configuration, or document files. Visualizing these colours directly within your buffer makes working with them much easier.

Here's how you can create a simple function to overlay these colours in Emacs:

The following function highlights any 3 or 6 character hex colour codes it finds in the current buffer (e.g., =#ff0000=, =#33aaff=, =#fff=). It uses Emacs overlays to render the colour as the background of the matched text.

#+begin_src elisp
(defun my/rainbow-mode ()
  "Overlay colors represented as hex values in the current buffer."
  (interactive)
  (remove-overlays (point-min) (point-max))
  (let ((hex-color-regex "#[0-9a-fA-F]\\{3,6\\}"))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward hex-color-regex nil t)
        (let* ((color (match-string 0))
               (overlay (make-overlay (match-beginning 0) (match-end 0))))
          (if (string-greaterp color "#888888")
              (overlay-put overlay 'face `(:background ,color :foreground "black"))
            (overlay-put overlay 'face `(:background ,color :foreground "white"))))))))
#+end_src

As an additional note, I have added a little logic regarding generating a contrasting foreground colour to help the hex text value remain prominent.

Sometimes you may want to remove all colour overlays from the current buffer. The following function clears the overlays applied by =my/rainbow-mode=:

#+begin_src elisp
(defun my/rainbow-mode-clear ()
  "Remove all hex color overlays in the current buffer."
  (interactive)
  (remove-overlays (point-min) (point-max)))
#+end_src

Now that we have created =my/rainbow-mode=, let’s make it automatically activate in relevant modes like =prog-mode=, =org-mode=, and =conf-space-mode=. You can achieve this by adding hooks to these modes:

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'my/rainbow-mode)
(add-hook 'org-mode-hook #'my/rainbow-mode)
(add-hook 'conf-space-mode-hook #'my/rainbow-mode)
#+end_src

By doing this, whenever you open a buffer in a programming file, Org file, or certain configuration files, =my/rainbow-mode= will automatically highlight any hex colour codes present in the file.

---

And there we go!, by defining =my/rainbow-mode=, you can enjoy the benefits of colour-highlighting hex values in Emacs while staying true to a minimalist, package-free configuration!

* DONE Streamlining Navigation in Org-Mode using an adapted org-goto :org_goto:org:imenu:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241228131958-emacs--Streamlining-Navigation-in-Org-Mode
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-01-18 11:08>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241228131958-emacs--Streamlining-Navigation-in-Org-Mode.jpg
:END:

Navigating through lengthy org files can sometimes feel cumbersome. To address this I have tweaked =org-goto= to be a little more usable through the minibuffer completion system to jump to any org heading.

I have been aware of the =org-goto= command for a while now, which technically, allows for the efficient navigation through an org file.  Every now and then I give it a go, but it just feels clunky and some of the keybindings don't quite feel intuitively Emacs for some reason.

Now my org files are getting more elaborate, I would like a better way to navigate and especially through the hierarchy of headings.

What about =org-imenu-depth= I hear you say!  Well as far as I can tell, this allows stepping through to a defined subheading level but while going through multiple menu/hierarchical selection steps.  For efficiency, I would like a way to flatten the subheadings for a one-shot completion selection method.  This is where =org-goto= can actually be adapted to satisfy this need, and I think leverages the org refile menu system.

#+hugo: more

To achieve this, some variables will require changing, firstly:

#+begin_src emacs-lisp
(setq org-goto-interface 'outline-path-completionp)
#+end_src

The =org-goto-interface= variable defines the interface you use to navigate when calling =org-goto=. By default, org goto uses a mixed interface with direct completion and an alternative outline-based navigation using buffers. I prefer the *outline-path-completionp* setting, which provides a breadcrumb-like structure for easier navigation through the minibuffer completion system.

By default, Org mode’s outline-path interface works in steps, which means you select one heading level at a time. I find this behaviour a bit clunky, especially for larger files. Fortunately, you can disable this step-by-step behaviour by setting =org-outline-path-complete-in-steps= to =nil= which flattens the presented org goto heading list when activated so you can see the full list of headings/subheadings in a single step and therefore be able to navigate directly to your desired location.

#+begin_src emacs-lisp
(setq org-outline-path-complete-in-steps nil)
#+end_src

---

Lets demonstrate how this now works with an example.

Given the following org:

#+begin_src org
,* Heading 1
...
,* Heading 2
...
,** Subheading 2.1
...
,* Subheading 3
...
,** Subheading 3.1
...
,*** Subheading 3.1.1
#+end_src

imenu would just allow navigation to leaf nodes and not the higher subdirectories.

(Note : I use =fido-mode=/=icomplete=):

Here is the minibuffer menu presented when =imenu= is activated by default:

#+begin_src org
(Heading.1 | Heading.2 | *Rescan* | Subheading.3)
#+end_src

For example, I can navigate to Heading 1 but what about Heading 2 or Heading 3?, when selecting these headings that have subheadings it will take me into further leaf node menus for selection.

This is where the setup above for =org-goto= comes in handy as it now presents the following:

#+begin_src org
{Heading 2/ | Heading 2/Subheading 2.1/ | Heading 1/ | Subheading 3/ | Subheading 3/Subheading 3.1/ | Subheading 3/Subheading 3.1/Subheading 3.1.1/}
#+end_src

Where of course the minibuffer completion system can complete to not just the leaf nodes but also the higher level subheadings, allowing navigation to any org heading!

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241228131958-emacs--Streamlining-Navigation-in-Org-Mode.jpg]]

* DONE Ediff Comparing Regions :emacs:ediff:2025:
:PROPERTIES:
:EXPORT_FILE_NAME: 20250108140933-emacs--Ediff-Comparing-Regions
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-01-08 15:30>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20250108140933-emacs--Ediff-Comparing-Regions_001.jpg
:END:

=ediff= is one of my favourite tools in Emacs and I have recently found myself not only using =ediff-buffers= and =vc-ediff= often but also now having the need to compare two regions.

For example, when developing new Elisp functions, I generally modify the bottom of my tangled init file and then evaluate/edit as necessary, or sometimes through the /scratch/ buffer.

However, for something more complex, for example, at the moment, I am trying to generate an RSS feed from my Hugo-based blog's Org file through =org-publish=. In this case, I prefer creating a separate directory where I can experiment with example files, generated files, and temporarily manage everything under version control.

At the end of development, I could simply paste my function(s) back into my main configuration, however, as a software engineer, I am accustomed to using merging tools, so what better way to handle this than with =ediff=

Given my development functions and my init file, I can't compare entire files to copy/merge the changes across, and VC in this case is not helpful. So, how do I compare two regions? In fact, is it even possible in Emacs?

Well, yes, yes it is! (of course)

#+begin_quote
ediff-regions-linewise

Run Ediff on a pair of regions in specified buffers.
BUFFER-A and BUFFER-B are the buffers to be compared.
Regions (i.e., point and mark) can be set in advance or marked interactively.
Each region is enlarged to contain full lines.
#+end_quote

and my keybinding is:

#+begin_src elisp
(global-set-key (kbd "M-s +") #'ediff-regions-linewise)
#+end_src

Note: at the moment I only ever run =ediff-regions-linewise= but the documentation recommends using =ediff-regions-wordwise= for smaller regions.  For this example I shall be using =ediff-regions-linewise= only.

Documentation for =ediff-regions-wordwise=

#+begin_quote
The ediff-regions-linewise function is effective for large regions, over 100-200 lines.

For small regions, use ‘ediff-regions-wordwise’.
#+end_quote
  
Initially, I prefer to have a horizontal split with the two files containing the regions I would like to compare, and then place the point in the left-hand window.

When =ediff-regions-linewise= is then activated, that is the order the regions are set up, from left to right.

Note: According to the documentation, it seems possible to set up the two regions using marks before the call, after which you will go directly into an ediff comparison rather than the interactive region described below.  However, I have not yet been able to get the region comparison to work this way.

Ok, lets do a region comparison!

-----
  
   1. *Run*

      - Open both buffers side-by-side, Buffer A : Buffer B
      - Run =M-x ediff-regions-linewise=
      - Select each side-by-side buffer, by <RET>, <RET>

   2. *Mark Buffer A's Region*

      - When prompted for "Region A:", Buffer A will be automatically switched to
      - Now mark the region for comparison
      - Once the region is marked, hit C-M-c

   3. *Mark Buffer B's Region*

      - Similarly, when prompted for "Region B:", Buffer B will be automatically switched to
      - Now mark the region for comparison
      - Once the region is marked, hit C-M-c

      Now the usual familiar ediff comparison begins.

      -----

      Here is a little visual example set up with a simple paragraph difference:

      #+attr_org: :width 300px
      #+attr_html: :width 100%
      [[file:static/emacs/20250108140933-emacs--Ediff-Comparing-Regions_001.jpg]]

      In this case Buffer A and Buffer B are set up side-by-side and with the process for a region comparison as described above on *2. Mark Buffer A's Region* that I have deliberately made slightly different for Buffer B.

      Here is the comparison result:

      #+attr_org: :width 300px
      #+attr_html: :width 100%
      [[file:static/emacs/20250108140933-emacs--Ediff-Comparing-Regions_002.jpg]]

   -----

   I have something that seems to work for me at the moment, but I would really like to fully understand the difference between a linewise and a wordwise comparison. I understand that wordwise comparison could be computationally expensive on large blocks, but what benefits do I gain from using a smaller wordwise comparison compared to a linewise comparison?

   Also, although the interactive region selection works well, I really want to figure out how to set up the regions initially.

   If anyone knows answers to these questions, just drop in a comment!

* DONE Emacs Quick Window Pt 4 - Further Tweaks :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241231120205-emacs--Enhancing-Window-Navigation-my-quick-window-jump
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2025-01-03 Fri 20:20>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241213115239-emacs--Emacs-core-window-jumping-between-two-windows.jpg
:END:

Previously, =my/quick-window-jump= was geared mostly toward managing two or more windows. The behaviour was straightforward:
- If two windows were open, the function would directly jump to the other window.
- For more than two windows, a key selection interface would allow you to pick a window to switch to.

However, the function didn’t handle a single-window scenario intelligently. A horizontal split from a single window is something I do very frequently, by frequently, I mean at least every minute! This split is currently bound to its own keybinding, but couldn't my =ace-window= defun clone do this? For example, I find that the transition from a single window to a split never happens vertically for me, so why not make =my/quick-window-jump= perform a horizontal split from a single window and then move the point to that window?

In addition, it is very rare for me to vertically split into more than two columns. I could probably drop my current horizontal split keybinding now. If I do require another horizontal split, the default =C-x 3= is already bound to muscle memory.

Lets take this function to the next level of convenience, with a very simple change, simply an extra (length window-list) and the relevant logic.

#+hugo: more

Below is the updated implementation of =my/quick-window-jump=:

#+begin_src elisp
(defun my/quick-window-jump ()
  "Jump to a window by typing its assigned character label.
If there is only a single window, split it horizontally.
If there are only two windows, jump directly to the other window."
  (interactive)
  (let* ((window-list (window-list nil 'no-mini)))
    (cond
     ;; If there is only a single window, split it horizontally.
     ((= (length window-list) 1)
      (split-window-horizontally)
      (other-window 1)) ;; Move focus to the new window immediately after splitting.
     ;; If there are only two windows, switch to the other one directly.
     ((= (length window-list) 2)
      (select-window (other-window-for-scrolling)))
     ;; Otherwise, present the key selection interface.
     (t
      (let* ((my/quick-window-overlays nil)
             (sorted-windows (sort window-list
                                   (lambda (w1 w2)
                                     (let ((edges1 (window-edges w1))
                                           (edges2 (window-edges w2)))
                                       (or (< (car edges1) (car edges2))
                                           (and (= (car edges1) (car edges2))
                                                (< (cadr edges1) (cadr edges2))))))))
             (window-keys (seq-take '("j" "k" "l" ";" "a" "s" "d" "f")
                                    (length sorted-windows)))
             (window-map (cl-pairlis window-keys sorted-windows)))
        (setq my/quick-window-overlays
              (mapcar (lambda (entry)
                        (let* ((key (car entry))
                               (window (cdr entry))
                               (start (window-start window))
                               (overlay (make-overlay start start (window-buffer window))))
                          (overlay-put overlay 'after-string 
                                       (propertize (format "[%s]" key)
                                                   'face '(:foreground "white" :background "blue" :weight bold)))
                          (overlay-put overlay 'window window)
                          overlay))
                      window-map))
        (let ((key (read-key (format "Select window [%s]: " (string-join window-keys ", ")))))
          (mapc #'delete-overlay my/quick-window-overlays)
          (setq my/quick-window-overlays nil)
          (when-let ((selected-window (cdr (assoc (char-to-string key) window-map))))
            (select-window selected-window))))))))
#+end_src

The updated =my/quick-window-jump= function now adapts to any window configuration dynamically. Here is now an overview on how it now works:

1. *Single Window? Split It Automatically*
   - If there’s only one window open, the function splits it horizontally and shifts focus to the new window.

2. *Two Windows? Still Jump Directly*
   - The behaviour for two windows remains unchanged. It efficiently switches focus to the other window directly without inefficiencies.

3. *More Than Two Windows? Key Selection Interface*
   - When multiple windows are open, the function presents the familiar key selection interface, allowing you to jump exactly where you intend.

Will there be more tweaks?, not sure, but this is the advantage of now creating my own defun for this piece of functionality!

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241213115239-emacs--Emacs-core-window-jumping-between-two-windows.jpg]]

* DONE Exploring Static Website Publishing with Org Publish :emacs:2024:org:org_publish:elisp:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241226125955-emacs--Exploring-Emacs-Based-Static-Website-Publishing-with-Org-Publish
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-12-27 10:10>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241226125955-emacs--Exploring-Emacs-Based-Static-Website-Publishing-with-Org-Publish.jpg
:END:

As someone who enjoys using Emacs for almost everything, I recently began exploring an alternative Emacs-native method for publishing static websites.

Currently, I use [ox-hugo](https://github.com/kaushalmodi/ox-hugo) to build a static site from a single Org file, and it works beautifully for exporting content to Hugo-compatible Markdown. However, I wanted to create a backup web generation system entirely within Emacs that doesn't rely on external tools like Hugo and might fit into my overarching *Emacs Enhancements* project concept.

My *Emacs Enhancements* project focuses on replacing significant external packages that I commonly use with a collection of simple Elisp functions and built-in functionality. This approach is ideal for situations where I run Emacs on an air-gapped system or even on Windows, where I have found package management to be somewhat unreliable. You can check out my progress on [GitHub](https://github.com/captainflasmr/Emacs-enhanced).

#+hugo: more

So, how do I replace Hugo/ox-hugo? Well, I finally got around to experimenting with the powerful =org-publish= system. I say "finally" because I’ve had my eye on this for quite a while, but at no point in the past did I have the time to invest in learning it. Now, during the festive period, I have my laptop and potentially some downtime so maybe now is the time!

This post documents my work in progress journey of setting up an Emacs-based publishing workflow using =org-publish= to export to HTML.

** *Why Org-Publish over ox-hugo?*

While ox-hugo provides extensive functionality to structure and export content seamlessly for Hugo-based static sites, I found these motivations to explore org-publish:

1. *Native Emacs Solution*: Keeping everything within the Emacs ecosystem.
2. *Backup*: Ensures I have a non-Hugo-dependent HTML web site generation backup.
3. *Customizability*: Leverage fine-grained control over publishing directory structures and formats from within Emacs elisp.

That said, this isn't a replacement for ox-hugo, but an experiment to see how efficient a pure Emacs approach can be.

** *Project Setup Overview*

1. *Using a Monolithic Org File*: My starting file, =emacs--all.org=, contains all blog posts under separate headings. 
2. *Split the Org File into Multiple Smaller Files*: For compatibility with =org-publish=, I wrote a utility to split the file. This allows each blog post to be processed independently.
3. *Use =org-publish-project-alist=*: Define a multi-step pipeline for splitting, exporting HTML, and processing images.

Here’s how I tackled each step in detail:

** *Step 1: Splitting the Monolithic Org File*

The first hurdle was enabling =org-publish= to work with my single Org file. Since =org-publish= usually expects individual files to process, I created a custom function, =my-org-publish-split-headings=. This function splits the top-level headings marked as =DONE= into separate files, each prefixed with the date from a property (e.g., =:EXPORT_HUGO_LASTMOD:=).

*** Splitting File Logic

Hopefully, this defun is commented well enough to be almost self-documenting!

#+begin_src emacs-lisp
(defun my-org-publish-split-headings (plist filename pub-dir)
  "Split an Org file into separate files, each corresponding to a top-level heading
that is marked as DONE.

Each file name is prefixed with the date in YYYYMMDD format extracted from the
:EXPORT_HUGO_LASTMOD: property. PLIST is the property list for the publishing
process, FILENAME is the input Org file, and PUB-DIR is the publishing directory."
  (with-temp-buffer
    (insert-file-contents filename) ;; Load the content of the current Org file
    (goto-char (point-min))
    (let ((heading-level 1) ;; Level of the top-level heading to split by
          prev-start heading-title sanitized-title output-file lastmod-date)
      ;; Iterate over all top-level headings
      (while (re-search-forward (format "^\\*\\{%d\\} \\(?:\\([[:upper:]]+\\) \\)?\\(.*\\)" heading-level) nil t)
        (let ((todo-keyword (match-string 1)) ;; Extract the TODO keyword (if it exists)
              (heading-title (match-string 2))) ;; Extract the title of the heading
          ;; Process only headings marked as DONE
          (when (and todo-keyword (string-equal todo-keyword "DONE"))
            (setq prev-start (match-beginning 0)) ;; Start of the current heading
            (setq sanitized-title (when heading-title
                                    (replace-regexp-in-string "[^a-zA-Z0-9_-]" "_" heading-title))) ;; Sanitize title
            ;; Extract the :EXPORT_HUGO_LASTMOD: property for the current section
            (save-excursion
              (when (re-search-forward ":EXPORT_HUGO_LASTMOD: +\\(<.+>\\)" (save-excursion (re-search-forward "^\\* " nil t) (point)) t)
                (let* ((raw-lastmod (match-string 1)) ;; Extract the timestamp string (e.g., "<2024-12-08 08:37>")
                       (date-elements (when (string-match "<\\([0-9]+\\)-\\([0-9]+\\)-\\([0-9]+\\)" raw-lastmod)
                                        (list (match-string 1 raw-lastmod) ;; Year
                                              (match-string 2 raw-lastmod) ;; Month
                                              (match-string 3 raw-lastmod))))) ;; Day
                  (setq lastmod-date (when date-elements
                                       (apply #'concat date-elements))))))
            ;; Default to "00000000" if no valid lastmod-date is found
            (setq lastmod-date (or lastmod-date "00000000"))
            ;; Find the end of this section (right before the next top-level heading)
            (let ((section-end (save-excursion
                                 (or (re-search-forward (format "^\\*\\{%d\\} " heading-level) nil t)
                                     (point-max))))) ;; End of current section or end of file
              ;; Only proceed if sanitized title exists and is valid
              (when (and sanitized-title (not (string-empty-p sanitized-title)))
                ;; Create the output file name (prepend the date)
                (setq output-file (expand-file-name (format "%s-%s.org" lastmod-date sanitized-title) pub-dir))
                ;; Write the section content (from prev-start to section-end)
                (write-region prev-start section-end output-file)
                (message "Wrote %s" output-file)))))))
    ;; Return nil to indicate successful processing
    nil))
#+end_src

I will go into more detail about how I set this up in a future post and how I decided on a split org-file naming convention.

** *Step 2: Org-Publish Configuration*

#+attr_org: :width 300px
#+attr_html: :width 100%
file:static/emacs/20241226125955-emacs--Exploring-Emacs-Based-Static-Website-Publishing-with-Org-Publish.jpg

After splitting the file, I defined the publishing pipeline in =org-publish-project-alist=. Here’s what each part does:

1. *=split-emacs=*:
   - Runs the custom splitting function (=my-org-publish-split-headings=).
   - Takes the original monolithic Org file and generates smaller Org files in a designated directory.
2. *=blog-posts-emacs=*:
   - Processes these generated Org files and exports them to HTML.
   - Adds metadata such as preamble, postamble, and custom =.css= links for styling.
   - Automatically generates a "sitemap" for blog indexing.
3. *=images-emacs=*:
   - Publishes related images to the target directory.
4. *=blog=*:
   - Meta-project to combine all the phases (=split-emacs=, =blog-posts-emacs=, =images-emacs=).

*** =org-publish-project-alist=

#+begin_src emacs-lisp
(require 'ox-publish)
;;
(setq org-publish-project-alist
      '(("split-emacs"
         :base-directory "~/DCIM/content"
         :base-extension "org"
         :publishing-directory "~/DCIM/content/split/emacs"
         :exclude ".*"
         :include ("emacs--all.org")
         :publishing-function my-org-publish-split-headings
         :recursive nil)
        ("blog-posts-emacs"
         :base-directory "~/DCIM/content/split/emacs"
         :base-extension "org"
         :publishing-directory "~/publish/hugo-emacs/site/static/public_html"
         :publishing-function org-html-publish-to-html
         :recursive t
         :section-numbers nil
         :with-toc nil
         :html-preamble t
         :html-postamble t
         :auto-sitemap t
         :sitemap-filename "index.org"
         :sitemap-title "the DyerDwelling"
         :html-head "<link rel=\"stylesheet\"
                    href=\"../assets/css//bootstrap.css\"
                    type=\"text/css\"/>\n
                    <link rel=\"stylesheet\"
                    href=\"../assets/css//style-ignore.css\"
                    type=\"text/css\"/>"
         :sitemap-function my-sitemap-format
         :sitemap-sort-files alphabetically)
        ("images-emacs"
         :base-directory "~/DCIM/content/emacs"
         :base-extension "jpg\\|gif\\|png"
         :recursive t
         :publishing-directory "~/publish/hugo-emacs/site/static/public_html/emacs"
         :publishing-function org-publish-attachment)
        ("blog" ;; Meta-project to combine phases
         :components ("split-emacs" "images-emacs" "blog-posts-emacs"))))
#+end_src

** Conclusion

Here is the generated site: https://www.emacs.dyerdwelling.family/public_html/

This was a simple introduction to my approach to using =org-publish= to provide an alternative web publishing option for my blog, while I'm still refining this workflow, the combination of a monolithic Org file for writing and =org-publish= for exporting HTML is already proving quite effective as a pure Emacs-powered alternative.

* DONE Calculate Number Of Days Between Two Dates :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241219132107-emacs--Calculate-Number-Of-Days-Between-Two-Dates
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-12-19 13:21>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241219132107-emacs--Calculate-Number-Of-Days-Between-Two-Dates.jpg
:END:

Just a very quick one today.

I recently needed to find the number of days between two dates. I thought this would be easy in Emacs, and indeed it was, but as with most things in Emacs, you need to know exactly what you're doing. Here is the method I used:

#+hugo: more 

#+begin_src 
  M-x =calendar=

  Navigate to the start date

  Set mark

  Navigate to the end date

  M-x =calendar-count-days-region=

  OR
 
  M-=
#+end_src

Note that the count is inclusive of the mark, the documentation says:

#+begin_quote
It is bound to M-=.

Count the number of days (inclusive) between point and the mark.
#+end_quote
  
#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241219132107-emacs--Calculate-Number-Of-Days-Between-Two-Dates.jpg]]

That is all. 🙂

* TODO vc-to-push-to-github-using-ssh :vc:github:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241217112011-emacs--vc-to-push-to-github-using-ssh
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-12-17 11:20>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241217112011-emacs--vc-to-push-to-github-using-ssh.jpg
:END:

Are you getting the following issue when trying to push to github from Emacs in vc-dir mdoe?
  
#+begin_src 
Running "git push"...
ssh_askpass: exec(/usr/lib/ssh/ssh-askpass): No such file or directory
git@github.com: Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
#+end_src

Well the ssh-askpass is not installed and doesn't exist in =/usr/lib/ssh/ssh-askpass=

Is there a way to point to a different name in Emacs?, not sure

But perform the following as a current workaround
  
Install the following:

=openssh-askpass=

Which make available the following:
  
/usr/bin/qt4-ssh-askpass

Emacs is looking for:

/usr/lib/ssh/ssh-askpass

So why not provide a symbolic link as root!?, seems to work:

#+begin_src 
  su -
  cd /usr/lib/ssh
  ln -s /usr/bin/qt4-ssh-askpass ssh-askpass
#+end_src

Although still raises the following:
  
#+begin_src
  Running "git push"...
  ErrorHandler::Throw - warning: QFSFileEngine::open: No file name specified file:  line: 0 function: 
  To github.com:captainflasmr/Emacs-enhanced.git
  6735e12..4766e6c  main -> main
#+end_src

* DONE Emacs Quick Window Pt 3 - jumping between two windows :emacs_core:emacs:elisp:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241213115239-emacs--Emacs-core-window-jumping-between-two-windows
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-12-13 20:15>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241213115239-emacs--Emacs-core-window-jumping-between-two-windows.jpg
:END:

The original implementation of =my/quick-window-jump= worked perfectly for multi-window setups. It enabled you to assign character labels to each window, display them as overlays within the windows themselves, and jump to your desired window by typing its corresponding key. However, for setups with just two windows (a very common scenario in Emacs), this process felt unnecessarily complicated. Why go through the entire label-assignment process when a single key press could suffice?

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241213115239-emacs--Emacs-core-window-jumping-between-two-windows.jpg]]
  
This latest tweak to =my/quick-window-jump= introduces a simple improvement and in fact is currently what =ace-window= does: *direct switching for two windows*. If there are exactly two windows open, the function now skips the overhead of key prompts and overlay creation. Instead, it switches directly to the other window, this seems more logical to me, why the extra key when it is obvious where the point is going to jump to?

Here’s the core logic for handling two windows:

#+begin_src elisp
(let* ((window-list (window-list nil 'no-mini)))
  (if (= (length window-list) 2)
      ;; If there are only two windows, switch to the other directly.
      (select-window (other-window-for-scrolling))
    ;; Otherwise, show the key selection interface.
    ...))
#+end_src

and here is the updated function:

#+begin_src elisp
(defun my/quick-window-jump ()
  "Jump to a window by typing its assigned character label.
  If there are only two windows, jump directly to the other window."
  (interactive)
  (let* ((window-list (window-list nil 'no-mini)))
    (if (= (length window-list) 2)
        ;; If there are only two windows, switch to the other one directly.
        (select-window (other-window-for-scrolling))
      ;; Otherwise, show the key selection interface.
      (let* ((my/quick-window-overlays nil)
             (sorted-windows (sort window-list
                                   (lambda (w1 w2)
                                     (let ((edges1 (window-edges w1))
                                           (edges2 (window-edges w2)))
                                       (or (< (car edges1) (car edges2))
                                           (and (= (car edges1) (car edges2))
                                                (< (cadr edges1) (cadr edges2))))))))
             (window-keys (seq-take '("j" "k" "l" ";" "a" "s" "d" "f")
                                    (length sorted-windows)))
             (window-map (cl-pairlis window-keys sorted-windows)))
        (setq my/quick-window-overlays
              (mapcar (lambda (entry)
                        (let* ((key (car entry))
                               (window (cdr entry))
                               (start (window-start window))
                               (overlay (make-overlay start start (window-buffer window))))
                          (overlay-put overlay 'after-string 
                                       (propertize (format "[%s]" key)
                                                   'face '(:foreground "white" :background "blue" :weight bold)))
                          (overlay-put overlay 'window window)
                          overlay))
                      window-map))
        (let ((key (read-key (format "Select window [%s]: " (string-join window-keys ", ")))))
          (mapc #'delete-overlay my/quick-window-overlays)
          (setq my/quick-window-overlays nil)
          (when-let ((selected-window (cdr (assoc (char-to-string key) window-map))))
            (select-window selected-window)))))))
#+end_src

* DONE Emacs Core Window Jumping With Visual Feedback :emacs_core:emacs:elisp:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241209085935-emacs--Emacs-core-window-jumping-visual-feedback
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-12-10 14:15>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241209085935-emacs--Emacs-core-window-jumping-visual-feedback.jpg
:END:

Already I think I can improve =my/quick-window-jump=: which was a window jumping mechanism I created in my previous post which uses a unique key identifier for window navigation just like =ace-window= but condensed into a minimal elisp defun implementation.

#+hugo: more

While the original implementation worked, I recently revisited and refined it to improve its modularity, visual feedback, and overall usability.

The main headline of the improvement is porting the =ace-window= window label identifier navigation mechanism using overlays!, see below:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241209085935-emacs--Emacs-core-window-jumping-visual-feedback.jpg]]

In this post, I’ll detail the evolution of =my/quick-window-jump=, highlighting the changes made to simplify the code, provide immediate visual indicators, and improve the end-user experience.

---

** The Original Implementation
*** Original Code

#+begin_src emacs-lisp
(defun my/quick-window-jump ()
  "Jump to a window by typing its assigned character label.
Windows are labeled starting from the top-left window and proceed top to bottom left to right."
  (interactive)
  (let* ((window-list (my/get-windows)) ; Get sorted list of windows
         (window-keys (seq-take '("j" "k" "l" ";" "a" "s" "d" "f") ; Assign key labels
                                (length window-list)))
         (window-map (cl-pairlis window-keys window-list)) ; Create key-to-window map
         (key (read-key (format "Select window [%s]: " (string-join window-keys ", ")))))
    (if-let ((selected-window (cdr (assoc (char-to-string key) window-map)))) ; Jump to selected window
        (select-window selected-window)
      (message "No window assigned to key: %c" key))))

(defun my/get-windows ()
  "Return a list of windows in the current frame, ordered from top to bottom, left to right."
  (sort (window-list nil 'no-mini)
        (lambda (w1 w2)
          (let ((edges1 (window-edges w1))
                (edges2 (window-edges w2)))
            (or (< (car edges1) (car edges2)) ; Compare top edges
                (and (= (car edges1) (car edges2)) ; If equal, compare left edges
                     (< (cadr edges1) (cadr edges2))))))))
#+end_src

While functional, several downsides existed in this implementation:

- *Separation of Logic:* The =my/get-windows= function added an extra layer of abstraction that wasn’t strictly necessary, as sorting logic could be directly embedded into the main function.
- *Lack of Visual Feedback:* The function provided no immediate indicator of which windows corresponded to which keys. Users had to guess or manually map the output of the key labels to the positions in their frame layout.

---

** The New and Improved Implementation

The updated version of =my/quick-window-jump= refines the original function by:

1. *Inlining Window Sorting Logic:* Sorting logic is now part of the main function rather than relying on a separate helper, simplifying maintenance and reducing cognitive overhead.
   
2. *Adding Overlay Labels:* Temporary overlays are added to each window, displaying the assigned key visually within the actual window. This makes it easier for users to identify which key corresponds to which window without having to manually figure it out.

Here’s the updated code:

*** Improved Code

#+begin_src emacs-lisp
(defun my/quick-window-jump ()
  "Jump to a window by typing its assigned character label.
Windows are labeled starting from the top-left window and proceeding top to bottom, then left to right."
  (interactive)
  (let* ((my/quick-window-overlays nil) ; Temporary list for overlays
         ;; Sort windows by position (top-to-bottom, left-to-right)
         (window-list (sort (window-list nil 'no-mini)
                            (lambda (w1 w2)
                              (let ((edges1 (window-edges w1))
                                    (edges2 (window-edges w2)))
                                (or (< (car edges1) (car edges2))
                                    (and (= (car edges1) (car edges2))
                                         (< (cadr edges1) (cadr edges2))))))))
         ;; Assign key labels to windows
         (window-keys (seq-take '("j" "k" "l" ";" "a" "s" "d" "f")
                                (length window-list)))
         (window-map (cl-pairlis window-keys window-list))) ; Create map of keys to windows
    ;; Add overlays to display key labels in each window
    (setq my/quick-window-overlays
          (mapcar (lambda (entry)
                    (let* ((key (car entry))
                           (window (cdr entry))
                           (start (window-start window)) ; Start position of window
                           (overlay (make-overlay start start (window-buffer window)))) ; Create overlay
                      (overlay-put overlay 'after-string  ; Add a visual label
                                   (propertize (format "[%s]" key)
                                               'face '(:foreground "white" 
                                                                   :background "blue" 
                                                                   :weight bold)))
                      (overlay-put overlay 'window window) ; Associate overlay with window
                      overlay))
                  window-map))
    ;; Read key input from user
    (let ((key (read-key (format "Select window [%s]: " (string-join window-keys ", ")))))
      ;; Clear overlays and reset
      (mapc #'delete-overlay my/quick-window-overlays)
      (setq my/quick-window-overlays nil)
      ;; Select window based on key or show error
      (when-let ((selected-window (cdr (assoc (char-to-string key) window-map))))
        (select-window selected-window)))))
#+end_src

---

** Key Improvements

1. *Eliminating Redundancy*  
   By folding the =my/get-windows= functionality into =my/quick-window-jump=, the updated function is now self-contained. This reduces dependency on external helpers and makes the logic easier to follow.

2. *Enhancing User Experience with Visual Overlays*  
   The use of temporary overlays provides immediate, intuitive feedback by displaying key mappings directly inside the appropriate windows. This reduces guesswork and makes navigation significantly faster.

   Each window is temporarily labeled with a key, using the following visual attributes:
   
   - *Foreground:* White for contrast.
   - *Background:* Blue for prominence.
   - *Bold Font:* For easy readability.

---

** Why These Changes Matter

Well I guess they don't really, it's just for me and its just for fun! 😀

1. *Reduced Mental Burden:* The new approach lets users navigate windows without having to remember or deduce key-to-window mappings. Visual feedback ensures immediate understanding of the layout.

2. *Improved Modularity:* By embedding all functionality into a single function and handling cleanup directly, the updated implementation is more modular and self-contained.

3. *Enhanced Readability and Maintainability:* Fewer moving parts and a more streamlined design make the function easier to maintain or extend in the future.

* TODO Emacs-core-copy-minibuffer-candidate-embark :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241209134058-emacs--Emacs-core-copy-minibuffer-candidate-embark
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-12-09 13:40>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241209134058-emacs--Emacs-core-copy-minibuffer-candidate-embark.jpg
:END:

Streamlining Minibuffer Efficiency: Copying Icomplete Candidates to the Kill Ring

The power of Emacs lies in its extensibility and the ability to customize nearly any aspect of its behavior. For users of the =icomplete= framework—or for those working primarily in the minibuffer—there’s often a need to copy a candidate (i.e., the currently selected or highlighted result in a completion list) to the kill ring for reuse elsewhere. While packages like Embark provide this functionality out of the box, it’s not always necessary to carry the overhead of an external dependency for something so specific.

In this blog post, we’ll explore a lightweight replacement for this aspect of Embark: copying the currently selected minibuffer candidate to the kill ring. We’ll achieve this with a simple custom function and keybinding, giving you the functionality you need without introducing additional complexity into your Emacs configuration.

** Why Copy Minibuffer Candidates?

Minibuffer candidates represent items generated via completion mechanisms, such as file paths, function names, or command options. Copying a candidate lets you extract the current selection, either for reuse in another buffer or for other interactive purposes. For example:

- *Programming workflows*: Copy a partial function name to paste into a code snippet.
- *Navigation*: Grab a file path for reference or to share elsewhere.
- *General efficiency*: Quickly transfer the displayed suggestion for further processing.

If you’re using =icomplete=, which enhances the built-in minibuffer completion experience, adding this capability takes only a few lines of code.

** The Function: =my-icomplete-copy-candidate=

Here’s the code we'll be working with:

#+begin_src elisp
(defun my-icomplete-copy-candidate ()
  "Copy the current Icomplete candidate to the kill ring."
  (interactive)
  (let ((candidate (car completion-all-sorted-completions)))
    (when candidate
      (kill-new (substring-no-properties candidate))
      (abort-recursive-edit))))
#+end_src

*** Breaking It Down

Let’s step through the functionality:

1. *=completion-all-sorted-completions=*:
   This variable holds the list of all completion candidates in order of relevance. The highlighted or selected candidate resides at the top of this list (=car=).

2. *=kill-new=*:
   The =kill-new= function adds the provided string to the kill ring. By doing this, you can immediately reuse the copied candidate elsewhere via =yank= (=C-y=).

3. *=substring-no-properties=*:
   This ensures that the copied candidate is plain text, stripping any text properties (e.g., face attributes) that might otherwise clutter the kill ring.

4. *=abort-recursive-edit=*:
   After copying, the function exits the minibuffer. This behavior ensures seamless interaction—when the candidate is copied, you can immediately move on without needing to manually close the completion session.

*** Error Handling

The function gracefully handles cases where there’s no active candidate (=when candidate=), ensuring it doesn’t break unexpectedly.

** The Key Mapping

After defining the function, we bind it to an intuitive key combination within the minibuffer’s completion context:

#+begin_src elisp
(define-key minibuffer-local-completion-map (kbd "C-c ,") 'my-icomplete-copy-candidate)
#+end_src

*** Why =C-c ,=?

This keybinding was chosen for its mnemonic value:
- =C-c= acts as a common prefix for user-defined functionality.
- The =,= symbol feels natural for an action like “replicate” or “copy” because of its lightweight, fast motion on the keyboard.

Of course, the keybinding is entirely customizable—you can select any sequence that fits your workflow.

** Real-World Use Case

Imagine you’re in a workflow where you frequently rely on Icomplete to discover file names, commands, or completions for other textual inputs. Let’s say you want to copy the current candidate to use it elsewhere:

1. *Trigger completion*:
   Start completion via a command that leverages =icomplete= (e.g., =find-file=).

2. *Select a candidate*:
   Navigate through the candidate list using the usual keys (e.g., =TAB= or =C-n=).

3. *Copy the candidate*:
   When the desired candidate is highlighted, press =C-c ,= to copy it to the kill ring. You can confirm the copy by immediately accessing the kill ring (=C-y= or =M-y=).

4. *Exit the minibuffer*:
   Since the function automatically aborts the minibuffer session, you can proceed with your workflow without manual intervention.

** Why Use This Instead of Embark?

While Embark is a powerful package for minibuffer actions, its general-purpose approach might be overkill if all you need is the ability to copy candidates. Here’s why you might prefer a custom solution like =my-icomplete-copy-candidate=:

- *Lightweight*: No need to install and configure a separate package.
- *Simplicity*: Single-purpose implementation focuses only on copying candidates.
- *Control*: Easily customizable to fit specific needs or workflows.

For users who already rely heavily on Embark’s wider feature set, this function likely overlaps with existing capabilities. But for those aiming to keep their Emacs configuration minimal, it’s a great alternative.

** Closing Thoughts

Implementing small, targeted functions like =my-icomplete-copy-candidate= demonstrates the power of Emacs to adapt to individual needs. By taking control of your minibuffer workflow with just a few lines of code, you can replicate the functionality of more complex tools while keeping your setup lightweight and easy to maintain.

Try incorporating this function into your Emacs workflow, and let us know how it enhances your productivity! Do you have other minibuffer tricks or customizations to share? Drop them in the comments below or join the discussion!

* DONE Core Emacs Init Without External Packages :emacs_core:emacs:elisp:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241206143221-emacs--Emacs-Core-Emacs-Init-Without-External-Packages
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-12-06 15:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241206143221-emacs--Emacs-Core-Emacs-Init-Without-External-Packages.jpg
:END:

I thought I would share a simple concept that I have found very beneficial: creating an Emacs init file that remains almost fully functional for my use but doesn't include any external packages!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241206143221-emacs--Emacs-Core-Emacs-Init-Without-External-Packages.jpg]]
  
This setup benefits two main use cases. The first is when using Emacs at work without internet access, and the second is configuring it for use on Windows (with an internet connection). For some reason, my Windows version always seems to struggle to connect to MELPA/ELPA for package downloads, prompting me to resort to an initial complete local repository download. Even then, I still encounter some inconsistencies. I don't often use the native Windows Emacs version anyway, and now that WSL is mature enough, I know a fully functioning version of Emacs can run seamlessly.

Anyway enough with the blithering.

I have realized that over the years, I have accumulated many Elisp snippets that can actually replace several packages I have downloaded from MELPA.

For example, while I couldn't live without *ace-window*, I only primarily use it for the window-jumping functionality. Now that I am familiar with the typical positions of the key identifiers in my window layout, I thought I would simply write my own implementation in Elisp:

#+begin_src elisp
(defun my/quick-window-jump ()
  "Jump to a window by typing its assigned character label.
  Windows are labeled starting from the top-left window and proceed top to bottom left to right."
  (interactive)
  (let* ((window-list (my/get-windows))
         (window-keys (seq-take '("j" "k" "l" ";" "a" "s" "d" "f")
                                (length window-list)))
         (window-map (cl-pairlis window-keys window-list))
         (key (read-key (format "Select window [%s]: " (string-join window-keys ", ")))))
    (if-let ((selected-window (cdr (assoc (char-to-string key) window-map))))
        (select-window selected-window)
      (message "No window assigned to key: %c" key))))

(defun my/get-windows ()
  "Return a list of windows in the current frame, ordered from top to bottom, left to right."
  (sort (window-list nil 'no-mini)
        (lambda (w1 w2)
          (let ((edges1 (window-edges w1))
                (edges2 (window-edges w2)))
            (or (< (car edges1) (car edges2)) ; Compare top edges
                (and (= (car edges1) (car edges2)) ; If equal, compare left edges
                     (< (cadr edges1) (cadr edges2))))))))

(global-set-key (kbd "M-a") #'my/quick-window-jump)
#+end_src

So the =ace-window= jumping functionality is now usable in an environment without access to MELPA!
  
I thought I would present my "no package" Emacs config piece by piece one blog post at a time, showcasing 90% of the functionality I typically use day-to-day and how I have managed to either write some elisp, found out a built-in option, or adapted my workflow in some way.

I still have my "full-fat" version, of course, but I have now based it on the =core= version (hence the name) and added extra things like =magit=, etc.

However, =magit= is a good example on something I think I might be able to remove soon to switch to the built-in Emacs VC. I successfully use it at work with both Git and Subversion!

If you are interested in seeing the full "no fat" version, have a ganders at: https://github.com/captainflasmr/Emacs-core

There will be more to come on this topic in the coming weeks... 😀

* TODO Sudo-Using-It :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241130201425-emacs--Sudo-Using-It
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-11-30 20:14>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241130201425-emacs--Sudo-Using-It.jpg
:END:

Very similar to Tramp except use double colon:
  
C-x C-f /su::/etc/hosts
C-x cC-f /sudo::/etc/hosts

* DONE Shrinking and Widening Org Tables :orgtable:org:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241128130253-emacs--Shrinking-Widening-Org-Tables
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-11-28 13:02>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241128130253-emacs--Shrinking-Widening-Org-Tables.jpg
:END:

This post is more of a note to myself, something I can store in my single emacs blog org file, so if I forget again, I can quickly search.

I keep forgetting the keybinding to shrink and expand an org table.

I often define tables to have a narrower width than content using the <num> concept in the top line of the table, but when I want to expand, I just can't remember the keybinding.

A search in =*help*= for =org-table-shrink= and =org-table-expand= reveals nothing!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241128130253-emacs--Shrinking-Widening-Org-Tables.jpg]]

Anyway, here is a note to myself:
  
#+begin_src 
  C-c TAB (translated from C-c <tab>) runs the command org-ctrl-c-tab
  (found in org-mode-map), which is an interactive native-compiled
  Lisp function in ‘org.el’.

  It is bound to C-c TAB.

  (org-ctrl-c-tab &optional ARG)

  Toggle columns width in a table, or show children.  Call
  ‘org-table-toggle-column-width’ if point is in a table.  Otherwise
  provide a compact view of the children.  ARG is the level to hide.
#+end_src

For clarity, within an Org table, pressing =C-c <TAB>= will toggle shrink/expand the state of the column that the point is currently in.

=C-u C-c <TAB>= will shrink all columns AND
  
=C-u C-u C-c <TAB>= will expand all columns

Right, that is a note, just for me 😀

* DONE Reducing Friction when Copying Whole Buffer To Kill Ring :emacs:elisp:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241118102423-emacs--Copying-Buffer-To-Kill-Ring
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-11-18 10:24>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241118102423-emacs--Copying-Buffer-To-Kill-Ring.jpg
:END:

Just a quick one today.

In keeping with the ongoing effort to reduce friction in the venerable Emacs text editor, I realized that a common action I often perform is copying the entire contents of the buffer, usually for pasting elsewhere.

#+hugo: more

To perform this I have chained together some emacs commands, namely =(mark-whole-buffer)= and then =(kill-ring-save)=

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241118102423-emacs--Copying-Buffer-To-Kill-Ring.jpg]]

The problem with pushing the buffer to the kill ring in this manner is that I lose the current cursor position/point and end up using =isearch= to navigate my way back. Strangely, it is only recently that I have found this annoying!

There are a few options to address this:

- Use Emacs marks
- Create a macro
- Create a defun

Initially I tried the setting =mark= option meaning that I =C-<SPC> C-<SPC>= to set the mark at the current position and then =C-u C-<SPC>= to pop back to my previous mark set.  The only issue is that =(mark-whole-buffer)= creates a mark at the end of the selected region and my first mark pop would be to this position, so I have to mark pop again.

The benefit of this approach is that I will start becoming more familiar with setting marks and navigating more efficiently within Emacs, which I really think I should learn. However, it all feels a little clunky, and you know what? I'm just going to write a simple elisp defun and bind it.

=save-excursion=, in this case, can be extremely useful!

#+begin_src elisp
(defun my/copy-buffer-to-kill-ring ()
  "Copy the entire buffer to the kill ring without changing the point."
  (interactive)
  (save-excursion
    (kill-ring-save (point-min) (point-max))))

(bind-key* (kbd "M-s z") #'my/copy-buffer-to-kill-ring)
#+end_src

* DONE Org Table From Org Headings using a Babel Block :org:emacs:elisp:babel:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241110085851-emacs--Babel-Block-Generating-Org-Table-From-Org-Headings
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-11-12 20:20>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241110085851-emacs--Babel-Block-Generating-Org-Table-From-Org-Headings.jpg
:END:

In this post, I'll walk you through how I use an Org Babel block to generate a dynamic Org table based on Org headings.

This approach is handy for anyone who wishes to programmatically extract information from an Org file (such as TODO states, tags, and content) and automatically format it as a neatly structured Org table. You can then export this table to various formats --- like HTML, Markdown, or LaTeX --- with built-in Org mode support.

#+hugo: more

At work, I'm currently using Emacs and Confluence, so my idea was to figure out how to get an org file into a Confluence post in a structured manner. For the particular task I'm working on, I've decided that I would like to convert an org file into a table. The table format essentially flattens the information presented by org structured text, and putting it as a table in Confluence also has the advantage of column sorting  and filtering.

This seems for the task in hand the most efficient way of representing a certain set of data.  I will have the advantage of always working within a familiar org document at the basic text level, leveraging all those years of Emacs muscle memory and as always forming the markup base for a myriad of export options.

However, I'm going to devise another method of export, lets see if I can find an effectual way to convert an org file into a table that can be efficiently used in Confluence.

I did some research and thought that maybe the org column mode could be somewhat useful. It's tabular, right? Can't I just grab that data and put it somewhere? Well, from what I can gather, it's mainly for more easily representing properties and uses overlays, which are not conducive to easy export.

A dynamic block looks quite interesting and seems to be more for representing some form of dynamic data that is consistently updated and is tied to an org document.  I think a pattern of tabular representation can be generated using this form and I might take a look at this in the future but for now it doesn't quite seem like the incremental learning opportunity I'm looking for.

And another option?, well that is to play around with an ox org back-end?, for example generating an html table and tailoring to my own needs.  This might be a bit too advanced for me at this stage, I think I will stick with the approach I decided on below which is to create an org babel block and generate a table through the output header parameter =:results table= mechanism.

Of course I am familiar with org babel blocks, it is how I generate my Emacs init file through the tangle mechanism, but I didn't quite realise just how powerful it could be.  My idea here is to parse the current org buffer with a babel block and output an org table simply as a string which would be interpreted as an org table in org-mode, that would work right?.  Well yes, yes it did work, I essentially just kept appending row strings as you would see in a typical org table, separated by the pipe character.  The code however was not particularly efficient, I would gather (push) all the relevant org items onto a list and then loop over them to construct the org table string.  As far as I was aware at the time the only babel mechanism for generation was though a form of pushing textual data to stdout which would then appear in the current buffer to be interpreted in whichever way you want according to the mode.

I stumbled on to a better solution however. I had already done the hard work of constructing a list of lists, with each sublist representing a row, it turns out that I can just return this list from the babel block and if I have the babel output header parameters set as =:results table= the list will be interpreted as a table!

Well lets try this out...

Note: the following examples will all be a babel block with the following header parameters defined:

#+begin_src
,#+begin_src emacs-lisp :results table :exports both
#+end_src

#+begin_src emacs-lisp :results table :exports code
(let ((rows '()))
  (push (list "1: first row" "2: first row") rows)
  rows)
#+end_src

#+begin_src
| 1: first row | 2: first row |
#+end_src

That is a table with a single row!

Lets expand...

#+begin_src emacs-lisp :results table :exports code
(let ((rows '()))
  (push (list "1: first row" "2: first row") rows)
  (push (list "1: second row" "2: second row") rows)
  rows)
#+end_src

#+begin_src
| 1: second row | 2: second row |
| 1: first row  | 2: first row  |
#+end_src

So now I have a simple mechanism for adding multiple rows.

Hang on!, the rows are not the order I expected, lets reverse.

#+begin_src emacs-lisp :results table :exports code
(let ((rows '()))
  (push (list "1: first row" "2: first row") rows)
  (push (list "1: second row" "2: second row") rows)
  (reverse rows))
#+end_src

#+begin_src
| 1: first row  | 2: first row  |
| 1: second row | 2: second row |
#+end_src

What about the table header?, this took a while to figure out, but I think I have it.

#+begin_src emacs-lisp :results table :exports code
(let ((rows '()))
  (push (list "1: first row" "2: first row") rows)
  (push (list "1: second row" "2: second row") rows)
  (setq rows (reverse rows))
  (push 'hline rows)
  rows)
#+end_src

#+begin_src
|---------------+---------------|
| 1: first row  | 2: first row  |
| 1: second row | 2: second row |
#+end_src

Well that is the header line, but there is no header!!

#+begin_src emacs-lisp :results table :exports code
(let ((rows '())
      (header (list "col1" "col2")))
  (push (list "1: first row" "2: first row") rows)
  (push (list "1: second row" "2: second row") rows)
  (setq rows (reverse rows))
  (push 'hline rows)
  (cons header rows))
#+end_src

#+begin_src
| col1          | col2          |
|---------------+---------------|
| 1: first row  | 2: first row  |
| 1: second row | 2: second row |
#+end_src

I think I have figured it out now, so the next aspect I need to consider is how to pick up the org elements.  It seems a common approach is to use =org-map-entries= which steps though each headline, seemingly actually within the buffer itself and some helper functions are available which can be used to extract the data.  For example, =org-element-at-point=, =org-outline-level=, =org-get-tags=, e.t.c, I am aware that there is a more formal API type of method where a syntactical tree can be made available through =org-element-parse-buffer= but that maybe is for another time.  Lets move ahead with the org babel, table output, org list construction through org-map-entries implementation.

** The Task - Collecting Headings and Outputting in a Table

The goal is simple: outline tasks with various headings, nesting levels, TODO states, tags, and content in an Org file, and use that information to generate an Org table using an *Emacs Lisp Org Babel block*. This allows us to extract metadata from headings into a well-structured table with a corresponding header row.

Each Org heading will be converted into a table row in the following format:

- *Title*: The full heading, including indentation to represent the level hierarchy.
- *TODO State*: The TODO keyword (like TODO, DONE, or other custom states) associated with the heading.
- *Tags*: Any Org tags associated with the heading.
- *Contents*: The content that immediately follows the heading.

** The Code

The following Emacs Lisp code in an Org Babel block which scans the Org file, collects the required information from all headings, and formats it into a table. Let's break it down step-by-step:

*** Org Babel Block: Automatic Table Generation

#+begin_src emacs-lisp :class table-custom :results table :exports code
(let ((rows)
      (header (list "Title" "TODO" "Tags" "Contents"))
      (table-rows '())
      (max-level 0))
  (org-map-entries
   (lambda ()
     (let* ((entry (org-element-at-point))
            (heading (org-get-heading t t t t))
            (level (org-outline-level))
            (tags (org-get-tags))
            (todo (org-get-todo-state))
            (contents ""))
       (org-end-of-meta-data nil)
       (when (eq (org-element-type (org-element-at-point)) 'paragraph)
         (let ((start (point)))
           (org-next-visible-heading 1)
           (setq contents (buffer-substring-no-properties start (point)))
           (dolist (pattern '("^#\\+begin.*" "^#\\+end.*" "\n+"))
             (setq contents (replace-regexp-in-string pattern
                                                      (if (string= pattern "\n+") " " "")
                                                      (string-trim contents))))))
       (setq max-level (max max-level level))
       (push (list (concat (make-string (* (1- level) 2) 45) " " heading)
                   (or todo "") (string-join tags ":") (or contents "")) rows))))
  (setq rows (reverse rows))
  (push 'hline rows)
  (cons header rows))
#+end_src

** How It Works

- *=org-map-entries=*: This function iterates through all headings in the Org document. Each heading that it encounters produces metadata, such as the heading title, level in the hierarchy, TODO state, tags, and the content following the heading.

- *Content Sanitization*: For headings with associated content, newline characters and code block markers (like =#+begin_src= and =#+end_src=) are removed. This ensures that the content is condensed into a single line for insertion into the Org table.

- *=heading=*: This variable stores the full heading, formatted with indentations based on its nesting level (=level=) to visually represent its position in the Org structure.

- *Output Format*: The information is collected into a list (=rows=). The list contains individual lists representing rows of the table. A "horizontal line" (='hline=) is inserted to act as a row separator.

- Finally, the first list in =rows= is a header row (=header=), which includes the column titles: "Title", "TODO", "Tags", and "Contents".

When evaluated (=C-c C-c=) within this org source for the blog post the code block outputs a table like the one below, note that it will also include the example Org Structure defined in the next section.

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241110085851-emacs--Babel-Block-Generating-Org-Table-From-Org-Headings/2024-11-10-13-54-46.jpg]]

** Example Org Structure

Here's an example Org structure that would produce part of the table above:

#+begin_src org
,** TODO one :tag1:tag2:
,*** DOING sub

content 1

,#+begin_src
>>
code start
more code >>
,#+end_src
after code

,**** further into the tree! :subtag:

first line, no space before!

,***** even further down the hole! :hole_tag:

No escape!!

,** TODO two :tag_two:

content 2

,** three
SCHEDULED: <2024-11-10 Sun>
#+end_src

** Exporting the Table

Once this table is generated, it will correctly render within Org mode, respecting the Org table formatting rules. You can also export it to other formats (like HTML or Markdown) using standard Org export commands (such as =C-c C-e h= or =C-c C-e m=).

For example, exporting to *HTML* will produce a structured HTML table with the column headers formatted as table header (=<th>=) elements, and the data rows and horizontal lines correctly converted into formatting tags.

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241110085851-emacs--Babel-Block-Generating-Org-Table-From-Org-Headings/2024-11-10-13-53-37.jpg]]

** Conclusion

By leveraging Emacs Lisp and Org Babel, we've created a highly flexible way to extract information from Org headings and output it as a well-structured table. This method not only saves time when working with large or hierarchical documents, but it also provides a powerful way to export Org-based data to various formats based on your needs.

This approach can be extended further to include other metadata (like scheduled dates, deadlines, or custom properties) or more advanced formatting options for both Org and export formats.

*Next Steps*: Experiment with Org Babel to explore even more advanced use cases, for example I would like to format the table in a more flexible manner, for example to specify the width and maybe the cell / row colour based on content.

* DONE Generate Current Year tag in an Org Capture Template :org_capture:org:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241007121110-emacs--Org-Capture-Dynamically-Setting-Year
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-11-01 Fri 08:30>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241007121110-emacs--Org-Capture-Dynamically-Setting-Year.jpg
:END:

A crucial aspect of maintaining organized and up-to-date notes is the use of Org Capture templates.

I have currently always hard-coded/set the current year in my org capture templates for use when exporting/constructing my web pages and as a tag for some filtering / web index generation.  Of course the main disadvantage of this is that I have to remember to update the year each year, of which I often fail miserably. ☹️

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241007121110-emacs--Org-Capture-Dynamically-Setting-Year.jpg]]

Can I get an org capture template to auto generate just the year as a tag like other capture template attributes?

Well yes, yes you can, and there a couple of ways to achieve this.

Firstly there is the org capture family of format strings which inserts a date when the capture is triggered.  This is a bit much for me and instead of generating just a string for the year, each specifier will generate a full timestamp:

- *%U* — Inactive Timestamp (Full Date and Time)
- *%T* — Active Timestamp (Full Date and Time)
- *%t* — Active Timestamp (Current Date Only)
- *%u* — Inactive Timestamp (Current Date Only)

However there is another format specifier, which can just insert the year, simply use *=%<%Y>=* which is part of a pretty standard common date or time string format options, for example, here are some useful format specifiers that can be used:

- `%Y`: Year (e.g., `2023`)
- `%m`: Month (e.g., `10` for October)
- `%d`: Day (e.g., `05`)
- `%H`: Hour (24-hour clock)
- `%M`: Minute
- `%S`: Seconds
- `%A`: Full weekday name (e.g., `Monday`)
- `%B`: Full month name (e.g., `October`)

Well that was easy, so to insert a year tag I can just wrap colons around %<%Y>

Just for fun, lets try something a little more advanced to achieve the same goal but this time allowing much more flexibility.

A particularly useful functional aspect of an org template is that the dynamic generation of the current year can be achieved using some elisp.  Lets use the =(format-time-string)= function.

** Understanding =(format-time-string "%Y")=

Before diving into the implementation, let's break down what =(format-time-string "%Y")= does:

- *=format-time-string=*: This is an Emacs Lisp function that formats the current time and date into a string based on a specified format.

- *="%Y"=*: This format code specifically fetches the four-digit representation of the current year. For example, in 2023, it would insert "2023", and conforms to the date specifiers defined above for the more simple capture template format definition.

By embedding this function into my Org Capture templates, the inclusion of the current year is neatly automated, this not only reduces manual updates but also ensures consistency across my entries.

** Implementing Dynamic Year in Capture Templates

Here's an example Org Capture template that uses =(format-time-string "%Y")= to dynamically manage the year for Emacs-related entries:

#+begin_src elisp
("e" "Emacs" plain
 (file+function
  "~/DCIM/content/emacs--all.org"
  my-capture-top-level)
 "* TODO %^{title} :emacs:%(format-time-string \"%Y\"):"
 :PROPERTIES:
 :EXPORT_FILE_NAME: %<%Y%m%d%H%M%S>-emacs--%\\1
 :EXPORT_HUGO_SECTION: emacs
 :EXPORT_HUGO_LASTMOD: <%<%Y-%m-%d %H:%M>>
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/%<%Y%m%d%H%M%S>-emacs--%\\1.jpg
 :END:
 %?
 " :prepend t :jump-to-captured t)
#+end_src

*** Key Features of this Template

- *Automatic Year Insertion*:
  - The directive =:%(format-time-string \"%Y\"):=, within the headline, ensures that the current year is automatically included as a tag whenever you create a new entry. This functionality is particularly useful for organizing tasks by year, making it easier to retrieve and filter information based on time.
- *Enhanced Organization*:
  - By integrating the current year automatically, you maintain a systematic arrangement of notes and tasks, minimizing the need for manual adjustments every new year.
- *Ease of Use*:
  - This template is set up for simplicity and re-usability. Once implemented, it requires no further changes for year-specific adjustments, allowing you to focus on content generation rather than template management.

** Benefits of Dynamic Year Management

- *Time-Saving*: No need to modify the template annually, thus saving valuable time.
- *Consistent Records*: Automatic year tagging provides a consistent way of tracking entries over time.
- *Improved Searchability*: Facilitates year-based searches and statistics generation, enhancing the utility of your Org files.

* DONE selected-window-accent-mode with window colour blending options :selected_window_accent_mode:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241021172036-emacs--Enhanced-selected-window-accent-functionality-with-blending-options
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-10-22 08:40>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/selected-window-accent-mode-07.jpg
:END:

I have enhanced =selected-window-accent= functionality with blending options to blend colourize the selected window (see below):

#+hugo: more

#+HTML: <img src="https://raw.githubusercontent.com/captainflasmr/selected-window-accent-mode/main/demos/selected-window-accent-mode-demo-blend.gif" width="80%" />

\\
\\

This means that not only will the mode-line, fringes and header be accent coloured, but also the whole selected window background colour, tinted to the alpha chosen.

The features added are as follows:

- Introduced =selected-window-accent-use-blend-background= and =selected-window-accent-use-blend-alpha= to allow blending of the accent colour with the background of the selected window a selected alpha amount.
- Introduced new toggle functions and added to transient:
  - =selected-window-accent-toggle-blend-background=
  - =selected-window-accent-toggle-pywal=
- Added function =selected-window-accent-blend-colors= to support blending of two colours.
- Updated =selected-window-accent--set-foreground-color= and =selected-window-accent= functions to incorporate new blending feature.
- Improved existing functions for setting and toggling accent features, ensuring consistent style and formatting.
- Cleaned up indentation and formatting inconsistencies across the file for better readability.

Example use of new selected window blending functionality:

#+begin_src elisp
(use-package selected-window-accent-mode
  :config (selected-window-accent-mode 1)
  :custom
  (selected-window-accent-fringe-thickness 10)
  (selected-window-accent-use-blend-background t)
  (selected-window-accent-use-blend-alpha 0.2)
  (selected-window-accent-tab-accent t)
  (selected-window-accent-custom-color "cyan4")
  (selected-window-accent-mode-style 'default))
#+end_src

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/selected-window-accent-mode-07.jpg]]

#+begin_src elisp
(use-package selected-window-accent-mode
  :config (selected-window-accent-mode 1)
  :custom
  (selected-window-accent-fringe-thickness 10)
  (selected-window-accent-use-blend-background t)
  (selected-window-accent-use-blend-alpha 0.1)
  (selected-window-accent-tab-accent t)
  (selected-window-accent-custom-color "orange")
  (selected-window-accent-mode-style 'subtle))
#+end_src

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/selected-window-accent-mode-08.jpg]]

* DONE Transforming Dired File Paths into Org Links :org:hugo:emacs:elisp:dired:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240918111443-emacs--Transforming-Dired-File-Paths-into-Org-Links-with-Emacs-Lisp
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-10-17 15:36>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240918111443-emacs--Transforming-Dired-File-Paths-into-Org-Links-with-Emacs-Lisp.jpg
:END:

I am of course using org mode for organizing my tasks, notes and other paraphernalia.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240918111443-emacs--Transforming-Dired-File-Paths-into-Org-Links-with-Emacs-Lisp.jpg]]

In addition, I generate static web pages from org using *=hugo=*, with each org heading representing a single post.

I often find myself needing to refer to files stored in a directory, especially image files that can be org embedded and then passed through to Hugo by the =ox-hugo= package.

Navigating to the file and manually generating the appropriate org link can be just a little cumbersome - to initially pick up the file name and then insert the relevant org attributes.

=dired-copy-filename-as-kill= is a function I often use in =dired=, which copies the filename under point. I can then use something like =tempel= to insert the attributes. However, while the combination of copying the filename in =dired= and then remembering the =tempel= shortcode is quite efficient, I think this could be accomplished more cleanly with some Elisp and a =dired-mode= mapping.

Here is a typical embedded image form, which restricts the image within the org document to 300 pixels and to 100% width when exported through hugo to my web site.

#+begin_src
,#+attr_org: :width 300px
,#+attr_html: :width 100%
[[file:static/emacs/20240918111443-emacs--Transforming-Dired-File-Paths-into-Org-Links-with-Emacs-Lisp.jpg]]
#+end_src

Lets walk through a custom function, =my/dired-file-to-org-link=, which transforms the =dired= file path under cursor/point into an org link and copies it to the kill ring for easy pasting.

#+begin_src elisp
(defun my/dired-file-to-org-link ()
  "Transform the file path under the cursor in Dired to an Org mode
link and copy to kill ring."
  (interactive)
  (let ((file-path (dired-get-file-for-visit)))
    (if file-path
        (let* ((relative-path (file-relative-name file-path
                                                  (project-root (project-current t))))
               (org-link (concat "#+attr_org: :width 300px\n"
                                 "#+attr_html: :width 100%\n"
                                 "file:" relative-path "\n")))
          (kill-new org-link)
          (message "Copied to kill ring: %s" org-link))
      (message "No file under the cursor"))))
#+end_src

When =my/dired-file-to-org-link= is called in a dired buffer, it gets the file path under the point, transforms it into an Org link with specific attributes, and copies the link to the kill ring. This enables you to quickly paste it into your Org file.

I map this to the letter =b= in the =dired-mode= mapping, which for me mnemonically refers to (b)log and the b key is not one I currently use in dired.

Note also the use of project.el with the project functions, as I have a project top level defined for my website content, allowing for an easily generated relative path name.

Therefore for example,  =20240918111443-emacs--Transforming-Dired-File-Paths-into-Org-Links-with-Emacs-Lisp.jpg= from dired in an =emacs= directory is transformed into :

#+begin_src
,#+attr_org: :width 300px
,#+attr_html: :width 100%
[[file:static/emacs/20240918111443-emacs--Transforming-Dired-File-Paths-into-Org-Links-with-Emacs-Lisp.jpg]]
#+end_src

* DONE Simple Directory and File Creation Using Vertico Completion Exit With Input :vertico:emacs:elisp:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241004102654-emacs--Simple-Directory-Creation-Using-Vertico-Exit-With-Input
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-10-09 20:30>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241004102654-emacs--Simple-Directory-Creation-Using-Vertico-Exit-With-Input.jpg
:END:

In my previous post about creating simple functions to create a new directory and file in =dired=, I received an interesting comment suggesting another way to bypass the potential messiness of completion and pass through the literal text input.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241004102654-emacs--Simple-Directory-Creation-Using-Vertico-Exit-With-Input.jpg]]

My last post :

#+begin_export md
[Simple Directory and File Creation in Dired]({{< ref
"/emacs/20240922201246-emacs--Efficient-Directory-and-File-Management-with-Dired-in-Emacs.md" >}})
#+end_export

It is a subtlety of most if not all completion systems, and that is to exit with any input, hence exiting without having to necessarily match and complete.

Given this, and given that I'm using the completion framework of =vertico=, I thought I would revisit the vertico github manual : https://github.com/minad/vertico

and I find :

*M-RET -> vertico-exit-input*

#+begin_quote
vertico-exit-input exits with the minibuffer input instead. Exiting with the current input is needed when you want to create a new buffer or a new file with find-file or switch-to-buffer. As an alternative to pressing M-RET, move the selection up to the input prompt by pressing the up arrow key and then press RET.
#+end_quote

Well this is exactly the issue I was having and why I wrote my two little simple functions.  Now if I build in M-RET into my muscle memory (which already seems pretty natural), I can refine my Emacs init, while adhering more to vanilla Emacs concepts.  Also as I now am being more idiomatic, I suspect the M-RET keybinding may just come in handy at some point in the future.

So, now rebinding =dired-mode-map= as follows:

#+begin_src elisp
("_" . dired-create-empty-file)
#+end_src

This is all that is required; note that =dired-create-directory= is already bound to my preferred keybinding.

So continues the evolution of my Emacs understanding!

As a side-ish note, I have found that writing this blog provides not only an opportunity to explore a topic further and thoroughly understand it, thereby enabling me to articulate the subject fully, but also to receive comments and discover subtle nuances that I hadn't realized existed or hadn't thought to explore!

* DONE Syncing Tab Theme After Theme Load :tab_bar:tab:emacs:elisp:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20241001092329-emacs--Syncing-Tab-Theme-After-Theme-Load
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-10-01 09:50>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20241001092329-emacs--Syncing-Tab-Theme-After-Theme-Load.jpg
:END:

Previously I wrote about the incompatibility of some Emacs themes with the tab-bar and my temporary fix:

#+hugo: more

#+begin_export md
[Syncing Tab Bar To Theme]({{< ref
"/emacs/20240817082349-emacs--Syncing-Tab-Bar-To-Theme.md" >}})
#+end_export

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20241001092329-emacs--Syncing-Tab-Theme-After-Theme-Load.jpg]]

The tab bar was introduced in Emacs 27.1, during which I created a function to apply some simple logic to make the tabs look moderately decent and fit in with the new theme. The only thing I couldn't figure out was how to activate the function after a theme load, as there didn't seem to be a hook.

Well, actually there does seem to be such a hook and it seems to have gone into Emacs 29.  As with a lot of these little tweaks I found this on reddit in the emacs subreddit:

https://www.reddit.com/r/emacs/comments/1ft3wwm/did_the_much_needed_theme_change_hook_arrive_with/

From my previous post I wrote :

#+begin_quote
Now that the =defun= is available, how to activate it? My first thought was to add a hook for when a theme is loaded, but there doesn't seem to be such a feature!?  I also tried advising around `load-theme`, but that didn’t go well either, it worked for themes that were not loaded, but for those that were, a change in state was not detected, and the tab theme tweak was not applied.
#+end_quote

The solution is to simply add the following to your init file. Now that I know about this, I might even find some other use for it.

#+begin_src elisp
(defun my/after-theme-loaded(theme)
  (my/sync-tab-bar-to-theme))

(add-hook 'enable-theme-functions 'my/after-theme-loaded)
#+end_src

with the original =my/sync-tab-bar-to-theme= as follows:

#+begin_src elisp
(defun my/sync-tab-bar-to-theme ()
  "Synchronize tab-bar faces with the current theme."
  (interactive)
  (let ((default-bg (face-background 'default))
        (default-fg (face-foreground 'default))
        (inactive-fg (face-foreground 'mode-line-inactive))) ;; Fallback to mode-line-inactive
    (custom-set-faces
     `(tab-bar ((t (:inherit default :background ,default-bg :foreground ,default-fg))))
     `(tab-bar-tab ((t (:inherit default :background ,default-fg :foreground ,default-bg))))
     `(tab-bar-tab-inactive ((t (:inherit default :background ,default-bg :foreground ,inactive-fg)))))))
#+end_src


My tab theme fix is now activated on every theme load, and I no longer have to rely on muscle memory to make Emacs look colour-coherent when changing themes, which I do a lot!! 😀

* DONE Simple Directory and File Creation in Dired :emacs:dired:2024:elisp:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240922201246-emacs--Efficient-Directory-and-File-Management-with-Dired-in-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-09-24 20:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240922201246-emacs--Efficient-Directory-and-File-Management-with-Dired-in-Emacs.jpg
:END:

Today I'll simply delve into two custom functions that I've had in my init file for quite some time, =my/dired-create-directory= and =my/dired-create-empty-file=

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240922201246-emacs--Efficient-Directory-and-File-Management-with-Dired-in-Emacs.jpg]]

I use them frequently enough that I thought they were worth mentioning and they augment my =dired= workflow when mapped to =dired-mode-map= keybindings.

For many years I would create a new file or folder in one of two ways, through the command line, or a GUI file explorer (with either a click in or bound F2 to edit the name), Emacs comes with it's own directory manager so why not augment it with these features?

What about =find-file= I hear you say?, just press C-x C-f. This will prompt for a filename using the current directory of the current buffer and if you type a unique name it will create the file for you.  Unfortunately though this will not always work in a simple predictable manner when the minibuffer completion mechanism kicks in.

*my/dired-create-directory*

This custom function simplifies creating a new directory by prompting for a name in the minibuffer, bypassing the default completion mechanism to avoid unwanted name suggestions.

#+begin_src emacs-lisp
(defun my/dired-create-directory ()
  "Wrapper to dired-create-directory to avoid minibuffer completion."
  (interactive)
  (let ((search-term
         (read-from-minibuffer "Dir : ")))
    (dired-create-directory search-term)))
#+end_src

- *Purpose:* This function is a wrapper around the =dired-create-directory= function, designed to avoid the potential confusion of minibuffer completion and directly ask for the directory name.
- *Usage:* When invoked, it prompts the user to input a directory name and creates it using the =dired-create-directory= function.

*my/dired-create-empty-file*

Similarly, this custom function facilitates the creation of an empty file by asking for the filename in the minibuffer without the default completion.

#+begin_src emacs-lisp
(defun my/dired-create-empty-file ()
  "Wrapper to dired-create-empty-file to avoid minibuffer completion."
  (interactive)
  (let ((search-term
         (read-from-minibuffer "File : ")))
    (dired-create-empty-file search-term)))
#+end_src

- *Purpose:* This function wraps around =dired-create-empty-file=, providing a straightforward prompt for creating a new file.
- *Usage:* When triggered, it asks the user to input a file name and then creates an empty file with that name.

These functions are bound to =dired-mode-map= as follows:

- =_=: Create an empty file using =my/dired-create-empty-file=
- =+=: Create a new directory using =my/dired-create-directory=

This gives me a good ergonomic LShift+<Right hand of number row> combination and is therefore not too taxing on the hands and each key command are just next to each-other to emphasize their similar nature.

In addition the dired mode map keybinding for creating a new directory is bound to + so there is consistency there too.

I suspect there are probably many other ways to achieve this functionality in Emacs, in this case I am specifically relying on =dired= function calls here but there is also the =make-directory= function and the =shell-command= for example if you want to drop in to using the operating systems tool set.

* DONE Adding Disk Usage Reporting to Emacs Dired :emacs:elisp:dired:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240918092253-emacs--Adding-Disk-Usage-Reporting-to-Emacs-Dired-Mode
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-09-18 09:30>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240918092253-emacs--Adding-Disk-Usage-Reporting-to-Emacs-Dired-Mode.jpg
:END:

Just a quick one today.  One of the great strengths of Emacs is its extensibility, I have mentioned before in adding the ability to disk report on the size of a directory in =dired= but I thought I would quickly revisit the topic, demonstrating the function I currently use.

#+hugo: more

This functionality will allow you to run disk usage reports directly within Dired, using the =du -hc= command. This will make it easier to figure out how much space directories are taking up.

The aim of this function is to run the Linux command =du -hc= on the directory currently under the cursor in Dired mode. The command =du -hc= provides a human-readable summary of disk usage for the specified directory.

Here's the function that accomplishes this task:

#+begin_src elisp
(defun my/dired-du ()
  "Run 'du -hc' on the directory under the cursor in Dired."
  (interactive)
  (let ((current-dir (dired-get-file-for-visit)))
    (if (file-directory-p current-dir)
        (dired-do-async-shell-command "du -hc" nil (list current-dir))
      (message "The current point is not a directory."))))
#+end_src

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240918092253-emacs--Adding-Disk-Usage-Reporting-to-Emacs-Dired-Mode.jpg]]

and that is it!

* DONE New Package arscript-mode :package:emacs:artrage:arscript:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240906074332-emacs--New-Package-arscript-mode
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-09-07 08:55>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240906074332-emacs--New-Package-arscript-mode.jpg
:END:

As an avid ArtRage user for almost 10 years I have in the past delved into the subtle art of editing arscript files:

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240906074332-emacs--New-Package-arscript-mode.jpg]]

#+begin_quote
ArtRage arscript files are specialized script files used by the ArtRage painting software to automate and record various painting actions and effects. These files encapsulate sequences of drawing commands, tool selections, color settings, and other actions that can be replayed to recreate the painting process. The arscript format includes structured elements such as keywords, modifiers, structured tags, and numerical values, allowing for detailed specification of both high-level actions and granular details like brush strokes and layer manipulations. The format aims to facilitate complex artistic workflows by enabling repeatable and shareable painting routines, making it an essential tool for digital artists using ArtRage.
#+end_quote

They are designed to me modifiable, so what better way to modify them than with Emacs!

I created an =arscript= major mode with the idea to eventually add text manipulation functions to tweak a painting playback.

** Summary

=arscript-mode= is an Emacs major mode designed to facilitate the editing of arscript files, providing syntax highlighting and other useful editing features tailored specifically for the arscript file format.

** Screenshot

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/arscript-mode-00.jpg]]

** Links

https://www.artrage.com

https://www.artrage.com/manuals/scripts/

https://www.artrage.com/manuals/scripts/script-editing-tips/artrage-scripting-guide/

** Whats New
*** v0.1.0

First version

** Features

- Syntax highlighting for arscript-specific keywords, modifiers, and structures.
- Custom indentation logic for arscript code blocks.
- Auto-detection of .arscript files to automatically enable the mode.

** Installation
*** use-package (MELPA)

#+begin_src elisp
(use-package arscript-mode)
#+end_src

*** use-package (emacs 30+) directly from github

Put the following into your emacs init file:

#+begin_src elisp
(use-package arscript-mode
  :vc (:fetcher github :repo "captainflasmr/arscript-mode"))
#+end_src

*** From source

Download the `.el` file and place it in your Emacs `load-path` or in a specific source directory "~/source/repos/arscript-mode"

Then either manually load it or add it to your configuration to be loaded at startup.

#+begin_src elisp
(require 'arscript-mode)
#+end_src

OR

#+begin_src elisp
(use-package arscript-mode
  :load-path "~/source/repos/arscript-mode")
#+end_src

** Usage

Opening any .arscript file with Emacs should automatically enable =arscript-mode=, providing you with syntax highlighting and indentation support for editing arscript files.

Example arscript file:

#+begin_src arscript
//===========================================================================
//===========================================================================
//                            ArtRage Script File.
//===========================================================================
//===========================================================================


//===========================================================================
// Version Block - Script version and ArtRage version:
//===========================================================================

<Version>
   ArtRage Version: ArtRage 3 4
   ArtRage Build: 4.5.3
   Professional Edition: Yes
   Script Version: 1
</Version>


//===========================================================================
// Header block - Info about the painting/person who generated this script:
//===========================================================================

<Header>
   // === Project data
   Painting Name: "Willow"
   Painting Width: 2456
   Painting Height: 2206
   Painting DPI: 200
   Mask Edge Map Width: 1280
   Mask Edge Map Height: 800
   // === Author data
   Author Name: ""
   Script Name: ""
   Comment: ""
   Script Type: ""
   Script Feature Flags: 0x000000034
</Header>


//===========================================================================
// ArtRage project features. Sets the startup state of the script:
//===========================================================================

<StartupFeatures>
   Script Startup Features: {
   }// End of Script startup feature binary data.
</StartupFeatures>


//===========================================================================
// Script data follows:
//===========================================================================

<Events>
   Wait: 0.000s	EvType: Command	CommandID: CID_SetClearCanvas	ParamType: flag	Value: { true }
   Wait: 14.031s	EvType: Command	CommandID: LoadReferenceImage	Idx: 0	Reference Image: {
   }// End of reference image binary data.
   Wait: 2.694s	EvType: Command	CommandID: ReferenceImageXForm	Idx: 0	Loc: (0.182031, 0.2)	Size: (320, 236)	Scale: 1	Rot: 0	Off: (0, 0)
   Wait: 0.682s	EvType: Command	CommandID: ReferenceImageXForm	Idx: 0	Loc: (0.179688, 0.45)	Size: (320, 236)	Scale: 1	Rot: 0	Off: (0, 0)
   Wait: 2.298s	EvType: Command	CommandID: ReferenceImageXForm	Idx: 0	Loc: (0.180078, 0.45)	Size: (803, 600)	Scale: 1	Rot: 0	Off: (0, 0)
   Wait: 2.678s	EvType: Command	CommandID: ReferenceImageXForm	Idx: 0	Loc: (0.279297, 0.395)	Size: (803, 600)	Scale: 1	Rot: 0	Off: (0, 0)
   Wait: 7.316s	EvType: Command	CommandID: ReferenceImageXForm	Idx: 0	Loc: (0.278906, 0.395)	Size: (864, 646)	Scale: 1	Rot: 0	Off: (0, 0)
   Wait: 12.245s	EvType: Command	CommandID: ReferenceImageXForm	Idx: 0	Loc: (0.278906, 0.395)	Size: (139, 100)	Scale: 1	Rot: 0	Off: (0, 0)
   Wait: 0.000s	EvType: Command	CommandID: SetForeColour	ParamType: Pixel	Value: { 0x0FF7386A0 }
   Wait: 3.341s	EvType: Command	CommandID: CID_SetClearCanvas	ParamType: flag	Value: { true }
   Wait: 3.819s	EvType: Command	CommandID: ReferenceImageXForm	Idx: 0	Loc: (0.278906, 0.395)	Size: (684, 520)	Scale: 1	Rot: 0	Off: (0, 0)
   Wait: 8.354s	EvType: Command	CommandID: ReferenceImageXForm	Idx: 0	Loc: (0.278906, 0.395)	Size: (161, 119)	Scale: 1	Rot: 0	Off: (0, 0)
   Wait: 1.659s	EvType: Command	CommandID: CanvasXForm	Scale: 0.0840503	Rot: 0	Off: (537, 307)
   Wait: 1.123s	EvType: Command	CommandID: CanvasXForm	Scale: 0.0840503	Rot: 0	Off: (497, 259)
   <StrokeEvent>
	   <StrokeHeader>
		   <EventPt>	Wait: 1.116s	Loc: (1054.6, 527.3)	Pr: 0.0521997	Ti: 0.489467	Ro: 1.27568	Fw: 1	Bt: 0	Rv: NO	Iv: NO	</EventPt>
		   <Recorded>	Yes	</Recorded>
		   <RandSeed>	0x000000000, 0x000000000	</RandSeed>
		   <Smooth>	Count:	3
				Loc: (1054.6, 527.3)	Pr: 0.132196	Ti: 1	Ro: 0	Fw: 1	Bt: 0
				Loc: (1086.56, 527.3)	Pr: 0.132196	Ti: 1	Ro: 0	Fw: 1	Bt: 0
				Loc: (1102.54, 527.3)	Pr: 0.132196	Ti: 1	Ro: 0	Fw: 1	Bt: 0
		   </Smooth>
		   <PrevA>	Loc: (-679.912, 774.652)	Pr: 0.135925	Ti: 1	Ro: 0	Fw: 1	Bt: 0	</PrevA>
		   <PrevB>	Loc: (-505.365, 600.105)	Pr: 0.174106	Ti: 1	Ro: 0	Fw: 1	Bt: 0	</PrevB>
		   <OldHd>	Loc: (1086.56, 527.3)	Pr: 0	Ti: 0.477897	Ro: 1.27511	Fw: 1	Bt: 0	Dr: (-0.919609, -0.392834)	Hd: (0.392834, -0.919609)	</OldHd>
		   <NewHd>	Loc: (1054.6, 527.3)	Pr: 0	Ti: 0.489467	Ro: 1.27568	Fw: 1	Bt: 0	Dr: (-0.99682, -0.0796825)	Hd: (0.0796825, -0.99682)	</NewHd>
	   </StrokeHeader>
	   Wait: 0.000s	Loc: (1054.6, 535.29)	Pr: 0.0569451	Ti: 0.489467	Ro: 1.27568	Fw: 1	Bt: 0	Rv: NO	Iv: NO
	   Wait: 0.002s	Loc: (1054.6, 543.279)	Pr: 0.0237271	Ti: 0.489467	Ro: 1.27568	Fw: 1	Bt: 0	Rv: NO	Iv: NO
   </StrokeEvent>
#+end_src

** Customization

Currently, =arscript-mode= provides a basic set of features optimized for general usage. Future versions may include customizable options based on user feedback.

** Contributing

Contributions to =arscript-mode= are welcome! Whether it's bug reports, feature suggestions, or code contributions, feel free to reach out or submit pull requests on GitHub.

** ROADMAP :roadmap:
*** TODO review syntactical keyword highlighting based on contents of arscript pdf manual
*** TODO add text transformation functions to affect arscript and hence ArtRage playback
** Alternatives

As far as I can tell this is the first Emacs major mode supporting the arscript format.

* DONE Streamlining eshell with popper, capf-autosuggest, and Enhanced Autocompletion :eshell:emacs:elisp:capf:cape:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240827210257-emacs--Enhancing-Eshell-To-Be-More-Fishy
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-08-30 11:20>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240827210257-emacs--Enhancing-Eshell-To-Be-More-Fishy.jpg
:END:

In this post, I will describe the small enhancements and tweaks I have applied to =eshell= to make it feel more like a typical linux terminal using the fish shell and especially the inline autosuggestion feature that fish has out-of-the-box.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240827210257-emacs--Enhancing-Eshell-To-Be-More-Fishy/2024-08-30-08-27-30.jpg]]

For clarity, the autosuggestions in fish enable autocompletion suggestion previews as you type, for example :

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240827210257-emacs--Enhancing-Eshell-To-Be-More-Fishy/2024-08-30-08-52-32.jpg]]
#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240827210257-emacs--Enhancing-Eshell-To-Be-More-Fishy/2024-08-30-08-52-48.jpg]]
#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240827210257-emacs--Enhancing-Eshell-To-Be-More-Fishy/2024-08-30-08-52-57.jpg]]

Fish will suggest a single command to the right of the cursor dynamically in grey, its just like the terminal built-in readline C-r/C-s, but inline and for your most recent command based on the text input. As a bonus of course, fish will have readline built in and therefore a familiar Emacs keybinding =C-e= will complete the suggested completion for you!

Over the years, I have progressed through possibly all the terminal shells, from csh and ksh through to bash and zsh, and now I use fish. Similarly to the popularity of more native-based light-weight Emacs plugins, such as vertico, corfu, and cape, the fish shell is lightweight and targets important functions right out of the box.

For years, I relied on readline shell functionality, with the keybinding C-r bringing up a command history which I could navigate. It is much like vertico, and although efficient, I now prefer the fish method of inline completion autosuggestion preview as I feel I can get to my desired commands faster.

With eshell, there is the native completion TAB based system but it is clunky, so lets see how we can make it more fishy! 😀 🐠

** Inline Fish-like autosuggestion

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240827210257-emacs--Enhancing-Eshell-To-Be-More-Fishy/2024-08-30-07-51-34.jpg]]

I'm going to dive straight in to enabling inline autosuggest preview for =eshell= to emulate Fish-like inline completion as described earlier.  I use a package called =capf-autosuggest=:

#+begin_src elisp
(use-package capf-autosuggest
  :hook
  (eshell-mode . capf-autosuggest-mode))
#+end_src

There are other similar packages out there, but so far I have found this to be the best and seems to work out-of-the-box. It is shell (comint) based, so it won't work anywhere else in Emacs, but that is fine for me as I have plenty of other completion mechanisms to choose from.

Of course you will need to have an =eshell= history to use effectively, but it will also autosuggest commands found on your PATH.

/Note : that as of Emacs 30 there is a new function - =completion-preview-mode= which looks as though it does something similar to =capf-autosuggest= but for all buffers!/

#+begin_quote
This mode automatically shows and updates the completion preview according to the text around point.
#+end_quote

I haven't tested this fully yet but when Emacs 30 comes out I will probably have a closer look.

** Creating Custom eshell Buffers

There are other =eshell= tweaks I make to generally improve my workflow and I will now describe how I create eshell buffers. Below is a function that allows the creation of eshell buffers with defined names, making it easier to manage multiple shell sessions.

#+begin_src elisp
(defun my/shell-create (name)
  "Create a custom-named eshell buffer with NAME."
  (interactive "sName: ")
  (eshell 'new)
  (let ((new-buffer-name (concat "*eshell-" name "*")))
    (rename-buffer new-buffer-name t)))

(global-set-key (kbd "M-o s") #'my/shell-create)
#+end_src

The reason for this is that I gain greater control over eshell buffer naming, which makes using tools like Popper (see below) and creating multiple eshells simpler. For example, opening an initial eshell in Emacs is easy, just run =eshell=, however, to create another unique eshell, you must remember to pass in a universal argument (which I always forget); otherwise, you will just switch to the existing eshell.  So this function will always create a new shell, I can always switch between eshell buffers as normal through Emacs anyway.

** Toggling eshell with Popper

Popper provides a pop-up window manager, making it easy to toggle eshell in and out of view. It has been a recent discovery, but now I can't live without it.

#+begin_src elisp
(use-package popper
  :init
  (setq popper-reference-buffers
        '("\\*eshell.*"
          flymake-diagnostics-buffer-mode
          help-mode
          compilation-mode))
  (popper-mode 1)
  (popper-echo-mode 1)
  :custom
  (popper-window-height 15))

(bind-key* (kbd "C-;") #'popper-toggle)
#+end_src

Since I control my eshell naming, I can set up Popper with the requisite regex to pop up eshell when it is opened or created.

What I like about Popper is that it does what it says: it pops windows in and out. I also like to pop Flymake, Help, and Compilation windows, this keeps Emacs clean and uncluttered, and if, for example, I build something, if I need a terminal, or need some linting diagnostics, I can just quickly pop in and out and switch between each pop.

As a note, if more than one window has been "poppered" then switching between each "pop" is easy through a keybinding M-<number>, which is something I also use all the time.

** General eshell Configuration

Here is my general eshell setup. I don't think there is anything controversial here, but as you can see, I have enabled a hook to my own shell setup function, and yes, I know I could add capf-autosuggest-mode to this, but for clarity in this post, I kept it specifically in the capf-autosuggest section.

#+begin_src elisp
(use-package eshell
  :config
  (setq eshell-scroll-to-bottom-on-input t)
  (setq-local tab-always-indent 'complete)
  (setq eshell-history-size 10000)
  (setq eshell-save-history-on-exit t) ;; Enable history saving on exit
  (setq eshell-hist-ignoredups t) ;; Ignore duplicates
  :hook
  (eshell-mode . my/eshell-hook))
#+end_src

Yes, I know, the history size is ridiculous! (default is 128) but why not build up a huge collection of my past commands for a more robust autosuggest mechanism?!

** eshell completion using consult

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240827210257-emacs--Enhancing-Eshell-To-Be-More-Fishy/2024-08-30-08-28-45.jpg]]

What about other completion mechanisms?, for example emulating the C-r/C-s readline functionality?

For a while I used consult to bring up a =completing-read= searchable eshell history via =consult-history=, and although it does work well I found I wasn't really using it. However, I do still have it enabled:

#+begin_src elisp
(define-key eshell-hist-mode-map (kbd "M-r") #'consult-history))
#+end_src

** UI completion with Corfu and Cape

Now for some completion UI setup to augment the capf-autosuggest functionality - we are in Emacs after all!

In this case I am choosing to use =corfu= but =company= is another option.  The idea here is to bring up a typical =corfu= completion popup UI when typing, for example:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240827210257-emacs--Enhancing-Eshell-To-Be-More-Fishy/2024-08-30-08-27-30.jpg]]

Here you can see it working along-side =capf-autosuggest=

Here is the config:

#+begin_src elisp
(use-package cape)

(defun my/eshell-hook ()
  "Set up eshell hook for completions."
  (interactive)
  (setq-local completion-styles '(basic partial-completion))
  (setq-local corfu-auto t)
  (corfu-mode)
  (setq-local completion-at-point-functions
              (list (cape-capf-super
                     #'pcomplete-completions-at-point
                     #'cape-history)))
  (define-key eshell-hist-mode-map (kbd "M-r") #'consult-history))
#+end_src

I decided to have a simple set of completion styles, none of those fancy fuzzy, orderless, flex shenanigans as I can generally string a few characters of the command I want to use to quickly generate a suitable matching command.

=cape= at this point becomes useful as it exposes the function =cape-history= to =corfu=.  Once set up, typing in eshell now brings up the completion popup and you would use as expected.  This for me has now replaced =consult-history= as it feels more integrated and faster for my workflow while producing the same functionality.

/Note: I have explicitly turned on corfu autocompletion as in general I like to have it turned off. I have learnt that things can get tricky and laggy with autocompletion turned on when using eglot and communicating over an LSP, so I prefer to bind to a key and call the UI on demand.  Also I'm a little old school in that I don't like a busy work window, I'm not used to seeing a dynamic autocompletion appear when I am coding and would rather manually leverage this functionality when required./

** Combining all of it!

The =corfu= functionality described above can run nicely along-side =capf-autosuggest=.  For some, this may seem cluttered and you may want to choose one or the other, but for me, for the moment, this suits my workflow.

** Conclusion

By integrating =popper=, =capf-autosuggest=, =corfu=, and =cape= into my eshell setup, I think I may have finally been able to almost completely fully transition terminal usage to emacs through =eshell=.

In addition, if I am running Emacs on a system that doesn't have the fish shell available, for example windows, or a restricted linux development environment, then eshell can now increase my efficiency on the command line.

* DONE Syncing Tab Bar To Theme :emacs:elisp:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240817082349-emacs--Syncing-Tab-Bar-To-Theme
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-08-24 11:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/2024-08-24-10-55-54.jpg
:END:

Using tabs as part of my workflow has enabled a nice encapsulation and collection of files per tab that I can quickly switch to.

#+hugo: more

An issue I consistently run into however is tab theming. I'm a constant theme switcher, not just in Emacs but also operating system wide, and I often switch wallpapers.

Unfortunately, with the advent of tabs in version 27.1, many Emacs themes lack styles for the new tab faces, resulting in a wonky disjointed appearance.

For example:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/2024-08-24-10-55-54.jpg]]

Elisp can come to the rescue again of course, this is my attempt at making the tabs fit in a little better with an incompatible theme:

#+begin_src elisp
(defun my/sync-tab-bar-to-theme ()
  "Synchronize tab-bar faces with the current theme."
  (interactive)
  (let ((default-bg (face-background 'default))
        (default-fg (face-foreground 'default))
        (inactive-fg (face-foreground 'mode-line-inactive)))
    (custom-set-faces
     `(tab-bar ((t (:inherit default :background ,default-bg :foreground ,default-fg))))
     `(tab-bar-tab ((t (:inherit default :background ,default-fg :foreground ,default-bg))))
     `(tab-bar-tab-inactive ((t (:inherit default :background ,default-bg :foreground ,inactive-fg)))))))
#+end_src

which does its best to fit tab themes to the loaded theme, to give something like:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/2024-08-24-10-56-26.jpg]]

There is a bit of logic here, but essentially, for the whole tab-bar theming, I just pick up the foreground and background faces defined in the theme and for the selected tab =tab-bar-tab=, the default theme foreground switches to ensure the selected tab will always stand out.

For inactive tabs, I set the foreground to that used in the =mode-line-inactive=.

Now that the =defun= is available, how to activate it? My first thought was to add a hook for when a theme is loaded, but there doesn't seem to be such a feature!?  I also tried advising around `load-theme`, but that didn’t go well either, it worked for themes that were not loaded, but for those that were, a change in state was not detected, and the tab theme tweak was not applied.

My current solution is simply to make the function interactive and build up some muscle memory to run it every time I switch themes and the tab theming looks wonky.  I guess I could wrap around =load-theme= with my own theme loading function, then activate =my/sync-tab-bar-to-theme= afterwards, but I would rather keep the default theme selection function and run this function later.

P.S I also have a little idea to perhaps add this functionality to [selected-window-accent-mode](https://github.com/captainflasmr/selected-window-accent-mode) as this is related to clearly defining a selected element in Emacs.

* DONE Integrate Pywal Colors into Selected-Window-Accent-Mode for Wallpaper Accent Matching in Emacs :selected_window_accent_mode:pywal:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240816203918-emacs--selected-window-accent-mode-added-pywal-accent-based-on-wallpaper
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-08-16 20:49>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240816203918-emacs--selected-window-accent-mode-added-pywal-accent-based-on-wallpaper.jpg
:END:

I have updated my emacs package [[https://github.com/captainflasmr/selected-window-accent-mode][*selected-window-accent-mode*]]

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240816203918-emacs--selected-window-accent-mode-added-pywal-accent-based-on-wallpaper.jpg]]

#+begin_quote
The Selected Window Accent Mode is an Emacs package designed to visually distinguish the currently selected window by applying a unique accent color to its fringes, mode line, header line, and margins.
#+end_quote

** v0.9.0 <2024-08-10>

Added Pywal color integration to selected-window-accent-mode to allow the accent color to be consistent with the wallpaper of the operating system.

#+begin_quote
Pywal is a tool on linux that generates color schemes from images, allowing users to apply these colors to their desktop and application themes for a cohesive and dynamic look.
#+end_quote

*Note: will only work on linux.*

- Introduced `selected-window-accent-use-pywal` option to use a Pywal-generated color palette.
- Update logic in `selected-window-accent` function to use Pywal color if enabled.
- Require `json` package for handling Pywal palette.

Example use:
#+begin_src elisp
(setq selected-window-accent-use-pywal t)
#+end_src

When enabled, =color1= is selected as the accent color, taken from the file : =~/.cache/wal/colors.json= which is a generic color file typically generated by pywal.

This means that the accent color can be more tied in with the current wallpaper once pywal is connected to the wallpaper change mechanism of your operating system.

Note that this feature will require an external pywal generation step, triggered on wallpaper change, examples given below.

See below for an example =colors.json= file

Technically any tool that can write to a json file in a similar format will have a carry through affect on the accent color associated with this package.  Here is an example :

#+begin_src js-json
{
    "wallpaper": "/home/jdyer/.last_wallpaper.jpg",
    "alpha": "100",

    "special": {
        "background": "#0d1a05",
        "foreground": "#c8cfdb",
        "cursor": "#c8cfdb"
    },
    "colors": {
        "color0": "#0d1a05",
        "color1": "#8FA944",
        "color2": "#165E97",
        "color3": "#5C7391",
        "color4": "#748AA6",
        "color5": "#7498C4",
        "color6": "#8D9BB1",
        "color7": "#c8cfdb",
        "color8": "#8c9099",
        "color9": "#8FA944",
        "color10": "#165E97",
        "color11": "#5C7391",
        "color12": "#748AA6",
        "color13": "#7498C4",
        "color14": "#8D9BB1",
        "color15": "#c8cfdb"
    }
}
#+end_src

On linux, install =python-pywal= using your package manager of choice.

At which point you can generate a =colors.json= with the following commands:

#+begin_src bash
wal -c
wal -i ~/.last_wallpaper.jpg -q -n
#+end_src

*** Wallpaper Change Example

Changing a wallpaper and hooking =pywal= up accordingly, which technically should work for both Wayland and X11.

#+begin_src bash
#!/bin/bash

wallpaper_path="$(find ~/wallpaper-dir -type f | shuf -n 1)"
echo $wallpaper_path > ~/.last_wallpaper_path
cp -f $wallpaper_path ~/.last_wallpaper.jpg

if [[ $XDG_SESSION_TYPE == "x11" ]]; then
    feh --bg-scale "$wallpaper_path"
fi

if [[ $XDG_SESSION_TYPE == "wayland" ]]; then
    swww img "$wallpaper_path" --transition-step 20 --transition-fps=20
fi

# lets run pywal for colour scheme generation
wal -c
wal -i ~/.last_wallpaper.jpg -q -n
#+end_src

* DONE Ready Player Mode different Utilities for Video and Audio! :ready_player:emacs:elisp:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240811115938-emacs--Ready-Player-Mode-Different-Utilities-for-video-and-audio
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-08-11 16:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240810072449-emacs--Ready-Player-Mode-Tweak.jpg
:END:

Regarding my previous post, you can now disregard my little Frankensteinian elisp effort!:

#+hugo: more

#+begin_export md
[Ready Player Mode with a little elisp Tweak]({{< ref
"/emacs/20240810072449-emacs--Ready-Player-Mode-Tweak.md" >}})
#+end_export

Thanks to a quick turnaround from Author: Alvaro Ramirez https://xenodium.com URL: https://github.com/xenodium/ready-player Version: 0.4.1 now directly caters for the ability to use different utilities for video and audio, as thus:

#+begin_src elisp
(use-package ready-player
  :init
  (ready-player-mode 1)
  :custom
  (ready-player-thumbnail-max-pixel-height 200)
  (ready-player-autoplay nil)
  (ready-player-repeat t)
  (ready-player-shuffle t)
  (ready-player-open-playback-commands
   '((ready-player-is-audio-p "mplayer")
     (ready-player-is-video-p "mpv"))))
#+end_src

Really nice!! 😀

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240810072449-emacs--Ready-Player-Mode-Tweak.jpg]]

* DONE Ready Player Mode with a little elisp Tweak :ready_player:emms:emacs:elisp:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240810072449-emacs--Ready-Player-Mode-Tweak
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-08-10 09:42>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240810072449-emacs--Ready-Player-Mode-Tweak.jpg
:END:

I'm really enjoying *ready-player* at the moment, so much so I think it might end up replacing *emms*.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240810072449-emacs--Ready-Player-Mode-Tweak.jpg]]

I listen to music in a very simple, almost old-fashioned way, album by album, and I have my music collection well organized, with each album in a separate directory and in a way, =emms= was a little too much.

=ready-player= is well integrated with dired, so opening an audio file, for example, will kickstart the listening process for me.  I like to have shuffle on (=ready-player-shuffle=), and with =ready-player-repeat= if there is more media to play in the current directory then it will enter a continuous play mode.

Here are my current settings:

#+begin_src elisp
(use-package ready-player
  :init
  (ready-player-mode 1)
  :custom
  (ready-player-thumbnail-max-pixel-height 200)
  (ready-player-autoplay nil)
  (ready-player-repeat t)
  (ready-player-shuffle t)
  (ready-player-open-playback-commands
   '(
     ("mpv" "--audio-display=no")
     ("mplayer")
     ("ffplay")
     ("vlc")
     )))
#+end_src

The only little issue I have run into so far (and I encountered something similar with =emms=) is to figure out which media player back-end works best with my set-up, I am running SwayWM on Arch.

For some reason =emms= would only run well with =vlc= (found by trial and error).  With =ready-player= the default =mpv= worked well in most cases except it wouldn't automatically move on to the next audio track when =ready-player-repeat= was set.

I am happy with =ready-player= opening videos through =mpv= by default and would only really want to ever use =mpv= for video playback.

So first things first, lets establish which back-end gives me a continuous audio playback.

With a little trial and error (simply swapping around the back-ends) I found that =mplayer= was the one that worked for me, =mplayer= can play videos too but my muscle memory is so mpv-centric that I always want to be using mpv for video playback.

With =ready-player= as far as I can tell there is just a single list of potential playback commands which applies to all media types.  =ready-player= is in its early stages of development so I wouldn't be surprised if at some stage this might get added for more flexibility/customization.  But for me it doesn't really matter and in fact gives me the opportunity to flex my elisp know-how.

Can I write something to overcome this issue?

Emacs is essentially just an elisp machine anyway, so lets write some elisp to augment the current =ready-player= functionality to suit my multiple playback-end needs, here is some elisp:

#+begin_src elisp
(defun set-ready-player-commands ()
  "Set `ready-player-open-playback-commands` based on file extension."
  (let ((file-extension (file-name-extension (buffer-file-name))))
    (setq ready-player-open-playback-commands
          (cond
           ((member file-extension '("mp4" "mkv" "mov" "avi"))
            '(("mpv" "--audio-display=no")
              ("mplayer")
              ("ffplay")
              ("vlc")))
           ((equal file-extension "mp3")
            '(("mplayer")
              ("mpv" "--audio-display=no")
              ("ffplay")
              ("vlc")))
           (t
            '(("mpv" "--audio-display=no")
              ("vlc")
              ("ffplay")
              ("mplayer")))))))

(add-hook 'find-file-hook 'set-ready-player-commands)

#+end_src

Simply, I just added some extra =ready-player= setup whenever a buffer is loaded from a file, essentially when I select it from dired.

I set the playback commands based on the extension, so for a video file it can use =mpv=, for an mp3 it prefers =mplayer=, with a fallback for any other type of file.  I guess I could have been a little more flexible in defining a wider range of audio file, but I generally only listen to mp3.

With that addressed, =ready-player= now seems to give me much less friction than =emms=, with =emms= I would have to perform roughly the following steps to even begin listening to a music album:

- first initialise - add files so emms can load in metadata
- browse to select music album
- push to a playlist
- jump to playlist to perform track functions

I would have to remember =emms= commands, or build up muscle memory, but with =ready-player= I just need to navigate to the relevant music folder using =dired=, open a file and I'm ready to go!, and the front-end is like any standard media player which makes more sense to me.

If I want to modify playback then I'm quite happy to jump to the playback buffer which can be accomplished quickly through vertico by fuzzy finding "ready", or by pushing =ready-player= to its own tab.

I think I will continue to play around with this cool little package.

* TODO Managing-Subversion-Importing-To-Git :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240806210058-emacs--Managing-Subversion-Importing-To-Git
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-08-06 21:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240806210058-emacs--Managing-Subversion-Importing-To-Git.jpg
:END:

#+hugo: more

** Create a Local Subversion Repository on Linux
*** Prerequisites

Make sure you have Subversion installed on your Linux system. You can install it using the package manager for your distribution. For example, on Debian or Ubuntu, you can use:

#+BEGIN_SRC shell
sudo apt update
sudo apt install subversion
#+END_SRC

On Red Hat-based distributions like CentOS or Fedora, you might use:

#+BEGIN_SRC shell
sudo dnf install subversion
#+END_SRC

*** Steps to Create a Local SVN Repository
**** Create the Repository Directory

Create a directory where you want to store your SVN repository. For example:

#+BEGIN_SRC shell
mkdir ~/svn_repos
#+END_SRC

**** Create the Repository

Use the =svnadmin= tool to create a new repository within the directory you just created:

#+BEGIN_SRC shell
svnadmin create ~/svn_repos/my_project
#+END_SRC

**** Import Initial Project Files (Optional)

If you already have a project you want to import into the repository, navigate to the project directory and run:

#+BEGIN_SRC shell
svn import . file:///home/your_username/svn_repos/my_project -m "Initial import"
#+END_SRC

Replace =/home/your_username= with your actual home directory path.

*** Use the Repository
**** Checkout the Repository

Checkout a working copy from the repository to your local directory:

#+BEGIN_SRC shell
svn checkout file:///home/your_username/svn_repos/my_project ~/my_working_copy
#+END_SRC

**** Add Files to the Working Copy

Navigate to your working copy directory and add files or directories:

#+BEGIN_SRC shell
cd ~/my_working_copy
echo "Hello, SVN!" > sample.txt
svn add sample.txt
#+END_SRC

**** Commit Changes

Commit your changes to the SVN repository:

#+BEGIN_SRC shell
svn commit -m "Added sample.txt"
#+END_SRC

**** Update Working Copy

To update your working copy with the latest changes from the repository, use:

#+BEGIN_SRC shell
svn update
#+END_SRC

*** Common SVN Commands

- Add a file or directory:

#+BEGIN_SRC shell
svn add <file_or_directory>
#+END_SRC

- Remove a file or directory:

#+BEGIN_SRC shell
svn delete <file_or_directory>
#+END_SRC

- View the status of your working copy:

#+BEGIN_SRC shell
svn status
#+END_SRC

- See the log of changes:

#+BEGIN_SRC shell
svn log
#+END_SRC

With these steps, you should be able to set up a local SVN repository and start using it for version control on your Linux system.

** Emacs Tools to Manage an SVN Repository
*** `psvn.el`

- **Description**: =psvn.el= is a popular and comprehensive Subversion interface for Emacs. It offers various features to manage SVN repositories directly within Emacs.
- **Installation**: It may come pre-installed with some Emacs distributions, but if not, you can download it from its [[http://www.xsteve.at/prg/emacs/psvn.el][repository]].
  To use =psvn.el=, add the following to your Emacs configuration:

#+BEGIN_SRC emacs-lisp
(autoload 'svn-status "psvn" "Run `svn status`." t)
#+END_SRC

- **Usage**: Use =M-x svn-status= to start interacting with your SVN repository.

*** Built-in VC (Version Control) Mode

- **Description**: Emacs comes with a built-in version control (VC) mode that supports various version control systems, including SVN.
- **Configuration**: No additional configuration is needed to use =vc= mode for SVN; it should work out of the box.
- **Usage**: When you open a file in a directory under SVN control, you can use various VC commands:
  - =C-x v v=: Perform the next appropriate version control operation (e.g., check-in, check-out).
  - =C-x v i=: Register the file with the version control system.
  - =C-x v d=: Display the status of files in the directory.
  - =C-x v ~ <revision>=: Check out a specific revision.

*** `dsvn.el`

- **Description**: =dsvn.el= is another Subversion front-end for Emacs that gives a =dired=-like interface for managing SVN repositories.
- **Installation**: You can install =dsvn= via MELPA by adding the following to your configuration if you're using the package manager:

#+BEGIN_SRC emacs-lisp
(use-package dsvn
  :ensure t)
#+END_SRC

- **Usage**: Use =M-x svn-update= to update the SVN repository, =M-x svn-status= for the status of the repository, and other SVN-related commands.

*** `magit-svn` (if using Magit)

- **Description**: If you are already using =magit= for Git repositories but also need to handle SVN repositories, =magit-svn= can be useful. It integrates SVN support into =magit=.
- **Installation**: You'll need to install both =magit= and =magit-svn=.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t)

(use-package magit-svn
  :ensure t
  :after magit
  :config
  (magit-svn-mode 1))
#+END_SRC

- **Usage**: This package provides SVN support within the familiar Magit interface. You can initialize it within a repository with =M-x magit-svn=.

*** `ISVN` (Interactive SVN)

- **Description**: ISVN provides an interactive interface for Subversion within Emacs.
- **Installation**: You can install ISVN from the Emacs Wiki or its dedicated repository.
- **Usage**: You can interact with your repository using intuitive keybindings specific to ISVN.

*** Example Configuration

Here’s an example of a minimal =.emacs= or =init.el= configuration to get started with the recommended tools:

#+BEGIN_SRC emacs-lisp
;; Use built-in VC Mode for SVN
(setq vc-handled-backends '(SVN Git))

;; Load PSVN
(autoload 'svn-status "psvn" "Run `svn status`." t)

;; Example keybinding for PSVN
(global-set-key (kbd "C-x s") 'svn-status)

;; Optional: Enable magit-svn if you're using Magit
(use-package magit
  :ensure t)

(use-package magit-svn
  :ensure t
  :after magit
  :config
  (magit-svn-mode 1))

;; Optional: Use dsvn if preferred
(use-package dsvn
  :ensure t)
#+END_SRC

** Clone a Git repository from a local Subversion repository

Yes, you can use a locally checked out Subversion repository as the source for ~git svn clone~. However, it requires setting up a temporary local Subversion server if you want to do this without re-checking out from the central repository. Here’s how you can achieve this:

*** 1. Install a Subversion Server

Ensure you have ~svnserve~ installed. On Ubuntu, you can install it with:

#+BEGIN_SRC sh
sudo apt-get update
sudo apt-get install subversion
#+END_SRC

*** 2. Start Subversion Server

Run ~svnserve~ to serve your local repository. You need to specify the root directory where your Subversion repository is located. For example:

#+BEGIN_SRC sh
svnserve -d -r /home/jdyer/source/working
#+END_SRC

This starts the server as a daemon (~-d~) and sets the root of the served files to ~ /home/jdyer/source/working~ (~-r~).

*** 3. Using ~git svn clone~

Now, you can use ~git svn clone~ to clone the repository via the ~svn://~ protocol. Assuming your project in the Subversion repository is called ~my_project~:

#+BEGIN_SRC sh
git svn clone svn://localhost/my_project my_project.git
#+END_SRC

This command clones the Subversion repository located at ~svn://localhost/my_project~ into a Git repository named ~my_project.git~.

*** Example

Here’s the complete process summarized in a series of commands:

#+BEGIN_SRC sh
# Step 1: Install svnserve if not already installed
sudo apt-get update
sudo apt-get install subversion

# Step 2: Start svnserve, serving your local Subversion repository
svnserve -d -r /home/jdyer/source/working

# Step 3: Clone the repository with git svn
git svn clone svn://localhost/my_project my_project.git
#+END_SRC

*** Stopping the server

Once the cloning process is done, don’t forget to stop the ~svnserve~ process if it’s no longer needed. You can find its process ID and stop it.

#+BEGIN_SRC sh
pkill svnserve
#+END_SRC

*** Note

This approach avoids re-fetching data from a remote Subversion repository and speeds up the conversion process by using the locally checked-out copy. However, be cautious: this setup is quite manual and assumes good familiarity with both SVN and Git tools.

* DONE Efficient File Searching in Emacs: Leveraging completing-read with Customizable Methods :ripgrep:find:emacs:elisp:dired:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240804075952-emacs--Finding-Files-Using-Completing-Read
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-08-04 09:05>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240804075952-emacs--Finding-Files-Using-Completing-Read.jpg
:END:

I thought I would share a little bit of elisp that I've been using for a while now that allows me to quickly find a file. It leverages =completing-read=, allows the selection of the find method and will search recursively.

#+hugo: more

When called you can select which search type you prefer:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240804075952-emacs--Finding-Files-Using-Completing-Read.jpg]]

You can select the built-in =find-name-dired= but as you see I can also choose an external find tool such as =find=, =fd= or =rg= and it should be flexible enough to add in any others by expanding =find-options= in the function below:

#+begin_src elisp
(defun my/find-file ()
  "Find file from current directory in many different ways."
  (interactive)
  (let* ((find-options '(("find -type f -printf \"$PWD/%p\\0\"" . :string)
                         ("fd --absolute-path --type f -0" . :string)
                         ("rg --follow --files --null" . :string)
                         ("find-name-dired" . :command)))
         (selection (completing-read "Select : " find-options))
         (metadata '((category . file)))
         (file-list)
         (file))
    (pcase (alist-get selection find-options nil nil #'string=)
      (:command
       (call-interactively (intern selection)))
      (:string
       (setq file-list (split-string (shell-command-to-string selection) "\0" t))
       (setq file (completing-read (format "Find file in %s: " (abbreviate-file-name default-directory))
                                   (lambda (str pred action)
                                     (if (eq action 'metadata)
                                         `(metadata . ,metadata)
                                       (complete-with-action action file-list str pred)))
                                   nil t nil 'file-name-history)))
      (when file (find-file (expand-file-name file))))))
#+end_src


To be completely honest, I don't really use Emacs' built-in find functions, such as =find-file= and =find-name-dired=. Here are a few reasons why:

- Speed and Efficiency
  - Tools like =fd= and =rg= are incredibly fast and efficient.
  - They allow easy filtering through a simple =.ignore= file configuration.


- Enhanced File Search
  - I can leverage =completing-read= to process the file list.
  - Using =vertico=, I gain the advantage of fuzzy completion, making file search more efficient and user-friendly.


- Alternative Methods
  - I seldom need to find a single file using =find-file=
  - Instead, I rely on bookmarks, =dired= and =recentf=


- Dired Benefits
  - While =find-name-dired= offers the benefits of a =dired= buffer, I generally don't need to perform specific actions on files found this way.
  - Most of the time, I just need to jump to a file quickly.
  - A dired bufer can be generated through =embark-export= anyway when going through a file fuzzy search at any point.


- Customization and Flexibility
  - External tools often provide more customization options, which align better with my workflow.
  - These tools integrate seamlessly with my Emacs setup, enhancing my overall productivity.


By considering these reasons, I've found that external tools better fit my workflow compared to the built-in Emacs find functions when wanting to find a file quickly.

*P.S.* I still have a fondness for the basic =find= command, which I continue to use, particularly on the command line and especially when operating through SSH. However, I still can't remember how to prune directories!, but then who can? 😀

* TODO Integrating CMake with Emacs :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240728172557-emacs--Integrating-CMake-with-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-07-28 17:25>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240728172557-emacs--Integrating-CMake-with-Emacs.jpg
:END:

Emacs is an incredibly versatile text editor, and with a bit of Elisp magic, you can tightly integrate your build systems into it. In this tutorial, we will illustrate how to use Emacs for seamless integration with *CMake* through custom Elisp functions and transients. So, let's get started!
#+hugo: more

*Introducing the Key Functions*

Here's an overview of the custom Elisp functions to handle CMake commands:

#+begin_src elisp
(defvar cmake-preset
  "build/linux/debug"
  "cmake-preset")

(defun change-directory-and-run (dir command bufname)
  "Change to DIR and run the COMMAND."
  (let ((default-directory dir))
    (async-shell-command command bufname)
    (message "Running command: %s:%s" dir command)))

(defun run-exe-command (dir exe bufname)
  "Run EXE from a specified DIR."
  (message "run-exe-command: %s:%s:%s" dir exe bufname)
  (change-directory-and-run dir exe bufname))

(defun run-cmake-command (command)
  "Run COMMAND from the top level of the project."
  (message command)
  (change-directory-and-run (project-root (project-current t)) command "*cmake*"))

(defun kill-async-buffer (buffer-name)
  "Kill the async buffer with BUFFER-NAME."
  (let ((buffer (get-buffer buffer-name)))
    (when buffer
      (kill-buffer buffer)
      (message "Killed buffer: %s" buffer-name))))

(defun list-cmake-presets ()
  "List available CMake presets using `cmake --list-presets=configure`."
  (let ((output (shell-command-to-string "cmake --list-presets=configure")))
    (delq nil
          (mapcar (lambda (line)
                    (if (string-match "^\\s-+\"\\([^\"]+\\)\"\\s-*$" line)
                        (match-string 1 line)))
                  (split-string output "\n")))))

(defun transient-select-cmake-preset ()
  "Function to select a CMake preset."
  (interactive)
  (let* ((presets (list-cmake-presets))
         (preset (completing-read "Select CMake preset: " presets nil t)))
    (setq cmake-preset preset)
    (message "Selected CMake preset: %s" preset)))
#+end_src

*Explanation of Functions*

1. `change-directory-and-run`:
   - This helper function changes the directory to `dir` and runs the specified `command` in an asynchronous shell.

2. `run-exe-command`:
   - Executes an executable `exe` from a specific directory `dir` and associates the output with `bufname`.

3. `run-cmake-command`:
   - Runs a CMake command from the top-level of the current project directory.

4. `kill-async-buffer`:
   - Kills the async buffer named `buffer-name`.

5. `list-cmake-presets`:
   - Lists all available CMake presets using the `cmake --list-presets=configure` command.

6. `transient-select-cmake-preset`:
   - Allows the user to select a CMake preset interactively.

*Creating the Transient Interface*

Next, we define our transient interface for various CMake-related tasks:

#+begin_src elisp
(transient-define-prefix build-transient ()
  "Build and Diagnostic transient commands."
  ["Build"
   ["CMake"
    ("p" "Set Preset" transient-select-cmake-preset)
    ("c" "Configure"
     (lambda () (interactive)
       (run-cmake-command (format "cmake --preset %s" cmake-preset))))
    ("RET" "Build"
     (lambda () (interactive)
       (run-cmake-command (format "cmake --build --preset %s" cmake-preset))))
    ("i" "Install"
     (lambda () (interactive)
       (run-cmake-command (format "cmake --install %s" cmake-preset))))
    ("f" "Refresh"
     (lambda () (interactive)
       (run-cmake-command (format "cmake --preset %s --fresh" cmake-preset))))
    ("x" "Clean"
     (lambda () (interactive)
       (run-cmake-command "rm -rf build")))
    ("s" "List Presets"
     (lambda () (interactive)
       (run-cmake-command "cmake --list-presets=configure")))]
   ["Flymake"
    ("t" "Toggle Flycheck" flymake-mode)
    ("d" "Show Diagnostics" flymake-show-buffer-diagnostics)]
   ["Coding"
    ("j" "Fancy Stuff"
     (lambda () (interactive)
       (call-interactively 'eglot)
       (flymake-mode 1)
       (company-mode 1)))
    ("u" "Undo Fancy Stuff"
     (lambda () (interactive)
       (eglot-shutdown-all)
       (flymake-mode -1)
       (company-mode -1)))
    ("g" "Stop eglot"
     (lambda () (interactive)
       (eglot-shutdown-all)))]
   ["Run"
    ("r" "All"
     (lambda () (interactive)
       (run-exe-command
        (concat (project-root (project-current t))
                "build/windows/debug/bin/Debug")
        "CigiDummyIG.exe" "*Running CigiDummyIG.exe*")
       (run-exe-command
        (concat (project-root (project-current t))
                "build/windows/debug/bin/Debug")
        "CigiMiniHostCSharp.exe" "*Running CigiMiniHostCSharp.exe*")))
    ("1" "CigiDummyIG"
     (lambda () (interactive)
       (run-exe-command
        (concat (project-root (project-current t))
                "build/windows/debug/bin/Debug")
        "CigiDummyIG.exe"
        "*Running CigiDummyIG.exe*")))
    ("2" "CigiMiniHost"
     (lambda () (interactive)
       (run-exe-command
        (concat (project-root (project-current t))
                "build/windows/debug/bin/Debug")
        "CigiMiniHost.exe"
        "*Running CigiMiniHost.exe*")))
    ("3" "CigiMiniHostCSharp"
     (lambda () (interactive)
       (run-exe-command
        (concat (project-root (project-current t))
                "build/windows/debug/bin/Debug")
        "CigiMiniHostCSharp.exe"
        "*Running CigiMiniHostCSharp.exe*")))]
   ["Kill"
    ("5" "CigiDummyIG (k)"
     (lambda () (interactive)
       (kill-async-buffer "*Running CigiDummyIG.exe*")))
    ("6" "CigiMiniHost (k)"
     (lambda () (interactive)
       (kill-async-buffer "*Running CigiMiniHost.exe*")))
    ("7" "CigiMiniHostCSharp (k)"
     (lambda () (interactive)
       (kill-async-buffer "*Running CigiMiniHostCSharp.exe*")))
    ("k" "All (k)"
     (lambda () (interactive)
       (kill-async-buffer "*Running CigiDummyIG.exe*")
       (kill-async-buffer "*Running CigiMiniHost.exe*")
       (kill-async-buffer "*Running CigiMiniHostCSharp.exe*")))]])
#+end_src

*Key Bindings for Transient Interface*

1. *CMake Commands*:
   - Set CMake preset (`p`)
   - Run CMake configure (`c`)
   - Build project (`RET`)
   - Install project (`i`)
   - Refresh build (`f`)
   - Clean build directory (`x`)
   - List available presets (`s`)

2. *Flymake Diagnostics*:
   - Toggle Flycheck (`t`)
   - Show diagnostics (`d`)

3. *Coding Helpers*:
   - Engage coding helpers like Eglot and Flymake (`j`)
   - Disable coding helpers (`u`)
   - Stop Eglot (`g`)

4. *Executable Commands*:
   - Run all predefined executables (`r`)
   - Individual executable commands (`1`, `2`, `3`)

5. *Kill Async Buffers*:
   - Kill specific async buffers (`5`, `6`, `7`)
   - Kill all async buffers at once (`k`)

*Setting Up Global Keybinding*

Finally, bind the transient to a global key for easy access:

#+begin_src elisp
(global-set-key (kbd "M-RET") 'build-transient)
#+end_src

*Conclusion*

By integrating these Elisp functions and transients into your Emacs setup, you can significantly streamline your CMake-based development workflow. This custom interface allows quick access to build commands, diagnostic tools, and executable runners, making Emacs a powerful IDE for CMake projects. Happy coding!

* DONE Sending Dired Directories to Meld for Directory Comparison :meld:emacs:elisp:dired:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240728141344-emacs--Sending-Dired-Directories-to-Meld
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-07-28 16:43>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240728141344-emacs--Sending-Dired-Directories-to-Meld.jpg
:END:

A common activity for a Software Engineer is to compare two directories, especially those that might require a level of merging.  My preferred tool of choice in this instance is *Meld*

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240728141344-emacs--Sending-Dired-Directories-to-Meld.jpg]]

#+begin_quote
Meld is a visual diff and merge tool that is widely used for comparing files, directories, and version-controlled projects.
#+end_quote

For *Meld*, the workflow is generally straightforward: simply open a file explorer alongside and drag and drop the required directories.

But what about comparing directories seamlessly as part of the Emacs ecosystem I hear you say? 🫢

Well, I am trying to incorporate =ztree-diff= into my workflow, but after a few minutes of grappling with it, I always reach for Meld as I know it well (yes, I know this isn't really the Emacs way, in which an initial investment of blood, sweat and toil eventually reaps dividends).  I will persist with =ztree-diff=, but for now, to at least get a more seamless directory comparison experience from within Emacs I will have to just fall back on the tried and tested method of invoking an external application, and in this case by sending directories marked in =dired= to *Meld*, here is some elisp:

#+begin_src elisp
(require 'cl-lib)

(defun my/dired-meld-diff-all-dwim ()
  "Compare all marked directories in all visible Dired buffers using Meld.
   The order of directories respects the order suggested by `dired-dwim-target`."
  (interactive)
  (let ((files ()))
    (dolist (window (window-list))
      (with-current-buffer (window-buffer window)
        (when (and (derived-mode-p 'dired-mode)
                   (dired-get-marked-files))
          (setq files (append files (dired-get-marked-files))))))
    (if (or (<= (length files) 1)
            (not (cl-every 'file-directory-p files)))
        (message "Please mark at least two directories.")
      (apply 'start-process "meld" nil "meld" files))))

(define-key dired-mode-map (kbd "C-c m") 'my/dired-meld-diff-all-dwim)
#+end_src

/*edit: <2024-07-29> every is now obsolete, replaced with cl-every/

This method has the advantage of honouring =dired-dwim-target= through the =(window-list)= function which I am now pretty familiar with as I often use =dired-do-copy= and =dired-do-rename=

So how does this work?, well now I can split windows, bring up some dired buffers, mark directories to compare, and then make sure I am in the dired buffer that is to appear on the LHS of the Meld comparison before I then run the command.  The destination directory would then be defined according to =dired-dwim-target= which I have set to =t= which is the next dired visible buffer in a clockwise direction, but can be adjusted as desired.

With a little experimentation I found out that =(dired-get-marked-files)= retrieves the dired item that the cursor is over, therefore each directory doesn't necessary even need to be explicitly marked!, so you could just split with two dired buffers, leave the cursor over the destination directory, switch to the source dired buffer and leave the cursor over the source directory before running the command above.

More experimentation reveals that even three directories can be sent to Meld for comparison!, just open the dired buffers, hover cursor or mark, make sure they are visible, set up in the clockwise order and then focus the cursor on the source directory.

Is it a little weird that I'm talking about experimentation when this is a function I wrote myself? 😀  A three directory comparison is not something I have ever used but I deliberately left the function open and flexible enough and it doesn't really do any harm...

* TODO Prog-Mode Folding With a Transient :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240728085110-emacs--Prog-Mode-Folding-With-Transient
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-07-28 08:51>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240728085110-emacs--Prog-Mode-Folding-With-Transient.jpg
:END:

I'm looking on ways to enhance my Emacs coding experience and especially regarding the use of cmake and folding.  More on cmake in a future post, but regarding the folding aspect, my interest was rekindled when I looked into a new package called =outline-indent=, in principle it seems like a simple and cool idea to leverage the =outline-mode= to program fold based on indentation levels.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240728085110-emacs--Prog-Mode-Folding-With-Transient.jpg]]

Of course org heavily leans on =outline-mode= for much of its folding and I've been using <TAB> and <S-TAB> for quite a while which toggle cycles headings, although less on the navigation aspect as I rely on org speed commands.

A while ago I found some simple agnostic folding elisp using =selective-display= :

#+begin_src elisp
(defun my/fold ()
  "Fold text indented same of more than the cursor."
  (interactive)
  (if (eq selective-display (1+ (current-column)))
      (set-selective-display 0)
    (set-selective-display (1+ (current-column)))))
#+end_src

Which folds everything in the buffer based on the cursor position and just toggles back and forth.  I found this pretty cool when I found it but I do keep forgetting about it, well now I am going to try and go full throttle on some agnostic level folding in source code I might bring this into the general concept introduced by =outline-indent=

At the moment I'm having fun defining transients, I like the grouping of any set of commands together which is presented as a simple text menu and especially those infrequently used and hence forgotten.

So my idea here is to allow agnostic code folding on spaces and tabs (as my source code is always consistently indentally formatted), based on =outline-mode= along with an =outline-mode= transient menu which will also include extra cursor position folding using =selective-display=

I could use =outline=indent= to help me out here but I thought as just a general exercise to learn some more elisp and have fun defining a transient (which could be easily turned into an all purpose =outline-mode= transient).  Although I am using the following taken from =outline-indent= to enable the space / tab outline indenting mechanism:

#+begin_src elisp
(setq-local outline-regexp (rx bol
                               (zero-or-more (any " \t"))
                               (not (any " \t\n"))))
#+end_src

I'm not too clear as to how much =outline-mode= is generally leveraged in different programming modes, and presumably based on different program specific syntactical structures.  The languages that I mainly use seem to for example define their own navigation system, and straight using =outline-mode= and especially then turning on outline cycling is problematic given the <TAB> use within general source code and hence the outline conflicting binding.

So given all these thoughts, this is what I have have so far:

#+begin_src elisp
(transient-define-prefix my/transient-outlining-and-folding ()
  "Transient menu for outline-mode."
  ["Outline Mode Commands"
   ["Cycle / Folding"
    ("g" "Cycle" outline-cycle)
    ("O" "Cycle Buffer" outline-cycle-buffer)
    ("F" "Global Folding at Point"
     (lambda () (interactive)
       (if (eq selective-display (1+ (current-column)))
           (set-selective-display 0)
         (set-selective-display (1+ (current-column))))))]
   ["Visibility"
    ("o" "Toggle Children" outline-toggle-children)
    ("h" "Hide Sublevels" outline-hide-sublevels)
    ("s" "Show All" outline-show-all)
    ("i" "Hide Body" outline-hide-body)
    ("e" "Show Entry" outline-show-entry)
    ("H" "Hide Entry" outline-hide-entry)
    ("c" "Hide Leaves" outline-hide-leaves)
    ("k" "Show Branches" outline-show-branches)
    ("t" "Hide Subtree" outline-hide-subtree)
    ("S" "Show Subtree" outline-show-subtree)]
   ["Motion"
    ("n" "Next Visible Heading" outline-next-visible-heading)
    ("p" "Previous Visible Heading" outline-previous-visible-heading)
    ("u" "Up Heading" outline-up-heading)
    ("f" "Forward Same Level" outline-forward-same-level)
    ("b" "Backward Same Level" outline-backward-same-level)]
   ["Structure"
    ("t" "Promote Heading" outline-promote)
    ("d" "Demote Heading" outline-demote)
    ("P" "Move Subtree Up" outline-move-subtree-up)
    ("N" "Move Subtree Down" outline-move-subtree-down)]
   ["Edit"
    ("a" "Add Heading" outline-insert-heading)
    ("r" "Rename Heading" outline-insert-heading)
    ("m" "Mark Subtree" outline-mark-subtree)]])

(bind-key* (kbd "C-c o") 'my/transient-outlining-and-folding)

(defun my/prog-folding ()
  "Enable and configure outline minor mode for code folding.

This function sets up the outline minor mode tailored for
programming modes based on basic space / tab indentation."
  (interactive)
  (setq-local outline-minor-mode-use-buttons nil)
  (setq-local outline-regexp (rx bol
                                 (zero-or-more (any " \t"))
                                 (not (any " \t\n"))))
  (outline-minor-mode 1))

(add-hook 'prog-mode-hook 'my/prog-folding)
#+end_src

As you can see, the main transient is globally defined so can be used in anything that has =outline-mode= enable, for example org!

But sneakily also has  "Global Folding at Point" for some cursor position folding.

Often and when in a source code body I would really like to just get a top level outline of all the functions available, this should be always doable with  "Global Folding at Point" for just about any language as long as the cursor is positioned accordingly.  "Cycle Buffer" would mostly perform a similar function but could run into difficulties if newlines were just after function headers.

Also I often program in Ada and for procedure or function definitions the indent structure is not that compatible with an outline methodology and would start folding local variables and function / procedure bodies separately.  For Ada I would almost always used  "Global Folding at Point" and probably I'm sure for some other languages.  Well maybe the transient now caters for most programming folding?

Now the big question is... will I actually use the above? and then build it into my workflow / muscle memory? I have survived this far without code folding, and annoyingly is my recent development shennanigans in Visual Studio skewing / adjusting my expectations in an IDE?, do I really want this?, is it helpful? who knows, and actually it doesn't matter I have learned much about =outline-mode= regex using rx, transients, e.t.c

* TODO Native-Compilation-On-Linux :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240720165945-emacs--Native-Compilation-On-Linux
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-07-20 16:59>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240720165945-emacs--Native-Compilation-On-Linux.jpg
:END:

Compiling Emacs with native compilation on Linux involves several steps, but it can be a worthwhile endeavor if you want to take advantage of the performance improvements offered by native compilation. Native compilation in Emacs uses the `libgccjit` library to compile Emacs Lisp code to native code, which can then be executed directly by the CPU.

#+hugo: more

Here are the general steps to compile Emacs with native compilation on Linux:

As I am currently using Arch I shall use the AUR and tailor PKBUILD

Here is a good post from Prot : https://protesilaos.com/codelog/2022-07-06-build-emacs-arch-linux/ of which most of this post was taken from.

On Arch we can build custom packages cleanly by writing a PKGBUILD. This is a shell script that fetches the source and prepares it for installation. In the case of Emacs, we do not need to write the entire script ourselves: the community-driven Arch User Repository (AUR) already includes the emacs-git package.

As we likely want to customise certain aspects of the build, emacs-git should not be installed as-is (and generally one ought to always inspect what they install from the AUR). Instead, we must fetch the PGBUILD source, edit it, and build the package from there. This requires the base-devel package group. The resulting output is a regular package as far as the pacman is concerned.

We get the build script:

git clone https://aur.archlinux.org/emacs-git.git/ path/to/emacs-git-aur

Then we change to the emacs-git-aur directory and visit the PKGBUILD file. It is properly annotated so one must read all the comments carefully to understand what each variable pertains to.

#+begin_src sh
JIT="YES"
PGTK="YES"     # Use native GTK3 build. Supports Wayland, yay!
GTK3=          # GTK3 old windowing interface.
XWIDGETS="YES" # Use GTK+ widgets pulled from webkit2gtk. Usable.
SITTER="YES"   # Use tree-sitter incremental language parsing.
#+end_src

Now to build the package outright ($ refers to regular user privileges):

/path/to/emacs-git-aur $ makepkg -siC

- *-s* (or =--syncdeps=): This flag tells =makepkg= to install any missing dependencies required to build the package. It will use the package manager (usually =pacman=) to find and install these dependencies.

- *-i* (or =--install=): After the package is successfully built, this flag will automatically install the newly built package using =pacman=.

- *-C* (or =--cleanbuild=): This flag tells =makepkg= to remove the existing build directory before building the package. This ensures that the build starts from a clean state, which can help avoid issues related to remnants of previous builds.

the -C is not necessary here, but I added it just to be sure (it is required for clean builds).

As a final step, makepkg will prompt to install the package and ask to escalate privileges. In case we miss that part, we do not need to restart the whole process. The easier way is to check the directory we are in for a file named emacs-git-29.0.50.157962-1-x86_64.pkg.tar.zst or something like that and run the following (# denotes superuser privileges):

/path/to/emacs-git-aur # pacman -U emacs-git-29.0.50.157962-1-x86_64.pkg.tar.zst

The first build will take a long time, especially with native compilation enabled, but subsequent ones shall be faster (I wrote this blog post while waiting for it).

Rebuilding a package automatically fetches the updates. All we ever need is to re-run makepkg -si (occasionally with -C included). However, as time goes by, we might also have to check the PKGBUILD for updates, such as when new build options are added upstream. No problem! We just git pull from the source we cloned earlier (the https://aur.archlinux.org/emacs-git.git/). Again, the rest is all about scrutinising the PKGBUILD and running makepkg.

* TODO Native-Compilation-On-Windows :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240720165945-emacs--Native-Compilation-On-Windows
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-07-20 16:59>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240720165945-emacs--Native-Compilation-On-Windows.jpg
:END:

Compiling Emacs with native compilation on Windows involves several steps, but it can be a worthwhile endeavor if you want to take advantage of the performance improvements offered by native compilation. Native compilation in Emacs uses the `libgccjit` library to compile Emacs Lisp code to native code, which can then be executed directly by the CPU.

#+hugo: more

Here are the general steps to compile Emacs with native compilation on Windows:

1. **Install MSYS2**:
   - Visit the [MSYS2 website](https://www.msys2.org/) and download the installer.
   - Run the installer and update the package database and base packages by running the following commands in the MSYS2 terminal:
     ```sh
     pacman -Syu
     pacman --noconfirm -Syu # Might be needed to fully update MSYS2
     ```

2. **Install Required Packages**:
   Use the following command to install the necessary packages:
   ```sh
   pacman -S base-devel mingw-w64-x86_64-toolchain mingw-w64-x86_64-libgccjit mingw-w64-x86_64-cmake mingw-w64-x86_64-pkg-config git mingw-w64-x86_64-make
   ```

3. **Clone the Emacs Repository**:
   - Navigate to the directory where you want to download Emacs sources in the MSYS2 bash shell, then run:
     ```sh
     git clone https://github.com/emacs-mirror/emacs.git
     cd emacs
     ```

4. **Configure the Build**:
   - Create a separate directory for building Emacs (e.g., `build` directory inside the cloned `emacs` directory):
     ```sh
     mkdir build
     cd build
     ```
   - Run the configuration script with native compilation enabled:
     ```sh
     ../autogen.sh
     ../configure --with-native-compilation --prefix=/mingw64
     ```

5. **Compile and Install Emacs**:
   - Compile Emacs by running:
     ```sh
     make -j$(nproc)
     ```
   - Install Emacs to the prefix directory specified during the configuration (in this case, `/mingw64`):
     ```sh
     make install
     ```

6. **Set Up Native Compilation**:
   - Ensure that the installed Emacs can find the native compiler (`libgccjit`). This usually involves adding the MSYS2 `/mingw64/bin` directory to your PATH environment variable.

7. **Run Emacs**:
   - You can now run Emacs using the installed executable:
     ```sh
     /mingw64/bin/emacs
     ```

### Additional Notes
1. **Using GUI Emacs**:
   If you want to use the GUI version of Emacs, make sure you have installed the necessary GTK packages:
   ```sh
   pacman -S mingw-w64-x86_64-gtk3 mingw-w64-x86_64-pango mingw-w64-x86_64-xpm-nox mingw-w64-x86_64-xwidgets
   ```

2. **Troubleshooting**:
   - Make sure your environment variables are set correctly, especially PATH.
   - Keep an eye on the output of each step to catch any errors or missing dependencies.

### Example Emacs Configuration
Here's an example `.emacs.d/init.el` configuration to ensure native compilation works correctly once you start Emacs:

```elisp
(setq package-native-compile t)
(setq comp-speed 2)

* DONE Selected Window Accent Mode v0.8.0 :selected_window_accent_mode:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240718103550-emacs--Selected-Window-Accent-Mode-v-0-8-0
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-07-19 11:15>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240718103550-emacs--Selected-Window-Accent-Mode-v-0-8-0.jpg
:END:

** Whats New

What's New in Selected Window Accent Mode v0.8.0 - (selected-window-accent-mode) which is my window accent package in MELPA for Emacs, here is a quick summary before I dive into the new features:

#+hugo: more

#+begin_quote
The Selected Window Accent Mode is an Emacs package designed to visually distinguish the currently selected window by applying a unique accent color to its fringes, mode line, header line, and margins.
#+end_quote

https://github.com/captainflasmr/selected-window-accent-mode

** Transient Map for Quick Access

In the latest release of Selected Window Accent Mode, version 0.8.0, users of Emacs 28.1 and above can enjoy the convenience of a transient map. This new feature allows you to access a transient menu by simply pressing `C-c w`:

#+begin_src elisp
(global-set-key (kbd "C-c w") 'selected-window-accent-transient)
#+end_src

Upon invoking this key binding, the following transient menu will be displayed:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240718103550-emacs--Selected-Window-Accent-Mode-v-0-8-0.jpg]]

** Release Highlights
*** v0.8.0 | 2024-07-15

- **Transient Menu**: A transient menu has been added for interactive adjustments, simplifying the process of tweaking settings on the fly. Refer to the README for detailed usage instructions.
- **Emacs Dependency**: The Emacs dependency has been upgraded to version 28.1.
- **Custom Foreground Accent Color**: A new variable, `selected-window-accent-fg-color`, has been introduced for setting a custom foreground accent color.
- **Enhanced Customization Options**:
  - `selected-window-accent-foreground-adjust-factor`
  - `selected-window-accent--use-complementary-color`
  - `selected-window-accent--foreground-invert-state`
  - `selected-window-accent--foreground-offset`
- **Foreground Brightness Functions**:
  - `selected-window-accent-flip-foreground-color`
  - `selected-window-accent-increment-foreground-color`
  - `selected-window-accent-decrement-foreground-color`
  - `selected-window-accent-toggle-complementary-color`
  - `selected-window-accent-toggle-tab-accent`
  - `selected-window-accent-toggle-smart-borders`
- **Configuration Export**: A new function, `selected-window-accent-output-selected-window-accent-settings`, allows you to output the current settings for easy copying and pasting into your Emacs init file.
- **Miscellaneous**: Various improvements and refactoring have been made to enhance the overall functionality and maintainability.

*** v0.7.0 | 2024-07-09

- **Compatibility Fixes**: Addressed issues with other packages and restored modeline height when switching between modes.
- **Issue Resolutions**:
  - ISSUE #4: Resolved compatibility issues with other packages.
  - ISSUE #3: Fixed problems causing the package to break fringes.

With these updates, Selected Window Accent Mode continues to offer increased customization and improved user experience. Stay tuned for more exciting features in the upcoming versions! 😀

* DONE Emacs Blog 2 Year Anniversary - First Post Revisit - Create Local Offline ELPA MELPA ORG :emacs:bash:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240713203037-emacs--Local-ELPA-MELPA-ORG-Revisited-2yr-Anniversary
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-07-15 Mon 21:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240713203037-emacs--Local-ELPA-MELPA-ORG-Revisited-2yr-Anniversary.jpg
:END:

I've noticed that my Emacs blog is now almost 2 years old!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240713203037-emacs--Local-ELPA-MELPA-ORG-Revisited-2yr-Anniversary.jpg]]

Is there something absurd about writing about a text editor in that very text editor for such a long period? - I think the answer to this is clearly..., no!

My first post was on 2022-07-15 and this will be blog number 97.

And yes before you ask, how do I know this to be true?, well I found out the Emacs way!

I recorded its inception date in org-agenda, so I saw this date creep up this week :

#+begin_src org
,** blog anni :james:web:
<2022-07-15 .+1y>
#+end_src

The date of my first post is in an org drawer in my single Emacs blog org file:

#+begin_src org
:EXPORT_HUGO_LASTMOD: 2022-07-15
#+end_src

and the blog number?, well, I org-copy-visible'd my org blog file of all the top level org headers, pasted into the *scratch* buffer, flush-line'd out all the TODO entries, then finally entered (display-line-numbers-mode) to get the number of lines (I suspect there might be an easier way to do this 😀)

I also wrote this post ahead of time and to remind me when to post I created an org schedule entry as follows:

#+begin_src org
,** TODO post 2 yr emacs blog post
SCHEDULED: <2024-07-15 Mon>
#+end_src

and appeared in the agenda as :

#+begin_src org
Monday     15 July 2024 W29
aab--calendar:Scheduled:  TODO post 2 yr emacs blog post
#+end_src

and in (cfw:open-org-calendar) as :
#+begin_src org
+-------------------------+
| 15 (3)                  |
| TODO post 2 yr emacs    |
| blog anni               |
|                         |
|                         |
|                         |
+-------------------------+
#+end_src

Living an Emacs life and especially partially through org means that any and all information can be easily extracted let alone initially logged, the basic text format is so simple and uniform that all the data items above were pretty much extracted using the same mechanism through Emacs.

Anyway enough of all that, in celebration of being able to maintain some level of blogging discipline for 2 years, I decided to revisit my very first post, which was on how to create an offline version of the major Emacs repositories, namely:

- ELPA
- MELPA
- ORG

As it turns out this post is still quite relevant as from time to time, I need an offline version for an Emacs setup without an internet connection.

So lets re-post!, just for fun!, including the bash script that I still use:

---

#+begin_quote
Steps to locally download emacs packages for offline installation.
#+end_quote

** Local ELPA MELPA ORG

#+begin_src bash
#! /bin/bash
cd ~
mkdir -p emacs-pkgs/melpa
mkdir -p emacs-pkgs/elpa

echo
echo "updating MELPA..."
echo
rsync -avz --delete --progress rsync://melpa.org/packages/ ~/emacs-pkgs/melpa/.

echo
echo "updating ELPA..."
echo
rsync -avz --delete --progress elpa.gnu.org::elpa/. ~/emacs-pkgs/elpa

# org (currently no rsync support)
echo
echo "updating ORG..."
echo
cd ~/emacs-pkgs
git clone https://git.savannah.gnu.org/git/emacs/org-mode.git
# wget -r -l1 -nc -np https://orgmode.org/elpa
#+end_src

I then copy the emacs-pkgs directory to the offline target machine and change the default package manager archives to point to these packages.

Modify *.emacs* in the following manner commenting out the online package communication:

#+begin_src elisp
;; (setq package-archives '(("melpa" . "https://melpa.org/packages/")
;;                          ("org" . "https://orgmode.org/elpa/")
;;                          ("elpa" . "https://elpa.gnu.org/packages/")))

(setq package-archives '(("melpa". "~/emacs-pkgs/melpa")
                         ("org" . "~/emacs-pkgs/elpa")
                         ("elpa" . "~/emacs-pkgs/org-mode/lisp")))
#+end_src

* DONE Creating a Spelling Transient :spelling:jinx:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240712082430-emacs--Spelling-Powerthesaurus
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-07-12 08:25>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240712082430-emacs--Spelling-Powerthesaurus.jpg
:NUM:      96
:END:

I really want to finally get to grips with my spelling / dictionary set-up.

I'm happy with =jinx= instead of =flyspell=. I like =powerthesaurus= and, of course, =dictionary-lookup-definition=. It is mainly the keybindings I want to finally settle on. I have been moving them around for a while now but haven't really established something comfortable.

#+hugo: more

jjjNow Emacs 29 comes with =transient=, which is the keyboard-driven interface used by Magit, I am going to see if I can fit my spelling keybindings into a more menu-driven system. I have tried Hydra in the past but found I wasn't really using it. Now that =transient= is built-in and the syntax seems simple, let's give it a go!

Here are my original keybindings:

#+begin_src elisp
(use-package jinx)
(use-package powerthesaurus)
(global-set-key (kbd "M-s y") 'powerthesaurus-lookup-synonyms-dwim)
(global-set-key (kbd "M-s a") 'powerthesaurus-lookup-antonyms-dwim)
(global-set-key (kbd "M-s x") 'jinx-mode)
(global-set-key (kbd "M-s c") 'jinx-correct)
(global-set-key (kbd "M-s d") 'dictionary-lookup-definition)
#+end_src

and converted into :

#+begin_src elisp
(use-package jinx)

(use-package powerthesaurus
  :init
  (require 'transient)
  (transient-define-prefix my/transient-spelling ()
    "Spelling commands"
    ["Spelling"
     ["Lookups"
      ("y" "Synonyms" powerthesaurus-lookup-synonyms-dwim)
      ("a" "Antonyms" powerthesaurus-lookup-antonyms-dwim)]
     ["Spelling Tools"
      ("x" "Jinx" jinx-mode)
      ("c" "Jinx correct" jinx-correct)]
     ["Dictionary"
      ("d" "Lookup" dictionary-lookup-definition)]
     ["Miscellaneous"
      ("q" "Quit" transient-quit-one)]])
  :bind
  ("C-c s" . my/transient-spelling))
#+end_src

and produces the following menu:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240712082430-emacs--Spelling-Powerthesaurus.jpg]]

Well that was pretty simple, lets see how this goes and if I might then think about translating some more of my keybindings to transient menus.

* DONE WOWEE v0.3.3 :wowee:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240705073835-emacs--WOWEE-v0.3.3
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-07-05 07:58>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240705073835-emacs--WOWEE-v0.3.3.jpg
:END:

More tinkering and enhancements to some AutoHotKey scripts with WOWEE to allow some emacs keybindings throughout the realm of Windows.

#+hugo: more
#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240705073835-emacs--WOWEE-v0.3.3.jpg]]

---
#+TOC: headlines 1 local
---

#+begin_quote
WOWEE is a set of AutoHotKey scripts designed to bring Emacs-like commands and keybindings to the Windows operating system. Based on the concept of EWOW (Emacs Way of Operating Windows), WOWEE allows you to use Emacs-style navigation and commands throughout your Windows environment.
#+end_quote

I have this on github : https://github.com/captainflasmr/wowee

As I have been playing ergo for a little while with Emacs I decided to bring in some of this functionality, for example some common ergo keybindings.

** Ergonomic keyboard layout options

Additional AHK files that can be run in parallel with the main wowee.ahk file if you would prefer some extra ergonomic mappings.

For example it is common to map the Caps Lock key to the Control key to avoid the dreaded Emacs pinky, which can be performed by running up :

#+begin_src
wowee--caps_to_ctrl.ahk
#+end_src

I prefer to map the right hand Alt key to the Control key by running:

#+begin_src
wowee--ralt_to_ctrl.ahk
#+end_src

Both can also be run if desired!

** Whats New
*** Version 0.3.3 <2024-07-01>

A little support for Notepad++:

- isearch
- comment line

*** Version 0.3.2 <2024-07-01>

Separated individual ergonomic key-mappings as thus:

- wowee--caps_to_ctrl.ahk
- wowee--ralt_to_ctrl.ahk

These are extra files that can be run in addition to the main wowee.ahk for some common ergonomic keyboard Emacs mappings.

*** Version 0.3.1 <2024-06-30>

This commit has added windows, frames support

- kill frame (C-x c)
- split window vertically (C-x 3)
- maximize window (C-x 1)
- next window (C-x o)
- suspend frame (C-z)
- reorganisation of kanban
- reorganisation of commands.ahk to better group

** kanban

This kanban board is keeping track of those original EWOW functions.

The IGNORE column includes functions that I am definitely not going to implement.

The EXTRA section are additional commands that I am adding.

There is a prefix type indicator for each command referring to the specific type:

(C) - Core Emacs commands
(VS) - Visual Studio specific
(VC) - VSCode specific
(N++) - NotePad++ specific
(E) - Extra

and any command with an asterisk is an unconventional Emacs keybinding which will probably get fixed sometime in the future!

| TODO                            | DOING                          | DONE                               | IGNORE                          |
|---------------------------------+--------------------------------+------------------------------------+---------------------------------|
| (C) REGION COMMANDS             | (VS) VISUAL STUDIO             | (C) MOTION COMMANDS                | (C) JUMPING AROUND COMMANDS     |
| - (C) mark_word                 | - (VS) recenter_line (C-l)     | - (C) forward_char (C-f)           | - (C) scroll_left               |
| - (C) yank_pop                  | - (VS) indent_line (C-i)       | - (C) backward_char (C-b)          | - (C) scroll_right              |
| - (C) kill_region               | (VC) VSCODE                    | - (C) forward_word (M-f)           | (C) NEWLINE AND INDENT COMMANDS |
| - (C) delete_backward_char      | - (VC) isearch_backwards (C-r) | - (C) backward_word (M-b)          | - (C) open_line                 |
| - (C) kill_word                 | - (VC) isearch_forwards (C-s)  | - (C) next_line (C-n)              | (C) EDIT COMMANDS               |
| - (C) kill_whole_line           | - (VC) comment_line (C-;)      | - (C) previous_line (C-p)          | - (C) transpose_chars           |
| (C) NEWLINE AND INDENT COMMANDS | - (VC) recenter_line (C-l)     | (C) JUMPING AROUND COMMANDS        | - (C) transpose_words           |
| - (C) newline                   | (N++) NOTEPAD++                | - (C) scroll_down (C-v)            | - (C) transpose_lines           |
| - (C) delete_indentation        | (E) PROGRAM SPECIFIC PRESETS   | - (C) scroll_up (M-v)              | (C) CASE CONVERSION COMMANDS    |
| (C) EDIT COMMANDS               | (E) ERGO PRESET SELECTION      | - (C) move_beginning_of_line (C-a) | - (C) upcase_region             |
| - (C) redo                      |                                | - (C) move_end_of_line (C-e)       | - (C) downcase_region           |
| - (C) query_replace             |                                | - (C) beginning_of_buffer (M-<)    | - (C) upcase_word               |
| - (C) overwrite_mode            |                                | - (C) end_of_buffer (M->)          | - (C) downcase_word             |
| - (E) isearch-yank-word-or-char |                                | - (C) goto_line (M-g g)            | - (C) capitalize_word           |
| (C) INSERT PAIRS COMMANDS       |                                | (C) REGION COMMANDS                | (C) MACRO RECORDING COMMANDS    |
| - (C) insert_parentheses        |                                | - (E) mark_whole_line (M-s ,)      | (C) ADD IGNORE FRAMES           |
| - (C) insert_comment            |                                | - (C) mark_whole_buffer (C-x h)    | (C) ADD MOUSE EVENTS            |
| - (C) indent_new_comment_line   |                                | - (C) kill_ring_save (M-w)         |                                 |
| (C) OTHER COMMANDS              |                                | - (C) yank (C-y)                   |                                 |
| - (C) shell                     |                                | - (C) delete_char (C-d)            |                                 |
| - (C) shell_command             |                                | - (C) backward_kill_word (M-BKSP)  |                                 |
| - (C) facemenu                  |                                | - (C) kill_line (C-k)              |                                 |
| - (C) help                      |                                | (C) NEWLINE AND INDENT COMMANDS    |                                 |
| (C) SYSTEM COMMANDS             |                                | - (C) indent_for_tab_command (C-i) |                                 |
| - (C) ignore                    |                                | (C) EDIT COMMANDS                  |                                 |
| - (C) repeat                    |                                | - (C) undo_only (C-/)              |                                 |
| (C) UNIVERSAL ARGUMENT COMMANDS |                                | - (C) search_forward (C-s)         |                                 |
| (C) FILES COMMANDS              |                                | - (C) search_backward (C-r)        |                                 |
| - (C) write_file                |                                | (C) SYSTEM COMMANDS                |                                 |
| - (C) find_file                 |                                | - (C) set_mark_command (C-SPC)     |                                 |
| - (C) dired                     |                                | - (C) set_c-x_command (C-x)        |                                 |
| (C) WINDOWS FRAMES COMMANDS     |                                | - (C) keyboard_quit (C-g)          |                                 |
| - (C) delete_window             |                                | (C) FILES COMMANDS                 |                                 |
| - (C) split_window              |                                | - (*C) save_buffer (C-x s)         |                                 |
| - (C) previous_window           |                                | (C) WINDOWS FRAMES COMMANDS        |                                 |
| (C) ADD HOOKS                   |                                | - (*C) kill_frame (C-x c)          |                                 |
| (C) ADD GENERIC GOTO LINE       |                                | - (C) next_window (C-x o)          |                                 |
| (C) ADD KILL RING               |                                | - (C) suspend_frame (C-z)          |                                 |
| (VC) VSCODE                     |                                | (C) ADD C-X (C-x)                  |                                 |
| - (VC) indent_line (C-i)        |                                | (VS) VISUAL STUDIO                 |                                 |
|                                 |                                | - (VS) isearch_backwards (C-r)     |                                 |
|                                 |                                | - (VS) isearch_forwards (C-s)      |                                 |
|                                 |                                | - (VS) comment_line (C-;)          |                                 |
|                                 |                                | - (VS) split window vert (C-x 3)   |                                 |
|                                 |                                | (N++) NOTEPAD++                    |                                 |
|                                 |                                | - (N++) isearch_backwards (C-r)    |                                 |
|                                 |                                | - (N++) isearch_forwards (C-s)     |                                 |
|                                 |                                | - (N++) comment_line (C-;)         |                                 |

* DONE WOWEE v0.3.0 :wowee:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240628101906-emacs--WOWEE-v0.3.0
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-06-28 10:19>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240623081827-emacs--WOWEE---Windows-Operating-With-Emacs-Enhancements.jpg
:END:

I have been continuing to tinker with this project over the last week...

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240623081827-emacs--WOWEE---Windows-Operating-With-Emacs-Enhancements.jpg]]

https://github.com/captainflasmr/wowee

** Overview

WOWEE is a set of AutoHotKey scripts designed to bring Emacs-like commands and keybindings to the Windows operating system. Based on the concept of EWOW (Emacs Way of Operating Windows), WOWEE allows you to use Emacs-style navigation and commands throughout your Windows environment.

** Whats New
*** Version 0.3.0 [2024-06-28]

This commit has split out ahk files into apps, core and init:
- Added comment-line
- Added mark-whole-buffer
- Refined isearch
- Added application specific bindings in keybinds-apps.ahk for Visual Studio and VSCode
- Update README to reflect design changes
- Added beginning_of_buffer and end_of_buffer core mappings
- Added mark_whole_buffer core mapping

*** Version 0.2.0 [2024-06-26]

This commit introduces several new functions to enhance the usability and
functionality of the `commands.ahk` script. Notable additions include:

- Implementation of `isearch_backward` and `isearch_forward` functions for improved search capabilities, allowing for backwards and forwards in-document searches with initialization and continuation logic.
- Addition of `recenter_line`, `indent_line`, and `backward_kill_word` functions to enrich text editing commands.
- Enhancement of `select_line` and `goto_line` functions for better line selection and navigation.
- The `quit_g` function extends quitting capabilities to also reset the `selecting` and `searching` states.
- Modifications to `next_lines` and `previous_lines` to increase the number of lines navigated with each command from 3 to 6, improving scroll efficiency.
- Update to `kill_ring_save` to include an escape key press, ensuring a more comprehensive cleanup post-operation.
- Improved the README.org kanban to more easily differentiate between command sections and to define those commands I am not implementing (IGNORE) and those additional commands (EXTRA)

*** Version 0.1.0 [2024-06-19]

Initial version

** Features

- Emacs-like commands and keybindings in Windows
- Based on EWOW – Emacs Way of Operating Windows
- Written in AutoHotKey v2
- Includes various Emacs style navigation commands
- Ergonomic keyboard layout options
- Easily add your own keybindings by modifying AHK source files
- *Bindings bespoke to individual applications*

*** My current thoughts
**** Bindings bespoke to individual applications

- I am playing around with the idea of application specific bindings within the keybinds.ahk file, for example something like :

  #+begin_src ahk
  ;; -------------
  ;; Visual Studio
  ;; -------------
  ;; Shortcut rebindings:
  ;;
  ;; Control+p Control+s : Text Editor : Incremental Search
  ;; Control+p Control+r : Text Editor : Incremental Search Reverse
  ;; Control+p Control+l : Text Editor : Scroll Recenter
  ;; Control+p Control+f : Text Editor : Format selection

  #HotIf WinActive("ahk_class VisualStudio")
  ^r::isearch_backward("{Shift down}{F3}{Shift up}" "^p^r")
  ^s::isearch_forward("{F3}" "^p^s")
  ^l::recenter_line()
  ^i::indent_line()
  ^+i::indent_line()
  #+end_src

  These will be placed in a separate ahk file called keybinds-apps.ahk.

  The comments would indicate which commands require re-bindings, or redefining the shortcuts. For example, in Visual Studio, Control+I is an incremental search which in emacs is used for multiple actions including indentation, cycling, e.t.c, so at times rather than relying on either default application keybindings or the general windows keybindings an explicit mapping may be required for full functionality.

  So as part of the application definition, why not add in the re-mappings in a comment!

  Also I might have to create some more generic functions to accept arguments defining application specific commands, as demonstrated above with isearch_forward and isearch_backward.

  As part of this I might have to expand the kanban per application, or maybe separate kanbans on which functions have been implemented.

*** kanban

This kanban board is keeping track of those original EWOW functions.

The IGNORE column includes functions that I am definitely not going to implement.

The EXTRA section are additional commands that I am adding.

| TODO                             | DOING                        | DONE                         | IGNORE                        |
|----------------------------------+------------------------------+------------------------------+-------------------------------|
| CORE REGION COMMANDS             | ---- VISUAL STUDIO ----      | CORE MOTION COMMANDS         | - scroll_left                 |
| - mark_word                      | - recenter_line              | - forward_char               | - scroll_right                |
| - kill_region                    | - indent_line                | - backward_char              | - open_line                   |
| - yank_pop                       | ---- VSCODE ----             | - forward_word               | - transpose_chars             |
| - delete_backward_char           | - isearch_backwards          | - backward_word              | - transpose_words             |
| - kill_word                      | - isearch_forwards           | - next_line                  | - transpose_lines             |
| - kill_whole_line                | ADD PROGRAM SPECIFIC PRESETS | - previous_line              | CORE CASE CONVERSION COMMANDS |
| CORE NEWLINE AND INDENT COMMANDS |                              | CORE JUMPING AROUND COMMANDS | - upcase_region               |
| - newline                        |                              | - scroll_down                | - downcase_region             |
| - delete_indentation             |                              | - scroll_up                  | - upcase_word                 |
| CORE EDIT COMMANDS               |                              | - move_beginning_of_line     | - downcase_word               |
| - redo                           |                              | - move_end_of_line           | - capitalize_word             |
| - query_replace                  |                              | - beginning_of_buffer        | CORE MACRO RECORDING COMMANDS |
| - overwrite_mode                 |                              | - end_of_buffer              | CORE ADD IGNORE FRAMES        |
| CORE INSERT PAIRS COMMANDS       |                              | - goto_line                  | CORE ADD MOUSE EVENTS         |
| - insert_parentheses             |                              | - mark_whole_line            |                               |
| - insert_comment                 |                              | - mark_whole_buffer          |                               |
| - indent_new_comment_line        |                              | - kill_ring_save             |                               |
| CORE OTHER COMMANDS              |                              | - yank                       |                               |
| - shell                          |                              | - delete_char                |                               |
| - shell_command                  |                              | - backward_kill_word         |                               |
| - facemenu                       |                              | - kill_line                  |                               |
| - help                           |                              | - indent_for_tab_command     |                               |
| CORE SYSTEM COMMANDS             |                              | - undo_only                  |                               |
| - ignore                         |                              | - search_forward             |                               |
| - repeat                         |                              | - search_backward            |                               |
| CORE DIGIT ARGUMENT COMMANDS     |                              | - set_mark_command           |                               |
| CORE FILES COMMANDS              |                              | - set_cx_command             |                               |
| - write_file                     |                              | - keyboard_quit              |                               |
| - find_file                      |                              | - save_buffer                |                               |
| - dired                          |                              | CORE ADD C-X                 |                               |
| CORE WINDOWS FRAMES COMMANDS     |                              | - isearch_backwards          |                               |
| - kill_frame                     |                              | - isearch_forwards           |                               |
| - delete_window                  |                              | - comment_line               |                               |
| - split_window                   |                              | - comment_line               |                               |
| - next_window                    |                              |                              |                               |
| - previous_window                |                              |                              |                               |
| - suspend_frame                  |                              |                              |                               |
| CORE ADD HOOKS                   |                              |                              |                               |
| ADD GENERIC GOTO LINE            |                              |                              |                               |
| CORE ADD KILL RING               |                              |                              |                               |
| - recenter_line                  |                              |                              |                               |
| - indent_line                    |                              |                              |                               |
| EXTRA ERGO PRESET SELECTION      |                              |                              |                               |
| EXTRA                            |                              |                              |                               |
| - ctrl_mapping                   |                              |                              |                               |

** Usage

1. **Install AutoHotKey**: Download and install AutoHotKey from [AutoHotKey's official website](https://www.autohotkey.com/).
2. **Run WOWEE**: Double-click on the `wowee.ahk` script to start WOWEE. Once running, Emacs commands will be available in your Windows environment.
3. **Quit WOWEE**: To quit WOWEE, right-click the AutoHotKey icon in the task tray and select "Exit."

** Configuration

WOWEE is composed of several AutoHotKey scripts, each serving a specific purpose to replicate Emacs functionalities:

*** wowee.ahk

The top level script to be run, contains the following scripts along with some potential ergonomic key-mappings which if not desired can be commented out:

#+begin_src ahk
RAlt::Control
CapsLock::Control
#Include fundamental.ahk
#Include commands.ahk
#Include keybinds-apps.ahk
#HotIf !WinActive("ahk_class Emacs")
#Include keybinds-core.ahk
#Include keybinds-init.ahk
#HotIf
#+end_src

*** fundamental.ahk

This script provides a set of fundamental functions and variables that are used to implement Emacs-like commands and keybindings.

*** commands.ahk

This script includes the basic implementation of Emacs commands.

*** commands_util.ahk

This script contains simple utility functions used by the command scripts.

*** keybinds-core.ahk

This script defines the default core keybindings for Emacs-like commands, which will be a fallback for any windows application.

*** keybinds-apps.ahk

This script defines the application specific commands, typically commands that have been remapped to accommodate the chosen commands.

Comments within the ahk file indicate the potential re-mappings.

*** keybinds-init.ahk

Analogous to the init.el file or Emacs init file in which all the users bespoke keybindings will exist.  An example of my preferred keybindings has been supplied.

* DONE WOWEE - Windows Operating With Emacs Enhancements :wowee:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240623081827-emacs--WOWEE---Windows-Operating-With-Emacs-Enhancements
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-06-24 21:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240623081827-emacs--WOWEE---Windows-Operating-With-Emacs-Enhancements.jpg
:END:

My Emacs usage on Windows seems to be more prevalent at the moment, and I'm having to drop into Visual Studio for C# development.

#+hugo: more

Emacs keybindings are so ingrained into my muscle memory that it would be rather pleasant to leverage this digital advantage when plonking around Windows for all applications.

In Visual Studio this apparently, like most IDE's, can be accomplished via a plug-in, but I think I would like a more wholistic versatile approach, by for example, having Emacs keybindings applied at a global Windows level.

So how do I accomplish this?, I prodded the interwebs and firstly came across *XKeymacs*:

#+begin_quote
XKeymacs provides key bindings like Emacs for applications running
on Microsoft Windows. You can also configure bindings for each
application.
#+end_quote

On running the binary it looks very comprehensive and has a nice intuitive GUI.  However I would like a project I could get my teeth into and I was struggling to build it in a modern version of Visual Studio, this may be something I'll have another look at in the future.  Possibly though my quick abandonment of this idea was more related to an idea I had regarding AutoHotKey (a scripting language which can provide easy keyboard shortcut mapping) and a language that I am already familiar with.

As it turns out there is already an AutoHotKey project that suits my needs and that is *EWOW -- Emacs Way of Operating Windows*, it is defined as follows:

#+begin_quote
+ allows Emacs-like commands and keybinds (almost) everywhere in
  Windows

  - keyboard macros

  - prefix digit-argument
    - ex. C-3 C-n -> go 3 lines down

  - Emacs-style region selection (i.e. set-mark-command)

  - ... etc
#+end_quote

It is essentially a set of AutoHotkey scripts and my AHK familiarity could mean this to be an ideal project to take a closer look at and to have a tinker around.

This project also seems to be well thought out and comprehensive and even provides bonus functionality that I wouldn't have expected, like hooks and even macros!!

It is written however in AutoHotkey V1 and although still currently available it is deprecated and v2 is considered now the main supported version.  V2 is a significant rewrite of the the AHK syntax and to convert EWOW from v1 to v2 might take some significant effort.  I had an initial look to see what was involved and used it as an exercise to start to understand both the magnitude of the porting task and to get familiar generally with EWOW.  More than anything though this activity surfaced an idea for a new project aimed at implementing Emacs-like commands on Windows, focusing especially on the commands I find myself wanting to use most frequently.

My initial idea is to lean heavily on EWOW by taking the basic structure and design principles which could accommodate some future augmentation, such as hooks, macros e.t.c and to declare a form of AHK bankruptcy and start almost from scratch and progress from an AHK V2 base.  Initially I will try and add the most common simple commands using EWOW as a guide and then build up over a period of time to something with more bells on it.

I have created a new project with a nod to the name of EWOW, it is defined below and I will look to gradually introduce more Emacs functionality over the next few months and especially focussing on those commands I keep reaching for when faffing around with Visual Studio.

I have also added a kanban board (using org-kanban, which I will discuss more in a future post) that lists all the EWOW implemented key functions and indicates which ones have been ported. As I become more familiar with this project, I will start to define its scope more clearly. This will likely include deciding on the functionality I choose not to implement. I would like to focus as much as possible on simplicity, with an ergonomic approach in mind. For example, I'm considering options such as mapping Caps and RAlt to Control, providing the option for a Vim-style keybinding, and the ability to create presets through textual modifications of AHK files.

---

** WOWEE - Windows Operating With Emacs Enhancements

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240623081827-emacs--WOWEE---Windows-Operating-With-Emacs-Enhancements.jpg]]

https://github.com/captainflasmr/wowee

WOWEE is a set of AutoHotKey scripts designed to bring Emacs-like commands and keybindings to the Windows operating system. Based on the concept of EWOW (Emacs Way of Operating Windows), WOWEE allows you to use Emacs-style navigation and commands throughout your Windows environment.

** Features

- Emacs-like commands and keybindings in Windows
- Based on EWOW – Emacs Way of Operating Windows
- Written in AutoHotKey v2
- Includes various Emacs style navigation commands

*** kanban

| TODO                        | DOING                   | DONE                   |
|-----------------------------+-------------------------+------------------------|
| scroll_left                 | jumping around commands | motion commands        |
| scroll_right                |                         | forward_char           |
| goto_line                   |                         | backward_char          |
| region commands             |                         | forward_word           |
| mark_word                   |                         | backward_word          |
| mark_whole_line             |                         | next_line              |
| mark_whole_buffer           |                         | previous_line          |
| kill_region                 |                         | scroll_down            |
| yank_pop                    |                         | scroll_up              |
| delete_backward_char        |                         | move_beginning_of_line |
| kill_word                   |                         | move_end_of_line       |
| backward_kill_word          |                         | beginning_of_buffer    |
| kill_whole_line             |                         | end_of_buffer          |
| newline and indent commands |                         | kill_ring_save         |
| newline                     |                         | yank                   |
| open_line                   |                         | delete_char            |
| indent_for_tab_command      |                         | kill_line              |
| delete_indentation          |                         | undo_only              |
| edit commands               |                         | set_mark_command       |
| redo                        |                         | set_cx_command         |
| transpose_chars             |                         | keyboard_quit          |
| transpose_words             |                         | save_buffer            |
| transpose_lines             |                         |                        |
| query_replace               |                         |                        |
| search_forward              |                         |                        |
| overwrite_mode              |                         |                        |
| case conversion commands    |                         |                        |
| upcase_region               |                         |                        |
| downcase_region             |                         |                        |
| upcase_word                 |                         |                        |
| downcase_word               |                         |                        |
| capitalize_word             |                         |                        |
| insert pairs commands       |                         |                        |
| insert_parentheses          |                         |                        |
| insert_comment              |                         |                        |
| indent_new_comment_line     |                         |                        |
| other commands              |                         |                        |
| shell                       |                         |                        |
| shell_command               |                         |                        |
| facemenu                    |                         |                        |
| help                        |                         |                        |
| system commands             |                         |                        |
| ignore                      |                         |                        |
| repeat                      |                         |                        |
| digit argument commands     |                         |                        |
| macro recording commands    |                         |                        |
| files commands              |                         |                        |
| write_file                  |                         |                        |
| find_file                   |                         |                        |
| dired                       |                         |                        |
| windows frames commands     |                         |                        |
| kill_frame                  |                         |                        |
| delete_window               |                         |                        |
| split_window                |                         |                        |
| next_window                 |                         |                        |
| previous_window             |                         |                        |
| suspend_frame               |                         |                        |
| add hooks                   |                         |                        |
| add ignore frames           |                         |                        |
| add goto line               |                         |                        |
| add kill ring               |                         |                        |
| add mouse events            |                         |                        |
| add C-x                     |                         |                        |

** Usage

1. **Install AutoHotKey**: Download and install AutoHotKey from [AutoHotKey's official website](https://www.autohotkey.com/).
2. **Run WOWEE**: Double-click on the `wowee.ahk` script to start WOWEE. Once running, Emacs commands will be available in your Windows environment.
3. **Quit WOWEE**: To quit WOWEE, right-click the AutoHotKey icon in the task tray and select "Exit."

** Configuration

WOWEE is composed of several AutoHotKey scripts, each serving a specific purpose to replicate Emacs functionalities:

*** fundamental.ahk

This script provides a set of fundamental functions and variables that are used to implement Emacs-like commands and keybindings.

*** commands.ahk

This script includes the basic implementation of Emacs commands.

*** commands_util.ahk

This script contains simple utility functions used by the command scripts.

*** keybinds.ahk

This script defines the default keybindings for Emacs-like commands.

** Installation and Setup

1. **Download WOWEE**: Download the WOWEE scripts from the repository.
2. **Extract Files**: Extract the files to a directory of your choice.
3. **Run the Script**: Double-click `wowee.ahk` to start using WOWEE.

** Customization
*** Editing Keybindings

You can customize the keybindings by editing the `keybinds.ahk` file. Open the file in any text editor and modify the keybindings according to your preferences. Refer to the AutoHotKey documentation for the syntax and available key options.

*** Adding New Commands

To add new commands, you can edit the `commands.ahk` and `commands_util.ahk` files. Define your new commands and utility functions, and then bind them to keys in `keybinds.ahk`.

** Troubleshooting

If you encounter any issues while using WOWEE, try the following steps:

1. **Check AutoHotKey Version**: Ensure you have the latest version of AutoHotKey installed.
2. **Script Errors**: If there are errors in the script, AutoHotKey will usually display a message with details. Use this information to debug and fix the issue.
3. **Conflicting Programs**: Some programs might have conflicting keybindings. Try closing other programs to see if the issue is resolved.

** Contributing

Contributions to WOWEE are welcome! If you have suggestions for improvements or want to add new features, feel free to submit a pull request.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/YourFeature`)
3. Commit your changes (`git commit -am 'Add your feature'`)
4. Push to the branch (`git push origin feature/YourFeature`)
5. Create a new pull request

** License

WOWEE is licensed under the MIT License. See the LICENSE file for more details.

** Acknowledgements

Special thanks to the creator of EWOW, from whom I have derived significant inspiration: https://github.com/zk-phi/ewow

Special thanks to the creators of AutoHotKey and the Emacs community for their inspiration and contributions to keyboard efficiency.

** Contact

For any questions or issues, please open an issue on the GitHub repository or contact the maintainer at captainflasmr@gmail.com

---

Enjoy using WOWEE and bring the power of Emacs navigation to your Windows experience!

* DONE Using A Mechanical Keyboard, Literally On A Laptop! :sticky_keys:keyboard:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240414121636-emacs--Using-A-Mechanical-Keyboard-On-A-Laptop
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-06-08 16:55>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240414121636-emacs--Using-A-Mechanical-Keyboard-On-A-Laptop.jpg
:END:

The next stage on my quest to mitigate any RSI issues when using Emacs on a laptop is to see if it is a viable option to use a mechanical keyboard on a laptop.

#+hugo: more

When I mean "on a laptop" I literally mean *ON* the laptop!!

My idea is to buy a smallish portable mechanical keyboard and just plonk it (technical term) over my current laptop keyboard.

At the moment I know nothing about mechanical keyboards, I just know from an RSI perspective they are generally a good idea.  I do miss the feeling of key travel and I am aware at times I'm tapping too hard on my laptop keyboard due to their shallow depth.

So here is the keyboard in its fully installed glory - extreme plonkification!

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240414121636-emacs--Using-A-Mechanical-Keyboard-On-A-Laptop.jpg]]


I however encountered notable difficulties that depended largely on the placement of the keyboard's feet in relation to the laptop's built-in keyboard.  Spamming of a single key press was a common issue and was due to my built-in laptop still being enabled when the mech-keyboard was plugged in.

Simply solved however with a bash script to disable the laptop keyboard when the mech is plugged in.

Note: this will be SwayWM specific but can easily be adapted by replacing the swaymsg command.

#+begin_src bash
KEYBOARD_CONNECTED=0

while :
do
    if [[ -L "/dev/input/by-id/usb-SEMICO_USB_Gaming_Keyboard-event-kbd" ]]; then
        if [[ $KEYBOARD_CONNECTED == 0 ]]; then
            KEYBOARD_CONNECTED=1
            notify-send -t 3000 "KEYBOARD CONNECTED!"
            swaymsg input 1:1:AT_Translated_Set_2_keyboard events disabled
        fi
    else
        if [[ $KEYBOARD_CONNECTED == 1 ]]; then
            KEYBOARD_CONNECTED=0
            notify-send -t 3000 "KEYBOARD DISCONNECTED!"
            swaymsg input 1:1:AT_Translated_Set_2_keyboard events enabled
        fi
    fi

    sleep 2
done
#+end_src

Now I can use Emacs on a laptop without the drawbacks of using a shallow laptop keyboard.

The next ergo improvement might now be trying to find a better resting hand position as the new mech-keyboard is raised by an inch or so, but that will be for another ergpost...

* DONE New Package, xkb-mode, to edit X Keyboard Extension Files :sticky_keys:package:melpa:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240524160249-emacs--New-Package-xkb-mode
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-05-24 16:12>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240524160249-emacs--New-Package-xkb-mode.jpg
:END:

Based on my recent forays into ergonomic key-mapping in Emacs for SwayWM, and effectively for any Wayland compositor or X11-based system using the X Keyboard Extension (XKB) standard, I realized that there doesn't seem to be an Emacs mode to edit these keyboard configuration files (*.xkb). This is surprising, considering they have been around for more than 30 years!

#+hugo: more

So I wrote one, and its on MELPA.

---
#+TOC: headlines 1 local
---

** Summary

A Major mode for editing X Keyboard Extension (XKB) files

xkb-mode is an Emacs major mode designed to facilitate the editing of XKB files, providing syntax highlighting and other useful editing features tailored specifically for XKB file format. Whether you're customizing keyboard layouts or diving into the details of X Keyboard Extension configurations, xkb-mode aims to make the task more efficient and enjoyable.

*** Whats New

Version 0.2.0

- Correct version from 0.6.0 to 0.2.0 to reflect the actual stage of
  development.
- Remove the 'Alternatives' section, streamlining the introduction.
- Improve code formatting for better readability and maintenance. This
  includes more consistent use of newlines and arrangement of font lock
  faces.
- Use `#'` prefix for function symbols as a best practice, explicitly
  marking `xkb-indent-line` as a function, enhancing code clarity.

*** Screenshot

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240524160249-emacs--New-Package-xkb-mode.jpg]]

** Features

- Syntax highlighting for XKB-specific keywords, modifiers, and structures.
- Custom indentation logic for XKB code blocks.
- Auto-detection of .xkb files to automatically enable the mode.

** Installation

To install xkb-mode, you can use the following methods:

*** use-package (MELPA)

#+begin_src elisp
(use-package xkb-mode)
#+end_src

*** use-package (emacs 29)

Put the following into your emacs init file:

#+begin_src elisp
(use-package xkb-mode
  :vc (:fetcher github :repo "captainflasmr/xkb-mode"))
#+end_src

*** from source

Download the `.el` file and place it in your Emacs `load-path`.

Then either manually load it or add it to your configuration to be loaded at startup.

#+begin_src elisp
(require 'xkb-mode)
#+end_src

** Usage

Opening any .xkb file with Emacs should automatically enable xkb-mode, providing you with syntax highlighting and indentation support for editing XKB files.

** Customization

Currently, xkb-mode provides a basic set of features optimized for general usage. Future versions may include customizable options based on user feedback.

** Contributing

Contributions to xkb-mode are welcome! Whether it's bug reports, feature suggestions, or code contributions, feel free to reach out or submit pull requests on GitHub.

** License

xkb-mode is available under the terms of the GNU General Public License v3.0. See the included LICENSE file for more details.

** Contact

For any questions or suggestions, please contact James Dyer at captainflasmr@gmail.com.

Visit our GitHub repository: https://github.com/captainflasmr/xkb-mode for more information and updates.

This README provides a concise but comprehensive overview of what the `xkb-mode` package is, how to get it installed, and how to use it, alongside encouraging community contributions and providing licensing info.

** ISSUES

NONE

** TODOs / ROADMAP

TODO function to set xkb file to latched sticky keys

TODO function to set xkb file locked sticky keys

TODO function to map RAlt to Ctrl

** Testing

See CHANGELOG.org

* DONE Writing Elisp to Find Available Keybindings in a Sway Config :sway:emacs:elisp:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240516070645-emacs--Elisp-Help-Find-Free-Bindings-In-Sway
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-05-16 18:25>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240516070645-emacs--Elisp-Help-Find-Free-Bindings-In-Sway.jpg
:END:

I thought I would provide an example of how I typically use elisp to make my life easier (well eventually - I still need to write the function after all!)

#+hugo: more

#+begin_src plantuml :file emacs/20240516070645-emacs--Elisp-Help-Find-Free-Bindings-In-Sway.jpg
@startwbs
!theme materia
,* Sway config
,** parse file
,** collect $mod keybindings
,** sort
,** output
@endwbs
#+end_src

#+attr_org: :width 300px
#+attr_html: :width 100%
#+RESULTS:
[[file:static/emacs/20240516070645-emacs--Elisp-Help-Find-Free-Bindings-In-Sway.jpg]]

In the example below, I wanted to find a simple elispy method to determine which Sway keybindings are available, specifically those that utilize the $mod key (typically Mod4/Super). Running out of available $mod keybindings in Sway, and then realizing upon reload that I have inadvertently added a duplicate keybinding, can be quite frustrating.

When this happens, I usually then have to resort to scrolling through the config file or using `isearch` to determine which keybindings are available.  This can be tedious and is made more difficult in that my keybindings are not listed alphabetically but are grouped by function.

I am having a similar problem with Emacs but that is where the package *free-keys* comes in handy, listing the free and available keybindings.

---

I initially wanted to create something similar to *free-keys* for Sway, but by parsing the Sway configuration file and generating a report.

A Sway config file is typically defined in the following format:

#+begin_src conf
# Set Defaults
set $mod Mod4
set $left h
set $down j
set $up k
set $right l

# Key bindings
bindsym $mod+b exec toggle_waybar.sh
bindsym $mod+c exec screen-record.sh
bindsym $mod+e exec thunar ~/DCIM/Camera
bindsym $mod+m exec emacs
bindsym $mod+n exec firefox
bindsym $mod+p exec wl-color-picker
bindsym $mod+q kill
bindsym $mod+return exec $term

# Change window focus
bindsym $mod+Left focus left
bindsym $mod+Down focus down
bindsym $mod+Up focus up
bindsym $mod+Right focus right
bindsym $mod+$left focus left
bindsym $mod+$down focus down
bindsym $mod+$up focus up
bindsym $mod+$right focus right
#+end_src

For now, to keep things simple, I will focus solely on writing elisp to list the current Sway keybindings that use Mod4 or any alias for Mod4 in alphabetical order. Then, by visually scanning and leveraging the human brain's familiarity with the alphabet, I can determine which keybindings are unused!

For example, my new elisp function could yield the following typical output for the sway snippet defined above:

#+begin_src conf
Mod4+Down
Mod4+Left
Mod4+Right
Mod4+Up
Mod4+b
Mod4+c
Mod4+e
Mod4+h
Mod4+j
Mod4+k
Mod4+l
Mod4+m
Mod4+n
Mod4+p
Mod4+q
Mod4+return
#+end_src

Now I should be able to more easily gauge which bindings are not used.

Of course my full Sway config has many more Mod4 keybindings and when running the elisp function defined below I realised I now only have 3 alphabetical mappings left for $mod - eeek!, but at least I now know what they are and don't have to go trawling through the config anymore.

...wait, um, just as a side note, while I'm editing this blog post, it has just occurred to me (pardon the pun), can I use *occur*, push to a buffer then re-order, mmmm....., well lets ignore that thought for now, I want to dig into some elisp, its a learning experience after all!!

Here is the elisp:

#+begin_src elisp
(defun swaywm-list-mod-bindsyms (path)
  "List all bindsyms that start with $mod or its resolved value in the SwayWM config file at PATH."
  (interactive "fSway config file path: ")
  (with-temp-buffer
    (insert-file-contents path)
    (goto-char (point-min))
    (let ((vars nil)
          (bindsyms nil))
      ;; Collect variable definitions
      (while (re-search-forward "^set \\$\\([a-zA-Z0-9_]+\\) \\(.*\\)$" nil t)
        (let ((var (match-string-no-properties 1))
              (value (match-string-no-properties 2)))
          (setq vars (cons (cons var value) vars))))
      ;; Prepare to translate $mod and other keys
      (let* ((mod (cdr (assoc "mod" vars)))
             (left (cdr (assoc "left" vars)))
             (down (cdr (assoc "down" vars)))
             (up (cdr (assoc "up" vars)))
             (right (cdr (assoc "right" vars)))
             (mod-re (format "\\(%s\\|$mod\\)" (regexp-quote mod))))
        (goto-char (point-min))
        ;; Collect all bindings that start with $mod or its resolved value
        (while (re-search-forward (format "^bindsym %s\\+\\([^ ]+\\) \\(.*\\)$" mod-re) nil t)
          (let* ((mod-key (match-string-no-properties 1))
                 (action (match-string-no-properties 2))
                 (full-key (concat mod "+" action)))
            ;; Replace variable references in keys
            (setq full-key (replace-regexp-in-string "\\$left" left full-key))
            (setq full-key (replace-regexp-in-string "\\$down" down full-key))
            (setq full-key (replace-regexp-in-string "\\$up" up full-key))
            (setq full-key (replace-regexp-in-string "\\$right" right full-key))
            ;; Replace $mod with the actual mod key or keep as $mod for clarity
            (setq full-key (replace-regexp-in-string "\\$mod" mod full-key))
            ;; Collect the key-action pair
            (setq bindsyms (cons (format "%s" full-key) bindsyms)))))
      ;; Return reversed to maintain order
      (mapconcat 'identity (sort (nreverse bindsyms) 'string-lessp) "\n"))))
#+end_src

and to call just by:

#+begin_src elisp
(swaywm-list-mod-bindsyms "~/.config/sway/config.d/default")
#+end_src

or interactively.

I might evolve this a little more over the coming weeks (and actually maybe this is where *occur* and in-house Emacsing may at last have its limitations!).  There is potentially a lot to do, for example some such improvements could be :
- iterate over multiple files to accommodate a typical distributed Sway configuration set
- show bindings that are free - just like *free-keys*
- make more generic for multiple different types of config files containing bindings such as :
  - hyprland
  - other tiling window managers that typically define bindings in config files
  - emacs ?!
- translate all aliases not just the common $left, $right, $up, $down

---

Here is a mini manual for this function :

---
#+TOC: headlines 2 local
---

** Manual for swaywm-list-mod-bindsyms

List and sort bindsym commands from a SwayWM configuration file that are assigned to the mod key.

*** Synopsis

#+begin_src elisp
(swaywm-list-mod-bindsyms PATH)
#+end_src

*** Description

The `swaywm-list-mod-bindsyms` function parses a specified SwayWM configuration file and extracts all `bindsym` commands that begin with the modifier key (usually designated as `$mod` in SwayWM configurations). The resolution of the `$mod` key, along with other potential sway variables like `$left`, `$down`, `$up`, and `$right`, is dynamically handled according to their definitions within the file. The commands are then returned as a single string, with each bindsym command on a new line, sorted alphabetically.

This function is particularly useful for users of the Sway Window Manager who wish to quickly audit their keybindings associated with the mod key — a common requirement for optimizing workflow efficiency or for documentation purposes.

*** Parameters

- `PATH`: Path to the SwayWM configuration file to be parsed.

*** Usage

To use `swaywm-list-mod-bindsyms`, call the function with the path to your SwayWM configuration file as its argument. For interactive use:

#+begin_src elisp
M-x swaywm-list-mod-bindsyms
#+end_src

When prompted, enter the full path to your SwayWM configuration file. The output will be shown, depending on the Emacs settings, either directly in the minibuffer (for shorter lists) or in a separate buffer for longer outputs.

*** Example

Assuming there's a SwayWM configuration file located at `~/sway/config`, you would use the function as follows:

#+begin_src elisp
M-x swaywm-list-mod-bindsyms RET ~/sway/config RET
#+end_src

The returned value will be a sorted list of all `bindsym` commands associated with the `$mod` key or its resolved value (e.g., `Mod4`) from the file, neatly formatted for easy inspection.

*** Notes

- This function assumes a standard formatting of the SwayWM configuration file, as deviations might affect the parsing logic.
- The sorting is done in a case-sensitive alphabetical order, following Emacs' `string-lessp` function conventions.
- All modifications to variables like `$mod`, `$left`, `$down`, `$up`, and `$right` are dynamically accounted for based on their set values in the configuration file.

  ---

* DONE Emacs Vim Navigation Without Evil :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240504183551-emacs--Emacs-Vim-Navigation-Without-Evil
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-05-11 21:40>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240504183551-emacs--Emacs-Vim-Navigation-Without-Evil.jpg
:END:

Every now and then I find it necessary to use Vim! (mainly for work) - was that clickbait on an Emacs blog?! 😀

#+hugo: more

---
#+TOC: headlines 1 local
---

#+begin_src plantuml :file emacs/20240504183551-emacs--Emacs-Vim-Navigation-Without-Evil.jpg
!pragma layout smetana
hide footbox
box "Emacs Vim Navigation Without Evil" #lightblue
h -> j
j -> k
k -> l
end box
#+end_src

#+attr_org: :width 300px
#+attr_html: :width 100%
#+RESULTS:
[[file:static/emacs/20240504183551-emacs--Emacs-Vim-Navigation-Without-Evil.jpg]]

** Introduction

I therefore like to have the muscle memory for basic Vim navigation keybindings already built up as that for me is half the battle when using Vim and I also appreciate the efficiency and natural feel of the navigation keybindings `hjkl`.

In light of this I have decided to incorporate this Vim navigation paradigm into Emacs.  My muscle memory is already fully baked and attuned to the Emacs default navigation keys so why not learn something new? with the benefits of an already oven warm familiar feel if I do have to use Vim and maybe anything else that might support vim keybindings (which is not uncommon), for example =pacseek= and seemingly most browser key navigation add-ons.

** Modal Editing and Emacs

Of course before delving a little further I shall have to talk about the herd of elephants in the room... and that is the current plethora of Emacs modal editing packages, such as `evil-mode`, `Meow` et al.  They have been developed to bridge the modal gap, for example, `evil-mode` is a comprehensive emulation layer that replicates Vim's keybindings and modes, offering Vim users a more familiar experience within Emacs. On the other hand, `Meow` presents a more streamlined approach, designed with simplicity in mind, aiming to provide the efficiency of modal editing without mirroring Vim's functionality in its entirety.

** My Non-Modal Solution

Despite the advantages of these packages, I wanted to find a method that involves neither the full adoptation of `evil-mode` nor the simplified modal editing of `Meow` or anything similar. My goal here is to utilize Vim's `hjkl` navigation keys within Emacs in a non-modal context, thereby retaining Emacs's modeless editing advantages while enjoying the familiarity and comfort of Vim's navigation system.

To achieve this, I tapped into the power of Emacs's keybinding customization capabilities.

Simply, I reassigned the original Emacs functions defined by `M-hjkl`.  This allows a Vim-style navigation in Emacs's default mode-less environment using the following keybindings:

#+begin_src elisp
(bind-key* (kbd "M-h") #'backward-char)
(bind-key* (kbd "M-j") #'next-line)
(bind-key* (kbd "M-k") #'previous-line)
(bind-key* (kbd "M-l") #'forward-char)
#+end_src

The original functions bound to these keys were seldom used in my workflow so I didn't mind replacing them:

- `M-h` (`mark-paragraph`) found a new home at `M-s h`.
- `M-j` (`default-indent-new-line`), which I rarely used, was easily replaced by simply using `tab` or `C-i`.
- `M-k` (`kill-sentence`), another feature I never utilized, was made redundant by the use of `kill-line`.
- `M-l` (`downcase-word`), also rarely used, didn’t find a new binding as it wasn’t needed in my daily tasks.

The only disadvantage is that it requires holding down the Meta (or Alt) key with my left hand, but ergonomically that doesn't seem too bad as that will be the only requirement for my left hand as my right will be busy with the navigation.

** Conclusion

While `evil-mode` and `Meow` offer powerful modal editing solutions that closely mimic or simplify Vim's interface within Emacs, my approach demonstrates an alternative path. By creatively reassigning keybindings, I have integrated Vim's efficient navigation into Emacs without adopting a modal editing framework, blending the best of both worlds to enhance my text editing efficiency. This approach underscores the adaptability of Emacs, proving it to be an incredibly versatile tool that can accommodate a wide range of user preferences and workflows.

* DONE How To Map RAlt to Ctrl for Emacs :xkb:wayland:sway:sticky_keys:plantuml:kmonad:emacs:autohotkey:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240425213402-emacs--How-To-Map-Ralt-to-Ctrl
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-05-04 15:30>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240425213402-emacs--How-To-Map-Ralt-to-Ctrl-puml.jpg
:END:

In a recent post I was talking about the benefits of mapping the RAlt key to the Ctrl key and this set up is so far still feeling very comfortable.

#+hugo: more

However, there are many ways to set up the mapping, so below are instructions on how to map the right Alt key (RAlt) to Ctrl for different platforms. These are just the methods I have used in the past, I'm sure there are a multitude of other options out there.

---
#+TOC: headlines 1 local
---

Before you dive in, here is a rough plantuml diagram to give you a top level diagrammatical overview of what I am describing below (note: kmonad is not included):

#+name: workflow1
#+begin_src plantuml :file emacs/20240425213402-emacs--How-To-Map-Ralt-to-Ctrl-puml.jpg
!pragma layout smetana
title: How To Map Ralt to Ctrl Activity Diagram
start
:Start;

if (OS == "Linux") then (yes)
   if (Environment == "X11 or Wayland") then (yes)
     :Generate xkb file;
     note right
       xkbcomp $DISPLAY -xkb keymap.xkb
     end note

     :Modify keymap.xkb;
     note right
       Add modifier_map and key definitions
     end note

     :Load modified file;
     note right
       xkbcomp keymap.xkb $DISPLAY
     end note

     :For persistence,\nadd to startup applications or\n.bashrc/.profile;
   endif

   if (Environment == "X11") then (yes)
     :Choose Tool;
     if (Tool == "xmodmap") then (yes)
       :Create/Edit .Xmodmap;
       :Add keycode modification;
       :Apply changes;
       note right
         xmodmap ~/.Xmodmap
       end note
     else (no)
       :Run setxkbmap command;
       note right
         setxkbmap -option ctrl:ralt_rctrl
       end note
     endif
     :For persistence,\nadd to startup applications or\n.bashrc/.profile;
   endif

   if (Environment == "Wayland TWM") then (yes)
     :Modify sway/hyprland config;
     note right
       Depending on the window manager, apply the necessary `input` configurations.
     end note
     :For persistence, ensure\nconfig is loaded on login;
   endif
 else (no)
   :Install AutoHotkey;
   :Create and Edit Script;
   :Run Script;
   note right
     Script contains key remappings like RAlt::Ctrl
   end note
   :For persistence, place in "Startup" folder;
 endif

 stop
#+end_src

#+attr_org: :width 300px
#+attr_html: :width 100%
#+RESULTS: workflow1
[[file:static/emacs/20240424142938-emacs--Emacs-Over-The-Last-30-Years_d3.jpg]]

** Linux
*** X11 or Wayland
**** xkb (X Keyboard Extension)

First generate an xkb file which defines all keybindings for the current layout by running the follwing command:

#+begin_example
xkbcomp $DISPLAY -xkb keymap.xkb
#+end_example

Add to the keymap.xkb file along with the other defined modifier_maps:

#+begin_example
modifier_map Mod1 { <RALT> };
#+end_example

and set the definition of key to:

#+begin_example
key <RALT> { [ Alt_L, Meta_L ] };
#+end_example

Now load the modified file back in again:

#+begin_example
xkbcomp keymap.xkb $DISPLAY
#+end_example

If you want it to be applied every time you log in, you can add this command to your startup applications or add it to your .bashrc or .profile file.

*** X11 only
**** xmodmap

Xmodmap is a little archaic these days and is seen as being a little deprecated and soon to become obsolete (especially with the incoming Wayland protocol) but especially on X11 it can still be used if you don't want to fiddle around with xkb files.

To map the right Alt key (RAlt) to Ctrl using xmodmap in Linux, you can follow these steps:

Create a file named .Xmodmap in your home directory if it doesn't exist already.

Add the following line to the file:

#+begin_example
keycode <keycode_of_RAlt> = Control_L
#+end_example

Replace with the keycode of your right Alt key.

To find the keycode, you can use the xev command. Open a terminal and run:

xev

This will open a small window. Move your cursor into that window and press the right Alt key. Look for the keycode in the terminal output. It should look something like keycode 108 (maybe exactly like!)

To apply the changes, run:

#+begin_example
xmodmap ~/.Xmodmap
#+end_example

Now your right Alt key should behave like the Ctrl key. Keep in mind that this mapping will only persist for your current session. If you want it to be applied every time you log in, you can add the xmodmap ~/.Xmodmap command to your startup applications or add it to your .bashrc or .profile file.

**** setxkbmap

Simply run the following command:
#+begin_example
setxkbmap -option ctrl:ralt_rctrl
#+end_example

If you want it to be applied every time you log in, you can add this command to your startup applications or add it to your .bashrc or .profile file.

*** Wayland Tiling Window Managers
**** Sway

Perform the xkb steps defined above and then modify the sway config file as follows:

#+begin_example
input type:keyboard {
   xkb_file keymap.xkb
}
#+end_example

alternatively modify the sway config file as follow:

#+begin_example
input type:keyboard {
    xkb_options ctrl:ralt_rctrl
}
#+end_example

As this is modifying the basic config file it will be guaranteed to be loaded every time you log in.

**** Hyprland

As the xkb steps above and then modify the hyprland config file as follows:

#+begin_example
input {
   kb_file = keymap.xkb
}
#+end_example

alternatively modify the hyprland config file as follow:

#+begin_example
input {
   kb_options = caps:ctrl_modifier
}
#+end_example

As this is modifying the basic config file it will be guaranteed to be loaded every time you log in.

--------------

** Windows
*** AutoHotKey

Install AutoHotkey if you haven't already. You can download it from the official website: https://www.autohotkey.com/

Once AutoHotkey is installed, right-click on your desktop or in a folder, hover over "New," and select "AutoHotkey Script." Name the script whatever you like, for example, RAlt_to_Ctrl.ahk.

Right-click the newly created script file and select "Edit Script" to open it in your default text editor.

Add the following line to the script:

#+begin_example
RAlt::Ctrl
#+end_example

Save the script and close the text editor.

Double-click the script file to run it. You should see a green "H" icon in the system tray indicating that the script is running.

Now, whenever you press the right Alt key, it will function as the Ctrl key. To stop the remapping, right-click the AutoHotkey icon in the system tray and select "Exit."

This remapping will persist until you close the script or disable AutoHotkey. If you want the remapping to be applied automatically every time you start your computer, you can place a shortcut to the script in the "Startup" folder of your Start Menu.

--------------

** Linux or Windows
*** kmonad

Install kmonad if you haven't already. You can find installation
instructions on the GitHub repository: https://github.com/kmonad/kmonad

Once kmonad is installed, create a configuration file called kmonad.hs

**** linux

Add the following lines :

#+begin_example
(defcfg
  input  (device-file "/dev/input/by-path/<device>")
  output (uinput-sink "My KMonad output")

  ;; Comment this if you want unhandled events not to be emitted
  fallthrough true

  ;; Set this to false to disable any command-execution in KMonad
  allow-cmd true
  )

(defsrc ralt)

(deflayer default lctrl)
#+end_example

Now on the command line run up:

#+begin_example
kmonad kmonad.hs
#+end_example

To ensure that the mapping persists place the command to your startup
applications or add it to your .bashrc or .profile file.

**** windows

#+begin_example
(defcfg
  input (low-level-hook)
  output (send-event-sink)
  fallthrough true)

(defsrc ralt)

(deflayer default lctrl)
#+end_example

Now create a batch script called kmonad.bat and add:

#+begin_example
kmonad.exe kmonad.hs
#+end_example

This remapping will persist until you close kmonad.exe. If you want the
remapping to be applied automatically every time you start your
computer, you can place a shortcut to the script in the "Startup" folder
of your Start Menu.

---

This post may end up turning into some kind of living document when I find out other ways to perform the mapping, for example I might start to look at Kanata and also see if PowerToys can perform this mapping on Windows.

* DONE My Emacs Key Workflow Moments Over The Last 30 Years :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240424142938-emacs--Emacs-Over-The-Last-30-Years
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-04-26 15:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240424142938-emacs--Emacs-Over-The-Last-30-Years_d1.jpg
:END:

I am just at the moment reflecting on how my experience with Emacs over the last 30 years has evolved.  I thought that just for fun I would list all the key moments along my Emacs journey regarding work-flow efficiency breakthroughs, roughly in year order!.

#+hugo: more

I think you can see that my investment of time has spiked in recent years, probably spurred on by writing this blog!

Firstly I went through the barren years... :

#+name: workflow1
#+begin_src plantuml :file emacs/20240424142938-emacs--Emacs-Over-The-Last-30-Years_d3.jpg
!pragma layout smetana
!theme mars
skinparam backgroundColor #eeeeee
skinparam sequenceArrowThickness 1
skinparam DefaultFontSize 20
skinparam roundcorner 20
hide footbox
-> 1994 : learning emacs at University
-> 2000 : mapped caps lock to ctrl
-> 2002 : desktop save mode
-> 2010 : using dired to replace native file explorer
-> 2016 : elisp defuns for common tasks
-> 2016 : savehist-mode
-> 2016 : winner mode
-> 2017 : ivy
-> 2018 : dabbrev
-> 2019 : rebinding keys to match usage frequency
-> 2019 : imenu for navigation
-> 2019 : macros for repetitive tasks
#+end_src

#+attr_org: :width 300px
#+attr_html: :width 100%
#+RESULTS: workflow1
[[file:static/emacs/20240424142938-emacs--Emacs-Over-The-Last-30-Years_d3.jpg]]

and then when I started to get a little more serious about Emacs :

#+name: workflow2
#+begin_src plantuml :file emacs/20240424142938-emacs--Emacs-Over-The-Last-30-Years_d2.jpg
!pragma layout smetana
!theme mars
skinparam backgroundColor #eeeeee
skinparam sequenceArrowThickness 1
skinparam DefaultFontSize 20
skinparam roundcorner 20
hide footbox
-> 2021 : grep with deadgrep
-> 2021 : magit
-> 2021 : leader key definition M-<key> - to take load off ctrl
-> 2021 : hippie expand
-> 2022 : vertico, orderless, marginalia
-> 2022 : embark for quick actions
-> 2023 : tempel - unique 2 characters to insert common templates
-> 2023 : vim cursor movement (without evil) - so fingers remain on home row
-> 2023 : moving to tabs to switch between windows setups
-> 2023 : tab bar history
-> 2024 : sticky keys - single key presses, no key chording
-> 2024 : using a mechanical keyboard
-> 2024 : mapped ralt to ctrl - to take complete load off even the caps lock remapping
-> 2024 : capf-autosuggest in [e]shell to get a more fish like experience
-> 2024 : org mode speed keys - single key presses for common org commands
#+end_src

#+attr_org: :width 300px
#+attr_html: :width 100%
#+RESULTS: workflow2
[[file:static/emacs/20240425213402-emacs--How-To-Map-Ralt-to-Ctrl-puml.jpg]]

Note that I have endeavoured to incorporate some level of completion framework into my work-flow, systems such as *company* and *corfu* but I always end up just using hippie-expand wrapped around dabbrev.

I think this is why I have always been drawn to Emacs, it is just me and a text editor, there is no clutter and no distractions, although there is so much more to Emacs than just a text editor, everything else is hidden away.  I don't really want inline completion popups as I type, I don't need a menu bar, scroll bars, a source code tree and I tend to always work on a single monitor so the saving on screen real estate is very beneficial to the way I work.

I am a Software Engineer now of 30 years, I am stuck in my ways, stuck with Emacs, but I am happy, productive and efficient!

P.S. and yes I'm starting to play around with plantuml 🙂

* TODO Plantuml-Setup-In-Emacs :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240421094624-emacs--Plantuml-In-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-04-21 09:46>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240421094624-emacs--Plantuml-In-Emacs.jpg
:END:

** install

To enable plantuml (local installation) in emacs perform the following:
#+hugo: more

- install openjdk (jdk21-openjdk) - for java > 8.1
- download plantuml.jar and move to <user-emacs-directory>
- in Emacs, install the plantuml-mode package

**** GraphViz (optional)

Depending on diagrams you want to generate, PlantUML might need a working version of GraphViz to be able to generate the following diagrams:

Usecase diagrams
Class diagrams
Object diagrams
Component diagrams
Deployment diagram
State diagrams
Legacy activity diagrams

There is however an alternative by putting in the following pragma at the start of the plantuml syntax  Since version 1.2021.5, you can experimentally use PlantUML without installing Graphviz using Semtana which is an experimental port of GraphViz from C to Java, this may or may not work for you so it is work a try first before you install GraphViz:

!pragma layout smetana

** setup

By default for plantuml-mode =plantuml-default-exec-mode= is set to /server/ but I prefer to use the local jar file just downloaded, in this case we need to add the following to the emacs init :

#+begin_src elisp
(use-package plantuml-mode
  :custom
  (plantuml-default-exec-mode 'jar)
  (plantuml-jar-path (concat user-emacs-directory "plantuml.jar"))
  (org-plantuml-jar-path (concat user-emacs-directory "plantuml.jar")))
#+end_src

Now adding something like the following running in =plantuml-mode= and C-c C-c will generate a plantuml diagram in an emacs buffer:

@startuml
:plant;
:uml;
@enduml

** org babel

to enable org babel functionality add the following:

#+begin_src elisp
(add-to-list
 'org-src-lang-modes '("plantuml" . plantuml))

(org-babel-do-load-languages
 'org-babel-load-languages
 '((plantuml . t)))

(add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode))
#+end_src

and then insert the following for text inserted into buffer:

#+begin_src plantuml :results verbatim
:plant;
:uml;
#+end_src

or to a file;

#+begin_src plantuml :file file.png
:plant;
:uml;
#+end_src

** troubleshooting

When running from org bable something like the following comes up :

#+begin_src bash
: java.io.IOException: Cannot run program "/opt/local/bin/dot": error=2, No such file or directory
#+end_src

Then it is likely that GraphViz (dot) needs to be installed.

or if running from *.plantuml so an SVG is generated and not being able to be loaded by emacs with something like :

#+begin_src bash
Error parsing SVG image: XML parse error: Error domain 1 code 4 on line 1 column 1 of data: Start tag expected, '<' not found
#+end_src

* DONE Transitioning RAlt to Ctrl - Enhancing Emacs Keybindings :sticky_keys:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240417211640-emacs--Transitioning-RAlt-to-Ctrl-Enhancing-Emacs-Keybindings
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-04-20 10:12>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240417211640-emacs--Transitioning-RAlt-to-Ctrl-Enhancing-Emacs-Keybindings.jpg
:END:

In the midst of adjusting my Emacs keybindings for a more ergonomic workflow, I've experimented with various configurations.  For example, I duplicated the right Alt key (RAlt) to function as an additional Alt key allowing for versatile key presses across the keyboard based on command keybinding locations.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240417211640-emacs--Transitioning-RAlt-to-Ctrl-Enhancing-Emacs-Keybindings.jpg]]

The RAlt key is certainly accessible with a little curl under of the right thumb and a modifier key activator I hadn't even considered before.

For instance, I found combinations like M-n and M-p already comfortable with a left hand / right hand split, but with RAlt for activating Meta/Alt a right hand / left hand split became possible for certain commands, notably M-f and M-w which I often use.  This theoretically already felt a more comfortable setup.

However, after a few months, I realized I couldn't quite find a way to transition to the RAlt remapping; I simply wasn't using it. Yet, the initial experiment hinted at the potential of shifting modifier load to the right hand, especially leveraging the strong thumb for ergonomic advantages.

Then it struck me: what if I map RAlt to Ctrl?, I immediately questioned why I hadn't tried it earlier!

The transition so far has unveiled the following (note: I may have got carried away with the detail here, but in a way its fun to weigh up the pros and cons!):

*Benefits*

- Splitting common prefixes like C-x and C-c between hands.
- Enhanced comfort in isearch with split hand C-r and C-s.
- Improved buffer window navigation, with RLR (Right Left Right) pattern for C-x o.
- Simplified buffer window splits with C-x <num>.  Although there are typically two consecutive left hand key activations, sticky keys allows just two individual key taps of x then <num>.
- Streamlined actions like the common C-c C-c, with the option of holding RAlt allowing easy left-hand tapping of c, c
- Reassigned C-o (never used) to the (other-window) so I can replace my ever fluctuating window keybinding navigation to something more simple using just one hand, plus I can hold down the Ralt and tap through the windows.
- C-g was always a bit of stretch - especially before sticky keys, but now I have a RL combination.
- Simplified Emacs exit with C-x C-c (although why would I ever need this?!) holding RAlt for x,c tap tap.
- A locked sticky key Ctrl double tap now doesn't activate a double whammy of left hand pinky lateral movement.
- Saving can be easier, C-x C-s again is a right hand modifier hold with an x,s tap
- Another common command (which in fact I had to rebind as it was too taxing on my left hand) is now much more comfortable, namely C-x C-e (eval-last-sexp) in the same way as saving mentioned above.
- I am finding myself instinctively using C-j a lot more as naturally my right thumb is now very close to RAlt and my right index finger is always on j
- Reverting buffers is much easier, It is bound to C-x x g (revert-buffer-quick)
- I am finding myself starting to revert back to the vanilla Emacs keybindings rather than my adapted ones mainly I suspect that C-x and C-c is much easier now to access.

*Negatives*

- I will have to adjust to the new position of the keybindings, and some like the undo with C-/ feed a bit strange due to the close proximity between Ralt and /
- Keyboard configuration is required to map Ralt to Control.

I'll evaluate this setup's efficacy over the next few months and I may contemplate not just the possibility of minimizing Ctrl key usage on the left hand but potentially eliminating it altogether! My left hand pinky would then never have to attempt lateral movement again!

* DONE Waybar Toggling Sticky Key Keymaps :sway:sticky_keys:krita:emacs:elisp:bash:art:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240414-emacs--Waybar-Toggling-Sticky-Key-Types
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-04-14 11:55>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/2024-04-14-10-55-03.jpg
:END:

For my previous post I was talking about a software visual indicator to discern which key has been locked in a sticky key situation.  For example there are typically two modes of stickiness, being latched and locked, by default I had set up the locked variant as I thought it would be more useful for Emacs and in fact I have found this to be the case.  For example, double tapping the Control key allows nice easy single key navigation via 'n' 'p' 'f' and 'b', possible page down with 'v' and to delete lines I can use 'k' .e.t.c.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/2024-04-14-10-55-03.jpg]]

I'm sure I will find more bonuses in Emacs with this key locking mechanism and of course I can always tweak my keybindings, for example maybe a page up could be a Ctrl-<key> so I can have even more power navigating with a single <key>.

But how does a locked key setup work in a different program? and especially the software I use for my digital art, namely Krita.  I have a USB numpad peripheral in which I map each key to a Krita shortcut, for example common actions such as colour picking, brush resize, canvas flip, undo / redo e.t.c.  I have found this to actually be a nice cheaper option than one of the more specialised digital art controllers and more flexible as I will always be able to use it on linux with keymapping software like kmonad or kanata.

It didn't take long to find out that I was running into difficulties with Krita and the locked sticky setup.  For example colour picking is quite a common activity in digital art and it just so happens that for Krita it is bound by default to the Ctrl key!  In addition Shift resizes the brush too.  I found that quite often I was tapping the Ctrl and or Shift consecutively which was locking the modifier key which would have some unwanted side effects and would start to get frustrating as I fumble around to unlock the relevant modifier thus disrupting my flow.  I quickly came to the conclusion that a locked sticky was not viable for my use within Krita.

So how could I craft a solution to this problem?

In my previous post, I might have unintentionally already laid the groundwork as I have created both a latched and a locked sticky key variant in the xkb file format. Perhaps I could develop a toggling mechanism between the locked and latched states, switching to latched state when I use Krita.

Just like before, I think Waybar would be ideal to perform the toggle with a click (which could also be a stylus click from a pen) and to then display the current status.

Initially I created the following bash script to perform the toggling of the keymaps :

#+begin_src bash
#!/bin/bash

# Define the paths to your keymap files
KEYMAP_SWAY=~/.config/keymap_sway.xkb
KEYMAP_LOCKED=~/.config/keymap_with_locked_modifiers.xkb
KEYMAP_STICKY=~/.config/keymap_with_sticky_modifiers.xkb
CURRENT_KEYMAP_PATH=~/.config/keymap_current

# Check if the current keymap is set, if not use the sway keymap
if [[ ! -f "$CURRENT_KEYMAP_PATH" ]]; then
    echo "$KEYMAP_SWAY" > "$CURRENT_KEYMAP_PATH"
fi

CURRENT_KEYMAP=$(cat "$CURRENT_KEYMAP_PATH")

# Swap the keymaps
if [[ "$CURRENT_KEYMAP" = "$KEYMAP_LOCKED" ]]; then
    cp -f "$KEYMAP_STICKY" "$KEYMAP_SWAY"
    echo "$KEYMAP_STICKY" > "$CURRENT_KEYMAP_PATH"
else
    cp -f "$KEYMAP_LOCKED" "$KEYMAP_SWAY"
    echo "$KEYMAP_LOCKED" > "$CURRENT_KEYMAP_PATH"
fi

# Reload Sway configuration
swaymsg reload
#+end_src

Note that at first I tried to use the xkbcomp command but by all accounts only works on X11 so with wayland and in particular Sway I had to find a workaround to reload a toggled keymap - which is where swaymsg reload comes in.  The solution is a little hacky but will work and involves swapping around files on disk and then forcing a reload of the sway configuration file.

As always with toggling, the key is usually working out the current toggle state in order to know what to toggle to.  I decided to use the old fashioned method of a file on disk containing the path to the current keymap!

In the sway configuration file I can now attach a keybinding to the new toggle script :

#+begin_src
bindsym $mod+y exec keymap-toggle.sh
#+end_src

'y' for sticky seems appropriate methinks.

Now for updating waybar to reflect the status.  In this case as in the modifier LEDs of my last post I will have to create some custom modules and link it to a content producing bash script.

A keymap_monitor.sh script is as follows:

#+begin_src bash
#!/bin/bash

CURRENT_KEYMAP_PATH=~/.config/keymap_current

CURRENT_KEYMAP=$(cat "$CURRENT_KEYMAP_PATH" | grep "sticky")

if [[ $CURRENT_KEYMAP ]]; then
    echo "{\"text\": \"STICKY\", \"class\": \"active\"}"
else
    echo "{\"text\": \"LOCKED\", \"class\": \"inactive\"}"
fi
#+end_src

and the waybar module :

#+begin_src
    "custom/togglesticky": {
        "exec": "keymap-monitor.sh",
        "interval": 1,
        "return-type": "json",
        "on-click": "keymap-toggle.sh",
    }
#+end_src

Note the return-type type is json and the echo statements in the keymap_monitor.sh script have formatted the return data in the json format meaning the waybar module can process the string effectively.  Note also a css class is set up which will link to the associated waybar css style sheet and potentially offer a nice flexible look for each mode if desired.

"on-click": "keymap-toggle.sh" will allow the toggle to be actioned and the monitor script will be called every second as per the interval setting to poll the current toggle state.

Well that should be about it!, when I now open up Krita I can just tap on the LOCKED indicator on waybar which will then display STICKY (I decided to go with STICKY rather than LATCHED)  This now indicates that I have changed the keymap, at which point double tapping any modifier keys as part of my arting shenanigans will now not lock the associated modifier and cause annoyance down the line.

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240414101304-emacs--Waybar-Toggling-Sticky-Key-Types/2024-04-14-10-55-19.jpg]]

I might even eventually find some icons or my preferred method emojis to make things look more graphically pleasing, but with all these things I always initially look to get most of the way there and in a working state before I start polishing it.

* DONE Waybar Sticky Key LED indicators on a Laptop :wayland:waybar:sway:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240323-emacs--Waybar-Sway-Locked-Sticky-Indicators
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-03-30 16:43>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/2024-03-30-10-27-49-banner.jpg
:END:

From my previous post regarding setting up sticky keys mainly for *Control*, *Alt* and *Shift* in Emacs to remove the dependence on key chording I just wanted to scratch another itch, and that was to provide a modifier LED indicator type experience on a laptop that you would commonly get on a full size keyboard.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/2024-03-30-10-27-49-banner.jpg]]

For example most laptops typically have a single LED indicator on the Caps Lock key with a full size keyboard having Num Lock, Caps Lock and Scroll Lock specific LEDs and generally in that order.

How would I accomplish this more granular display on a laptop that only has a single Caps Lock indicator LED?.

My previous solution of activating the Caps Lock LED when any modifier was activated works to an extent.  However, you still don't know which specific modifier is active, so to clear a locked modifier you might still have to go hunting around the modifiers to find out which one has been activated.

This so far is the only negative I have found using Sticky Keys in that occasionally a modifier key becomes accidentally locked (I suppose stuck!) and it takes a while to figure out which one.

In a highly configurable environment like Sway where you pretty much have to build most things for yourself the flexibility offered can allow me to craft a software solution by modifying the bar to visually indicate the current locked modifiers. So when stickies get stuck a quick glance will tell you which modifiers are active and hence which ones to deactivate.

For now I will just focus on *waybar* which is a customizable bar for Wayland compositors although setting up something like Polybar for X11 would be very similar.

I think the way to achieve this is to figure out how to access the current state of LED indicators which signify which sticky modifiers are set.  Currently any modifier on my laptop activates the Caps Lock LED indicator and although specifically a hardware LED, each modifier can be stored separately, and through xkb (X Keyboard Extension) we can store each LED state in the following locations if set up correctly:

#+begin_src bash
/sys/class/leds/input2::capslock
/sys/class/leds/input2::numlock
/sys/class/leds/input2::scrolllock
#+end_src

My first step is to split the modifiers, setting each internal device accordingly in */sys/class/leds*, so the original xkb file will change from:

#+begin_src
indicator "Caps Lock" {
    !allowExplicit;
    whichModState= locked;
    modifiers= Control+Mod1+Shift;
};
#+end_src

to

#+begin_src
indicator "Caps Lock" {
    !allowExplicit;
    whichModState= locked;
    modifiers= Control;
};
indicator "Num Lock" {
    !allowExplicit;
    whichModState= locked;
    modifiers= Mod1;
};
indicator "Scroll Lock" {
    whichModState= locked;
    modifiers= Shift;
};
#+end_src

which is the way I would activate each LED for a full size keyboard.

Next is to access each LED value so I can pass it through to waybar for display.  I will have to access the LED states more directly, hence in linux pulling values straight from a directory called /sys/class/leds

The following bash script will pass out a JSON formatted string which waybar will be able to process in a custom module:

#+begin_src bash
#!/bin/bash

# Define the paths to the LED brightness indicators
caps_lock_led="/sys/class/leds/input2::capslock/brightness"
num_lock_led="/sys/class/leds/input2::numlock/brightness"
scroll_lock_led="/sys/class/leds/input2::scrolllock/brightness"

# Function to output the JSON format for Waybar
output_json() {
    local text="$1"
    local active="$2"
    if [ "$active" = "1" ]; then
        echo "{\"text\": \"$text\", \"class\": \"active\"}"
    else
        echo "{\"text\": \"$text\", \"class\": \"inactive\"}"
    fi
}

# Check the command-line argument and output the respective LED status
case "$1" in
    --caps)
        caps_state=$(cat "$caps_lock_led")
        output_json "Ctl" "$caps_state"
        ;;
    --num)
        num_state=$(cat "$num_lock_led")
        output_json "Alt" "$num_state"
        ;;
    --scroll)
        scroll_state=$(cat "$scroll_lock_led")
        output_json "Sft" "$scroll_state"
        ;;
    ,*)
        echo "Usage: $0 [--caps | --num | --scroll]"
        exit 1
        ;;
esac
#+end_src

Each LED is associated with its own device, and conveniently, the brightness file is simply a text file containing either a 0 or 1 to indicate whether the LED is active or inactive. To facilitate integration with custom modules in Waybar, and to link them into its CSS I will need to output each module as JSON, assigning each key modifier a class set to either 'active' or 'inactive'.

I will have to write a some custom waybar modules so in the associated modules.json :

#+begin_src
    "custom/caps_lock": {
        "exec": "led-monitor.sh --caps",
        "interval": 1,
        "return-type": "json"
    },
    "custom/num_lock": {
        "exec": "led-monitor.sh --num",
        "interval": 1,
        "return-type": "json"
    },
    "custom/scroll_lock": {
        "exec": "led-monitor.sh --scroll",
        "interval": 1,
        "return-type": "json"
    }
#+end_src

Each button has to be a separate module with each having its own name and LED state which enables the CSS to access each LED individually.

I have kept the styling simple for now but of course the style can be anything you like, so here is an associated CSS :

#+begin_src css

/* General LED styling */
#custom-caps_lock,
#custom-num_lock,
#custom-scroll_lock {
    padding: 0em 0.2em;
}

/* Active LED styling */
#custom-caps_lock.active,
#custom-num_lock.active,
#custom-scroll_lock.active {
    background-color: @recording-color;
}
#+end_src

Here I have put a general padding on the right and left and then defined a simple highlight background colour for when the JSON script above returns active.

These modules can be positioned anywhere along waybar, I typically like to have mine on the right as thus :

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240323111726-emacs--Waybar-Sway-Locked-Sticky-Indicators/2024-03-30-10-27-10.jpg]]

with modifier activation of Alt and Shift shown as:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240323111726-emacs--Waybar-Sway-Locked-Sticky-Indicators/2024-03-30-10-27-49.jpg]]

So in the case above if my keys are doing weird things I can quickly glance at waybar and see that Alt and Shift are currently Sticky activated thus I can deactivate by selecting each to remove the visual indicators and carry on my merry little way!

* DONE Eliminating Key Chords in Emacs under Linux with Sticky Keys :wayland:sway:sticky_keys:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240309130457-emacs--kmonad-sway-kbd-map-locking
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-03-22 21:39>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240309130457-emacs--kmonad-sway-kbd-map-locking.jpg
:END:

I spend many hours living in emacs and a large proportion of this time is using a laptop.  Recently I have been thinking about my hands and how to protect them from any future pain or RSI.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240309130457-emacs--kmonad-sway-kbd-map-locking.jpg]]

Emacs out of the box can be a little, lets say +tortuous+ awkward.  For example I've always found the default keybindings for switching windows (`C-x o`) and saving buffers (`C-x C-s`) to be particularly uncomfortable, a feeling exacerbated by their frequent use. Also, key presses in Emacs typically involve key chording, this means that not only do you have to contort your hand into awkward positions, but you also have to press keys simultaneously thus reducing the possibility for natural hand movement during key activation.

The concept of C-x, especially for a Control key not mapped to the Caps Lock can really take its toll over a number of years; as of yet I am fortunate not to have yet experienced any hand pain but from what I've read, it's not uncommon for discomfort to start to set in after many years of daily keyboard use, so I really want to take measures now.

In a previous post I had started to discuss this topic :

#+begin_export md
[Sticky Keys on Sway using kmonad]({{< ref
"/emacs/20240308115556-emacs--Sticky-Keys-on-Sway-using-kmonad.md" >}})
#+end_export

I attempted to use the cross platform tool *kmonad* to apply Sticky Key functionality thus obviating the need for multiple key chord activation in emacs.  For the most part a basic latched sticky concept works well and is easy to set up, however when using emacs I think a *locking* sticky modifier would be a much better fit, which is where a modifier will be locked on a double tap and then unlocked with a single tap.

For instance, if I could lock the Control key, navigating a buffer could be done with single key presses using 'n', 'p', 'b', and 'f'. Deleting multiple lines, a task I frequently do, would then require only individual presses of the 'k' key. To mark a selection, I could simply tap the space-bar and then use single navigation keys to expand the selection. A single tap of the Control key would then deactivate the lock.

Unfortunately *kmonad* doesn't yet support this kind of sticky key locking functionality, however my attempts at finding a workaround led me to stumble into the murky arcane world of the x keyboard extension!

An XKB (X Keyboard Extension) file format is essentially a descriptive language that allows you to define the behaviour of the keyboard on linux.  This includes the mapping of physical keys to symbols (characters or functions), modifying the action of keys depending on other keys that are held down (modifiers like Shift, Ctrl, Alt) and was primarily developed for the X11 windowing system.

I run a Wayland compositor called *Sway* as my daily driver and it just so happens that Wayland is compatible with the x keyboard extension standard!

Below are some instructions on how to set up Sway with Sticky keys to help eliminate the need for key chords in emacs.  These instructions have been applied to the Sticky Keys section in the emacs wiki : https://www.emacswiki.org/emacs/StickyModifiers#h5o-8

Note that the following instructions can also work for X11 desktop environments as the x keyboard extension has been the de facto standard for many years on X11 and in fact I have successfully set up Sticky Keys in the same manner for the i3 window manager.

---

*Setting up Sticky Keys through XKB*

Firstly run the bash script below to create two sticky keyboard variant files:

#+begin_src bash
#!/bin/bash
DST=$HOME/.config

# Reset keyboard layout (to your preferred language)
setxkbmap gb

# Apply sticky modifiers to a file
xkbcomp $DISPLAY -xkb - | \
    sed 's|SetMods|LatchMods|g' > \
        $DST/keymap_with_sticky_modifiers.xkb

# Reset keyboard layout (to your preferred language)
setxkbmap gb

# Apply locked modifiers to a file
xkbcomp $DISPLAY -xkb - | \
    sed 's|SetMods|LatchMods|g' | \
    sed 's|,clearLocks);|,clearLocks,latchToLock);|g' > \
        $DST/keymap_with_locked_modifiers.xkb
#+end_src

- keymap_with_sticky_modifiers.xkb - a latched sticky modifier setup in which a modifier is activated by a following key press.

- keymap_with_locked_modifiers.xkb - a locking sticky modifier setup in which a modifier will be locked on a double tap and then unlocked with a single tap.

At this point you can activate Sticky Keys by loading the new xkb keymap in the Sway config as follows:

#+begin_src
input "type:keyboard" {
    xkb_file $HOME/.config/keymap_with_locked_modifiers.xkb
}
#+end_src

Note that for X11 you can use the xkbcomp command as thus:
#+begin_src bash
xkbcomp $HOME/.config/keymap_with_locked_modifiers.xkb $DISPLAY
#+end_src

Optionally modify the xkb file directly after generation to use the “Caps Lock” keyboard indicator LED for indicating a sticky modifier is active, like so :

#+begin_src
indicator "Caps Lock" {
    !allowExplicit;
    whichModState= locked;
    modifiers= Control+Mod1+Shift;
};
#+end_src

This turns on the Caps Lock LED whenever a Control, Alt (Mod1) or Shift key is sticky locked giving a visual hint to any locked keys.  Although useful on a laptop if you are using a full sized keyboard each modifier can be linked to its own indicator LED, for example:

#+begin_src
indicator "Caps Lock" {
    !allowExplicit;
    whichModState= locked;
    modifiers= Control;
};
indicator "Num Lock" {
    !allowExplicit;
    whichModState= locked;
    modifiers= Mod1;
};
indicator "Scroll Lock" {
    whichModState= locked;
    modifiers= Shift;
};
#+end_src

As part of this keyboard redefinition it might also be useful to remap the Caps Lock key to the Control modifier.  One way to achieve this in Sway is to modify the config file as follows:

#+begin_src
input type:keyboard {
   xkb_file $HOME/.config/keymap_with_locked_modifiers.xkb
   xkb_options ctrl:nocaps
}
#+end_src

However, as we are redefining our keyboard layout we can directly modify the xkb configuration file in the following manner:

replace:
#+begin_src
    key <CAPS> {         [       Caps_Lock ] };
#+end_src
with
#+begin_src
    key <CAPS> {         [       Control_L ] };
#+end_src

replace:
#+begin_src
    modifier_map Lock { <CAPS> };
#+end_src
with
#+begin_src
    modifier_map Control { <CAPS> };
#+end_src

For bonus points, and to ensure that the right Alt modifier functions like a regular Alt thereby distributing the keys more evenly between the left and right hands, perform the following changes:

add:
#+begin_src
    modifier_map Mod1 { <RALT> };
#+end_src

set the definition of key <RALT> to:
#+begin_src
    key <RALT> {         [           Alt_L,          Meta_L ] };
#+end_src

---

With this setup, I can now effectively press single keys in succession to trigger functionalities in Emacs that would normally require key chording. Even pressing C-g has become naturally easier; I'm now pressing Ctrl, then not having to stretch my index finger across at the same time as my pinky is now released from the control key.

* DONE My Dotfile :emacs:dotfile:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240314162853-emacs--My-Dotfile
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-03-14 16:28>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240314162853-emacs--My-Dotfile.jpg
:END:

Simply a link to my [[file:static/emacs/emacs--init.html][emacs literate config file]] 😀

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240314162853-emacs--My-Dotfile.jpg]]

* DONE kmonad Sticky Keys on Sway to Help Prevent RSI :sway:sticky_keys:kmonad:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240308115556-emacs--Sticky-Keys-on-Sway-using-kmonad
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-03-08 20:48>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240308115556-emacs--Sticky-Keys-on-Sway-using-kmonad.jpg
:END:

I primarily use Emacs on a laptop, and unfortunately, Emacs isn't inherently designed for ergonomic use. Coupled with the less-than-ideal typing experience of continuous laptop use, I'm considering adopting preemptive measures to protect my hands from potential strain injuries, including the infamous emacs pinky and RSI.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240308115556-emacs--Sticky-Keys-on-Sway-using-kmonad.jpg]]

My awareness of this issue heightened after watching numerous informative coding videos by Xah Lee, from which I've gleaned valuable tips on making simple yet effective adjustments to safeguard my hands.

One recommended strategy was relocating the Ctrl key to the Caps Lock position, a common suggestion that I had already implemented a few years ago. Another was to use a mechanical or ergonomic keyboard, which I have not considered feasible for my needs as I have a strong preference for using a laptop, particularly for its versatility as a digital art tablet with a 2-in-1 design.

Nonetheless, there's another solution within my reach: Sticky Keys. Although I've been predominantly aware of Sticky Keys through the inconvenient pop-up in Windows triggered by prolonged keypresses, Xah Lee's insights shed light on its potential benefits in alleviating the strain caused by emacs' key chord demands. My only concern is that my preferred Linux window manager, Sway, lacks built-in support for Sticky Keys, unlike Gnome and KDE.

Fortunately, there is a tool I am already using right under my nose that I had overlooked and that is *kmonad*.

Just for clarification, Sticky Keys allow the user to perform key combinations by pressing keys in sequence rather than simultaneously hence splitting emacs key chords into individual keypresses.

Here is a little summary of what *kmonad* can do:

#+begin_quote

KMonad offers advanced customization features such as layers, multi-tap, tap-hold, and much more. These features are usually available at the hardware level on the QMK-firmware enabled keyboards. However, KMonad allows you to enjoy such features in virtually any keyboard by low-level system manipulations.
\\
\\
KMonad lets you map any keyboard button to any keymap. Want to swap the useless Caps Lock key with the Escape key? Want to have your modifiers such as Shift and Control on your home row, without breaking your normal typing flow? Want a modifier that is combination of Alt + Ctrl + Super + Shift? You can do all of those and much more!

#+end_quote

I am already using kmonad to map the caps lock key to ctrl but on reading the excellent tutorial file I realised that in the latest version, namely v0.4.2 <2023-10-07>, it included sticky-key functionality!

Here is a little kmonad documentation regarding sticky keys:

#+begin_quote

KMonad also supports so called "sticky keys".  These are keys that will behave as if they were pressed after just tapping them.  This behaviour wears off after the next button is pressed, which makes them ideal for things like a quick control or shift.  For example, tapping a sticky and then pressing `abc' will result in `Abc'.
\\
\\
You can create these keys with the `sticky-key' keyword:
\\
\\
(defalias
slc (sticky-key 500 lctl))
\\
\\
The number after `sticky-key' is the timeout you want, in milliseconds.  If a key is tapped and that time has passed, it won't act like it's pressed down when we receive the next keypress.
\\
\\
It is also possible to combine sticky keys.  For example, to get a sticky shift+control you can do
\\
\\
(defalias
ssc (around
(sticky-key 500 lsft)
(sticky-key 500 lctl)))

#+end_quote

The Sway kmonad configuration below will activate a sticky key for all my linux modifier keys along with mapping the caps lock to the ctrl key:

#+begin_src
(defcfg
  input  (device-file "/dev/input/by-path/platform-i8042-serio-0-event-kbd")
  output (uinput-sink "My KMonad output")

  ;; Comment this if you want unhandled events not to be emitted
  fallthrough true

  ;; Set this to false to disable any command-execution in KMonad
  allow-cmd true
  )

(defsrc caps lctl lsft rsft lalt ralt lmet)

(deflayer mine
  (sticky-key 2000 lctl)
  (sticky-key 2000 lctl)
  (sticky-key 2000 lsft)
  (sticky-key 2000 rsft)
  (sticky-key 2000 lalt)
  scrlck
  (sticky-key 2000 lmet))

#+end_src

For us emacs types the configuration file also looks a bit lispy! 😀

Kmonad is also cross platform so it will run on windows too and for my next post I'm going to look to replace my current Autohotkey setup in windows with kmonad and see if it works as well as it does in linux!

* DONE Unified Interface for Switching Contexts - Switch to Thing :recentf:emacs:elisp:consult:buffer:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240305160708-emacs--Unified-Interface-For-Switching-Contexts
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-03-05 17:56>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240305160708-emacs--Unified-Interface-For-Switching-Contexts.jpg
:END:

Now I have ditched =save-desktop= for =recentf= which gives me a faster startup time but still being able to quickly access my most common files (i.e. those I have most recently opened) I have realised that I would like to have quick access to other Emacs resources after a startup.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240305160708-emacs--Unified-Interface-For-Switching-Contexts.jpg]]

This has led me to creating a unified interface of sorts to switch to different contexts through a single keybinding.  If you think that sounds vague, well you are correct!, I shall try and explain myself.

---

=save-desktop= has served me well for many many years as a quick method to call up my last session including recreating buffers in their last positions and thus repopulating the ibuffer list and re-enabling the default Emacs =switch-to-buffer= mechanism.

Unfortunately as I am now fiddling around with elisp it means that restarting Emacs has become much more commonplace and I don't really want to wait around for =save-desktop= to recreate itself after each reload.  In addition there were the odd peculiarities that I could never seem to resolve.

Out of the box =recentf= has its own basic opening mechanism not tied into anything particularly modern with a list of files populated for selection in a separate buffer, but =consult-recent-file= solves this by giving me a nice completing-read experience.

So now I can recall my most recent files in a nice completing-read way how about preserving a familiar switching experience, I could bind =consult-recent-file= to =C-x b=, hence =switch-to-buffer= for continuity, but then of course I can't switch to buffer!  should I have separate keybinding for =consult-recent-file=?, well maybe, but what else would I like to quickly switch to?

Well of course buffers! I shouldn't get carried away without forgetting the Emacs staple switching mechanism and in fact =switch-to-buffer= is perfectly fine and is completing-read enabled (I could also use =consult-buffer=)

Bookmarks! (can I start a sentence like that?).  This is a very underrated feature that I have become more accustomed to using and of course the USP being that a bookmark can reference a file, info page, directory, or pretty much anything you would want to access in Emacs.  Well that has a separate selection mechanism too via =bookmark-bmenu-list= which displays a list of existing bookmarks in a separate buffer.  Again the brilliant =consult-bookmark= comes to the rescue converting the bookmark mechanism into a completing-read, but how do I access this list?, another keybinding?, well maybe.

I am also one of those people that switches themes very often, like several times a day, well how do I do this?, =load-theme=, =customize-themes=?.  Out of the box theme selecting has a separate selection mechanism too which displays a list of existing themes in a separate buffer.  Again the brilliant =consult-theme= comes to the rescue giving a nice completing-read selection mechanism, but how do I access this list?, another keybinding?, well maybe.

So I have four contexts to switch to and I don't want a single keybinding for each one so can I merge all of these contexts into a single completing-read under a single keybinding, with the completion mechanism of choice performing the heavy lifting to give me a fast unified method of quick switching? (and breathe! 😵‍💫), the answer of course is - /"this is Emacs dummy, of course you can!"/.

I thought this would also be a perfect opportunity to further my understanding of elisp by tackling this problem myself, which is how I came up with =my/switch-to-thing=, which is described below:

---

** my/switch-to-thing

The provided Emacs Lisp function `my/switch-to-thing` offers a unified interface within Emacs to quickly switch contexts. It enables a user to perform one of several actions based on the user's selection from a prompted completion list. The specific actions that can be taken are:

1. **Switching to an Open Buffer**: If the selection matches the name of an open buffer, the function switches the current window to display that buffer.

2. **Opening a Recent File**: If the selection matches an entry in the list of recently opened files, that file is opened in the current window.

3. **Jumping to a Bookmark**: If the selection matches a bookmark's name, Emacs navigates to that bookmark.

4. **Changing the Emacs Theme**: If the selection starts with the prefix "Theme: ", the function interprets the rest of the selection as the name of a theme. It then loads and applies that theme.

Here is a break down of its behavior:

- **Initialization**: It first creates lists of current buffer names (`buffers`), recent files (`recent-files`), bookmark names (`bookmarks`), and available themes formatted with a "Theme: " prefix (`themes`). These lists are then concatenated into `all-options`, forming a comprehensive list of choices for the user.

- **User Input**: It prompts the user with a "`Switch to:`" message using `completing-read`, offering autocomplete functionality based on the `all-options` list. This prompt also integrates with Emacs' `file-name-history` for enhanced usability.

- **Action Selection**: Based on the user's choice (`selection`), the function uses `pcase` to pattern-match and decide the action:
  - If the selection is an open buffer, it switches to that buffer (`switch-to-buffer`).
  - If the selection is a bookmark, it jumps to that bookmark (`bookmark-jump`).
  - If the selection is prefixed with "Theme: ", it extracts the theme name, converts it back to a symbol, and loads that theme (`load-theme`).
  - If none of the above conditions are met, it interprets the selection as a file path/name and attempts to open it (`find-file`).

This function effectively encapsulates multiple navigation and customization actions within Emacs into a single command, streamlining the user's workflow by providing a centralized interface for common tasks.

#+begin_src elisp
(defun my/switch-to-thing ()
  "Switch to a buffer, open a recent file, jump to a bookmark, or change the theme from a unified interface."
  (interactive)
  (let* ((buffers (mapcar #'buffer-name (buffer-list)))
         (recent-files recentf-list)
         (bookmarks (bookmark-all-names))
         (themes (custom-available-themes))
         (all-options (append buffers recent-files bookmarks
                              (mapcar (lambda (theme) (concat "Theme: " (symbol-name theme))) themes)))
         (selection (completing-read "Switch to: "
                                     (lambda (str pred action)
                                       (if (eq action 'metadata)
                                           '(metadata . ((category . file)))
                                         (complete-with-action action all-options str pred)))
                                     nil t nil 'file-name-history)))
    (pcase selection
      ((pred (lambda (sel) (member sel buffers))) (switch-to-buffer selection))
      ((pred (lambda (sel) (member sel bookmarks))) (bookmark-jump selection))
      ((pred (lambda (sel) (string-prefix-p "Theme: " sel)))
       (load-theme (intern (substring selection (length "Theme: "))) t))
      (_ (find-file selection)))))
#+end_src

* DONE selected-window-accent-mode now on MELPA :window:selected_window_accent_mode:melpa:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240208164549-emacs-selected-window-accent-mode-now-on-MELPA
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-02-09 14:58>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/selected-window-accent-mode-00.jpg
:END:

The *selected-window-accent-mode* is now present on *MELPA* and is my first Emacs package!

#+hugo: more

It is designed to visually distinguish the currently selected window by applying a unique accent color to its fringes, mode line, header line, and margins.

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/selected-window-accent-mode-00.jpg]]

See https://github.com/captainflasmr/selected-window-accent-mode for more information and examples.

** Whats New

*Version 0.6.0*

*DONE* =ISSUE #1= Do not apply highlighting when frame only contains 1 window when =selected-window-accent-smart-borders= is set

*DONE* define accent color saturation adjustment

*DONE* define accent color darken adjustment

*DONE* highlight selected tab with same accent color

*DONE* add to MELPA

** Quick Start

To use left and bottom accent based on the themes highlight colour:

#+begin_src elisp
(use-package selected-window-accent-mode
  :config (selected-window-accent-mode 1)
  :custom
  (selected-window-accent-fringe-thickness 10)
  (selected-window-accent-custom-color nil)
  (selected-window-accent-mode-style 'subtle))
#+end_src

OR define your own colour:

#+begin_src elisp
(use-package selected-window-accent-mode
  :config (selected-window-accent-mode 1)
  :custom
  (selected-window-accent-fringe-thickness 10)
  (selected-window-accent-custom-color "#427900")
  (selected-window-accent-mode-style 'subtle))
#+end_src

** Alternative window highlighting packages

There exist a few Emacs packages that perform window highlighting but that don't quite provide the feature set of selected-window-accent.

selected-window-accent focusses more on clearly but non-intrusively highlighting the currently selected/focussed window by highlighting aspects of the window border without having to modify the appearance of non-selected windows, hence more akin to a tiling window manager.

*** dimmer

"This package provides a minor mode that indicates which buffer is currently active by dimming the faces in the other buffers."

This is the closest in functionality to selected-window-accent, the difference being that dimmer dims non selected windows rather than accent the selected window.

dimmer can be used in conjunction and will complement selected-window-accent to further enhance the emphasizing of the selected window.

*** hiwin

"This package provides a minor-mode to change the background colour of the non active window."

It uses overlays to highlight non active windows, so is similar to dimmer but is less subtle in its highlighting mechanism and hasn't been updated in excess of 10 years.

*** color-theme-buffer-local

"This package lets you set a color-theme on a per-buffer basis."

Unlike dimmer and hiwin this package isn't related to the concept of a selected window but more of defining different themes for different windows to distinguish them.

*** solaire-mode

"This package is designed to visually distinguish "real" buffers (i.e. file-visiting code buffers where you do most of your work) from "unreal" buffers (like popups, sidebars, log buffers, terminals, etc) by giving the latter a slightly different -- often darker -- background"

Unlike dimmer and hiwin this package isn't related to the concept of a selected window but more of distinguishing between collections of IDE like elements within Emacs.

** Roadmap / Improvements

*TODO* add darken desaturated and tab highlight examples to README

*TODO* define accent color hue adjustment

*TODO* define compensating margin

*TODO* Incorporate =mode-line-active= and =mode-line-inactive= somehow as this would make more sense especially in the 'default mode.

*TODO* header-line not shown on window split - I have a funny feeling this could be very difficult, if not impossible!

*TODO* restore modeline height when switching between modes

*TODO* adjust the not selected-window margin to avoid little window navigation. disruption, hence translating a fringe pixel width to a number of margin characters, not quite sure how I am going to do this yet.

*TODO* excess selected-window disruption in header-line. (not sure I can do much about this)

*TODO* define which theme face attribute to use as the main accent color - Currently the default is to use the =highlight= face

*WATCH* possible overheads of updating visual elements for each window?

*WATCH* careful with removing header-line on all windows, for example magit commit window and probably some others may need to add some logic depending on mode.

* DONE Winner Undo to Tab Bar History :winner_mode:tab_bar:mastering_emacs:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240114145517-emacs--Winner-Undo-To-Tab-Bar-History
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-02-03 10:56>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240114145517-emacs--Winner-Undo-To-Tab-Bar-History.jpg
:END:

Now I am using the =tab-bar= workflow I noticed that =winner-mode= was not working per tab in that the winner undo would return to the previous state of another tab, pretty annoying! 😕

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240114145517-emacs--Winner-Undo-To-Tab-Bar-History.jpg]]

But there is an easy fix, replace =(winner-mode 1)= with =(tab-bar-history-mode 1)=

and for example I replaced my following keybindings:

#+begin_src elisp
(global-set-key (kbd "M-u") 'winner-undo)
(global-set-key (kbd "M-i") 'winner-redo)
#+end_src

with

#+begin_src elisp
(global-set-key (kbd "M-u") 'tab-bar-history-back)
(global-set-key (kbd "M-i") 'tab-bar-history-forward)
#+end_src

Ironically I had just been reading a related section in *Mastering Emacs* and this configuration was recommended to avoid confusion and general vexation.

I would also recommend increasing the number of tab bar history elements remembered, the default is 10 and I quickly found myself running out.

Therefore I put in:

#+begin_src elisp
(setq tab-bar-history-limit 100)
#+end_src

* DONE Opening Frequently Used Files More Efficiently using consult :emacs:consult:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240127113907-emacs--Disabling-Consult-Preview-Selectively
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-01-27 21:14>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240127113907-emacs--Disabling-Consult-Preview-Selectively.jpg
:END:

Periodically, I find myself in situations where I restart Emacs frequently, such as when tweaking my configuration or simply experimenting. During these phases, to achieve a swift start-up, I often resorted to clearing my *=ibuffer=* as I tended to have more of an automatic *=desktop-save=* type workflow for restoring Emacs sessions.  However this would leave me with the task of manually reconstructing my previous session by reopening files.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240127113907-emacs--Disabling-Consult-Preview-Selectively.jpg]]

There are of course *=dired=* functions, like *=find-name-dired=* to more quickly locate files and although I have a good grasp of where my files are, this process became somewhat repetitive and time-consuming.

I realized that my sessions tend to involve the same set of files, sparking a need for a more streamlined approach.

This lead me to transition to the built-in *=recentf=* and then *=consult-recent-file=* with =(setq recentf-max-saved-items 200)= covering most of the files I would typically want to open.

Emacs starts up now in under 2 seconds and wont have a dependency on the number of buffers I had open on a previous session.  If I want to edit a recent file I can open *=consult-recent-file=* bringing up a =completing-read= list of my recently opened files and because I have =(savehist-mode 1)= my very recently opened files will always appear at the top - quite handy!

The only aspect of *=consult-recent-file=* that I am not too keen on as with most consult functions is the file preview when traversing through the recent file list as it seems to be slowing down the opening process due to a series of perceptible delays.  Is it possible to tweak this behaviour in Emacs? Absolutely! So far, I've incorporated the following consult-related packages:

- consult-recent-file
- consult-theme
- consult-outline
- consult-imenu

and I think the only preview that I require is *=consult-theme=* leading to the following configuration:

#+begin_src elisp
(consult-customize
 consult-theme :preview-key '(:debounce 0.2 any)
 consult-recent-file consult-outline consult-imenu consult-history :preview-key nil)
#+end_src

* DONE Emacs asynchronous copying using dired-async-mode :modeline:emacs_29:emacs:elisp:dired:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240120084016-emacs--Dired-Async-Mode
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-01-20 09:38>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240120084016-emacs--Dired-Async-Mode.jpg
:END:

For a while now I've been using an =rsync= based =dired-copy= replacement for large copy asynchronous operations within emacs.  It is not uncommon for me to want to copy large files in emacs and rather than waiting for the operation to finish I leveraged =async-shell-command= to perform an rsync copy as thus:

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20240120084016-emacs--Dired-Async-Mode.jpg]]

#+begin_src elisp
(define-key dired-mode-map (kbd "C") 'my/rsync)

(defun my/rsync (dest)
  "Rsync copy."
  (interactive
   (list
    (expand-file-name (read-file-name "rsync to:"
                                      (dired-dwim-target-directory)))))
  (let ((files (dired-get-marked-files nil current-prefix-arg))
        (command "rsync -arvz --progress --no-g "))
    (dolist (file files)
      (setq command (concat command (shell-quote-argument file) " ")))
    (setq command (concat command (shell-quote-argument dest)))
    (async-shell-command command "*rsync*")
    (dired-unmark-all-marks)
    (other-window 1)
    (sleep-for 1)
    (dired-revert)
    (revert-buffer nil t nil)))
#+end_src

Generally this has worked pretty well for me and as a plus I could see the progress in a buffer named =*rsync*= (although I would typically dismiss it quickly using =winner-undo= or maybe adding something to =display-buffer-alist=)

After watching the always excellent and informative video from [[https://www.youtube.com/@emacselements][Emacs Elements]] - [[https://www.youtube.com/watch?v=1jCNrpp_STM&t=80s][Best Way to Sort and Play Videos Is with Emacs]] it opened my eyes to a built-in feature of emacs 29, namely =dired-async-mode= (Do dired actions asynchronously) which seems to pretty much do what it says.

To activate, rather than having to map all those dired commands to async versions, the following just needs to be set up :

#+begin_src elisp
(dired-async-mode 1)
#+end_src

Now when a copy via dired is activated it will happen asynchronously! - and also with other dired commands like rename but really it is generally a copy that will take the time.

Out of the box a normal copy in dired using =C= activates the asynchronous task and the modeline displays something like the following in all windows :

#+begin_src
[1 Async job(s) running]
#+end_src

When finished the modeline updates with a copy complete message and then after three seconds disappears.

Three seconds you say? well how do I know that?, well I played around a little with the modeline finish message as of course this can be configured, this was my initial attempt:

#+begin_src elisp
(defun my/dired-async-mode-line-message (text face &rest args)
  "Notify end of async operation in `mode-line'."
  (let* ((my/message "Dired Async has finished!!")
         (mode-line-format (concat
                            " " (propertize
                                 my/message
                                 'face
                                 '(:background "#ff0000" :foreground "#ffffff" :inherit bold)
                                 ))))
    (message my/message)
    (force-mode-line-update)
    (sit-for 8)
    (force-mode-line-update)))

(setq dired-async-message-function 'my/dired-async-mode-line-message)
#+end_src

I just felt I could try something a little more prominent to indicate the end of a copy but in the end I kept the default setup.

The only issue I have observed thus far is that on an initial emacs startup the modeline for all windows displays *[0 Async job(s) running]* and only seems to disappear after the first copy.  It is a little annoying and even with the use of the =diminish= package my modeline can look a little cluttered.  I might need to look at this.

---

Update *<2024-01-20 12:05>*
Actually I do know why the above is happening, when I was messing around with the =my/dired-async-mode-line-message= function above I turned on =(dired-async--modeline-mode 1)= ooops! well now I have commented it out no modeline async message initially appears! - I thought I would just leave all this stuff in here 😀

* TODO Guide-to-Creating-New-Emacs-Package-for-MELPA :package:melpa:magit:emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240113160113-emacs--MELPA-Submitting
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-01-13 16:01>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240113160113-emacs--MELPA-Submitting.jpg
:END:

The instructions below are a quick guide to creating a new Emacs package and preparing it to be successfully submitted to the MELPA repository.
#+hugo: more

---
#+TOC: headlines 1 local
---

** Firstly create the new package locally

- Create a git local repo and link it to github remote repo and develop the new package.

** Test package

Comment / uncomment load-path / vc to check package in emacs locally / remotely, remotely when changes have been committed to git repo which will form a good idea if the package can be successfully downloaded built and integrated into emacs.

#+begin_src elisp
(use-package selected-window-accent-mode
  :load-path "~/repos/selected-window-accent-mode"
  ;; :vc (:fetcher github :repo "captainflasmr/selected-window-accent-mode")
  :custom
  (selected-window-accent-fringe-thickness 10)
  (selected-window-accent-custom-color my/accent-color)
  (selected-window-accent-mode-style 'subtle))
#+end_src

** Check the package just running in vanilla emacs
** Ensure package follows the relevant coding conventions:

MELPA will generally require a package to follow the following conventions:

*** Use quality-checking tools

**** byte-compile / flycheck

When specifying package dependencies in an Emacs Lisp package, including a version number like `((visual-fill-column "2.23"))` indicates that your package requires at least that version of the dependency to work correctly. When your package is installed via Emacs' package manager, it will attempt to install a version of `visual-fill-column` that satisfies this minimum version requirement.

Since `visual-fill-column` is distributed on MELPA, the version number can be a bit misleading, because MELPA uses a date-based versioning system for packages created from each commit. Therefore, the actual version number `visual-fill-column` is assigned when built by MELPA will look something like `20230320.1234`, which represents the date and time of the package build.

To find out which version MELPA associates with a package, you can search for the package on the MELPA website or query MELPA from within Emacs using `M-x package-refresh-contents` followed by `M-x package-list-packages`.

In your package's header, if you're not sure about the exact version to depend upon, you may use `"0"` or omit the version number entirely. For example:

#+begin_src elisp
;; Package-Requires: ((emacs "25.1") (visual-fill-column "0"))
#+end_src

or

#+begin_src elisp
;; Package-Requires: ((emacs "25.1") (visual-fill-column))
#+end_src

If you use `"0"`, the package manager interprets it as no specific version requirement, and it will install the latest version available. If additional features from a specific version of `visual-fill-column` are needed, it might be necessary to inspect release notes or specific commits in the `visual-fill-column` source repository to find out the correct minimum version number to require.

**** checkdoc

Use =checkdoc= to make sure that your package follows the conventions for documentation strings, within reason.

Buffer comments and tags:  Ok
Documentation style:       Ok
Message/Query text style:  Ok
Unwanted Spaces:           Ok

**** =package-lint= to help you identify common errors in your package metadata.
**** font-lock elisp warning

Set the following custom-set-faces :

#+begin_src elisp
'(font-lock-warning-face ((t (:foreground "#ff0000" :inverse-video t))))
#+end_src

so that any slightly frowned upon malformed elisp is clearly highlighted.

**** melpazoid

This is an overall check and will combine probably the above and is not essential to get things added to MELPA but run anyway

However can pick up some extra minor things.  All you need to do is to download the package and evaluate from :

#+begin_src sh
https://github.com/riscy/melpazoid/blob/master/melpazoid/melpazoid.el
#+end_src

Note that you may also need to install pkg-info

** Alternatives

Ensure that alternatives to your emacs package have been investigated.

** Tag package

When everything is committed and has been checked then create a tag

*** vc-mode

First make sure you are on main/master

run =vc-create-tag=, I think there is a better way using [b] [c] and soemthing else but I can't remember!

Enter something like 0.1.0

list tags by dropping into a terminal and running

#+begin_src sh
git tag --list
#+end_src

Make sure you are switched to the tag, although should be anyway, but use [b] [s]

To push you will at the moment definitely need to be in the terminal so run :

#+begin_src sh
git push origin 0.1.0
#+end_src

*** magit

magit -> t -> Create t (tag) -> 0.4.0 -> main

now commit and push tag

magit -> P -> T (a tag) which will formally take a snapshot of the source code at that time and I am assuming will form the basis for the MELPA build mechanism.

Note : github will create a tarball of the tags contents but the new tag will be available to inspect.

** Fork MELPA Repository

Go to the MELPA GitHub repository and fork it to your own user account.

If we are applying feedback after a period or the fork is just out-of-date then on github sync the fork to the MELPA repository.

** Clone Your Fork Locally

Clone the forked MELPA repository to your local machine, navigate to the required top level directory:

*** vc-mode

drop into a terminal and run

#+begin_src sh
git clone git@github.com:captainflasmr/melpa.git
#+end_src

*** magit

#+begin_src sh
M-x magit-clone
[u]rl or name
git@github.com:captainflasmr/melpa.git
#+end_src

** Create a new branch and add MELPA Recipe

Using =magit= create a new branch and checkout to hold your changes:

*** vc-mode

#+begin_src
M-x vc-dir
b c <package-name> RET
#+end_src

*** magit

#+begin_src
M-x magit-status
b c <package-name> RET
#+end_src

*** notes

Add your recipe file to the `recipes` directory in the MELPA repository. The recipe file should be named after your package and should contain the s-expression you created:

First open any recipe item in melpa/recipes enable =Melpa-Recipe= major mode this will activate the functions and variables below.

A nice built-in function is =package-build-create-recipe= which will prompt for the requisite information and then put the recipe into the directory pointed to by =package-build-recipes-dir= which will typically be the melpa/recipes directory.    The advantage of running this routine is that it will automatically create a valid recipe and then compile and install the package in the system as if it had come from a real online MELPA.

By default elisp files don't seem to be listed (=:files=) and would automatically pick up *.el e.t.c according to its documentation, just the *.el will be fine.

To manually build and install you can also run =C-c C-c (M-x package-build-current-recipe)= while in the recipe file buffer which will offer a =package-build-archive-entry= package descriptor to check everything is set up correctly.

You can now even run =list-packages= and check that your package is now present!

---

A recipe for MELPA is a small s-expression that tells MELPA how to fetch and build a package. Here's a simple recipe for `selected-window-accent-mode` based on the information you have provided:

#+begin_src elisp
(selected-window-accent-mode
 :fetcher github
 :repo "captainflasmr/selected-window-accent-mode")
#+end_src

This tells MELPA to:

- Use GitHub as the source (`:fetcher github`)
- Clone the repository `captainflasmr/selected-window-accent-mode`

** Package Sanity check

Now the package is part of the package list, maybe now test using =use-package= and that everything works as expected.

** Sanity

*** vc-mode

Check there is a single unregistered/untracked file, namely our new recipe and in our new branch

*** magit

Run =magit-status= and there will be a single untracked file, namely our new recipe and in our new branch

** Commit and Push Your Changes

Commit your new recipe file and push the branch to your GitHub fork

*** vc-mode

Register the file using [i] and add a comment [v], something like

#+begin_quote
Add recipe for <package-name>
#+end_quote

Now push the changes using [P] to the main git repository.

Running "git push"...
fatal: The current branch ollama-buddy has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin ollama-buddy

To have this happen automatically for branches without a tracking
upstream, see 'push.autoSetupRemote' in 'git help config'.

*** magit

From =magit= stage and commit as normal and put in a comment, something like:

#+begin_quote
Add recipe for <package-name>
#+end_quote

Now push the changes for the branch to the remote git repository

** ERROR:

If you get the errors below:

#+begin_src
Running git push -v origin refs/heads/add-selected-window-accent-mode:refs/heads/add-selected-window-accent-mode
Authentication failed for 'https://github.com/captainflasmr/melpa/' ... [Hit $ to see buffer magit-process: melpa for details]
#+end_src

then you have probably checked out the melpa repository incorrectly with cloning the following url :

=https://github.com/captainflasmr/melpa=

rather than

=git@github.com:captainflasmr/melpa.git=

basically it will be the github SSH command rather than the HTTPS one.

** Create a Pull Request

When you log into your fork of MELPA on github it will prompt you to :

#+begin_quote
<package-name> had recent pushes 2 minutes ago - Compare & pull request
#+end_quote

Presumably because a push request has just been made.

If you log in the following day then go to your melpa fork -> switch to branch -> Contribute -> Open Pull Request

If feedback has been given from a previous pull request access the pull request and update any comments.

On your forked GitHub repository, create a pull request against the original MELPA repository. Make sure you detail what the package does and why it's useful to users.

Select the pull request and fill in the following:

#+begin_src
### Brief summary of what the package does

[Please write a quick summary of the package.]

### Direct link to the package repository

https://github.com/your/awesome_package

### Your association with the package

[Are you the maintainer? A contributor? An enthusiastic user?]

### Checklist
- [x] The package is released under a GPL-Compatible Free Software License
- [x] I've read CONTRIBUTING.org
- [x] I've used the latest version of package-lint to check for packaging issues, and addressed its feedback
- [x] My elisp byte-compiles cleanly
- [x] I've used M-x checkdoc to check the package's documentation strings
- [x] I've built and installed the package using the instructions in CONTRIBUTING.org
#+end_src

If you are not sure what to enter select *contributing guidelines* from the right hand side.

Note : as far as I am aware MELPA will be built off your latest tag using a naming convention of something like v0.2 or 0.2 to pull a "stable" version.

** Address Feedback

There may be feedback from the MELPA maintainers. Be prepared to make necessary adjustments to your recipe or package according to their suggestions and update the pull request comments accordingly and resubmit.  Usually no new branches will need to be created as the melpa pull request branch would have just contained a simple recipe which will not have changed.

** Merge

Once your pull request is approved, the maintainers will merge it into the main MELPA repository. Your package will then become available to users and will be built on a regular basis.

Remember to keep your package repository well-maintained, as MELPA builds packages directly from the source (assuming from the latest tag). Any changes in your GitHub repository will reflect in the MELPA package after the next build.

* TODO Magit-Create-And-Publish-Tag :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240113151730-emacs--Magit-Create-And-Publish-Tag
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-01-13 15:17>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240113151730-emacs--Magit-Create-And-Publish-Tag.jpg
:END:

To create a new tag in your Git repository and link it to GitHub, you can follow these steps directly within Emacs using Magit:

#+hugo: more

1. Open Magit within Emacs:
   You can open Magit with the following Emacs command:

   =M-x magit-status=

   This brings up the Magit status view for your repository.

2. In the Magit status buffer, hit `t` to interact with tags:
   This command opens the tagging popup menu.

3. Press `t` to create a new tag:
   After you hit `t`, Magit will prompt you to enter the name of the new tag.

4. Enter the tag name and hit `RET` (Return/Enter key):

5. Optionally, provide an annotation for the tag '-a':
   If you're creating an annotated tag, you can type your message. You can finish by typing `C-c C-c` to confirm or `C-c C-k` to cancel.

6. Push the tag to GitHub:
   Now that you've created a local tag, you may want to push it to GitHub. From the Magit status buffer, press `P` (uppercase) to push.

7. Choose to push a specific tag `T`, then pick the tag you want to push:
   You'll be prompted to select the remote; typically, this will be `origin` for GitHub.

8. Confirm and complete the push process:
   Follow the prompts to finish pushing the tag to the remote repository.

9. A zip and tarball seem to be created for the repositories contents.

Here's an example of how some of the Magit commands look like when invoked:

#+begin_src
;; Create a new tag
M-x magit-status
t         ;; operate on tags
t         ;; create a new tag

;; Push tags to remote
P         ;; push
t         ;; push a specific tag
#+end_src

Make sure you're connected to the internet, and your Emacs has the necessary permissions to interact with GitHub. Also, ensure that your local Git configuration is set up with the correct GitHub credentials for push operations to work smoothly.

* DONE My first emacs package - =*selected-window-accent-mode*= :window:selected_window_accent_mode:emacs:elisp:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240106143432-emacs--Selected-Window-Accent-Mode
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-01-06 21:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/selected-window-accent-mode-00.jpg
:END:

From my previous two posts regarding defining a Selected Window Accent some interesting posts from [[https://irreal.org/blog][irreal]] arose, especially:

#+hugo: more

[[https://irreal.org/blog/?p=11867#comment-6354017310][Marking The Active Window]]

Where it looks like the simple =mode-line-active= and =mode-line-inactive= was a good way to indicate the current focussed window, and I do agree.

However to practice my elisp and to create my first emacs package I thought I would bring together my preference which is to have a tiling window manager type of focus involving typically a border around the current window while leveraging the usual customization options that come with emacs.

I have put it on [[https://github.com/captainflasmr/selected-window-accent-mode][github/captainflasmr]] for now and below is the *README* for a package called *=selected-window-accent-mode=*

It's a bit rough around the edges (pardon the pun!) but I think it might be a good starting point for further improvements.

---

** selected-window-accent-mode
*** Summary

The Selected Window Accent Mode is an Emacs package designed to visually distinguish the currently selected window by applying a unique accent color to its fringes, mode line, header line, and margins.

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/selected-window-accent-mode-00.jpg]]

---

*** Quick Start (emacs 29)

Add the following to the emacs init for a tiling window manager feel (see image above):

#+begin_src elisp
(use-package selected-window-accent-mode
  :vc (:fetcher github :repo "captainflasmr/selected-window-accent-mode")
  :custom
  (selected-window-accent-fringe-thickness 10)
  (selected-window-accent-custom-color "#916941")
  (selected-window-accent-mode-style 'tiling))

(selected-window-accent-mode 1)
#+end_src

---

*** Installation
**** use-package (emacs 29)

Put the following into your emacs init file:

#+begin_src elisp
(use-package selected-window-accent-mode
  :vc (:fetcher github :repo "captainflasmr/selected-window-accent-mode"))
#+end_src

**** use-package (MELPA)

- TODO (see roadmap below)

**** from source

Download the `.el` file and place it in your Emacs `load-path`.

Then either manually load it or add it to your configuration to be loaded at startup.

#+begin_src elisp
(require 'selected-window-accent-mode)
#+end_src

---

*** Usage

Interactively Toggle the mode on and off =M-x selected-window-accent-mode=

Interactively change the current style =M-x switch-selected-window-accent-style= which will present a =completing-read= selection in the minibuffer

The styles that are currently supported :

- default
- tiling
- subtle

see *roadmap* below for a description.

Typically I have bound these two interactive functions to a new keymap where I keep all my emacs visual change functions.

#+begin_src elisp
(defvar my-win-keymap (make-sparse-keymap))
(global-set-key (kbd "M-o") my-win-keymap)
(define-key my-win-keymap (kbd "a") 'selected-window-accent-mode)
(define-key my-win-keymap (kbd "y") 'switch-selected-window-accent-style)
#+end_src

---

*** Examples
**** Example 1 - Default / custom color

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/selected-window-accent-mode-01.jpg]]

To enable the accent mode automatically upon starting Emacs, add the following line to your `.emacs` or `init.el` file:

#+begin_src elisp
(use-package selected-window-accent-mode
  :vc (:fetcher github :repo "captainflasmr/selected-window-accent-mode")
  :custom
  (selected-window-accent-custom-color "goldenrod")
  (selected-window-accent-mode-style 'default))

(selected-window-accent-mode 1)
#+end_src

This will accent the modeline only for the selected window with the =goldenrod= color.

---

**** Example 2 - Tiling / custom color / custom fringe thickness

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/selected-window-accent-mode-02.jpg]]

#+begin_src elisp
(setq selected-window-accent-fringe-thickness 6)
(setq selected-window-accent-custom-color "#4179b2")
(setq selected-window-accent-mode-style 'tiling)

(selected-window-accent-mode 1)
#+end_src

This will accent the full outline of the window with the color #4175b2 more akin to a tiling window manager.

---

**** Example 3 - Tiling / theme highlight color

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/selected-window-accent-mode-03.jpg]]

#+begin_src elisp
(setq selected-window-accent-custom-color nil)
(setq selected-window-accent-mode-style 'tiling)

(selected-window-accent-mode 1)
#+end_src

This will accent the full outline of the window with the =highlight= color taken from the current theme.

---

**** Example 4 - Subtle / custom fringe thickness (thick)

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/selected-window-accent-mode-04.jpg]]

#+begin_src elisp
(setq selected-window-accent-fringe-thickness 40)
(setq selected-window-accent-custom-color nil)
(setq selected-window-accent-mode-style 'subtle)

(selected-window-accent-mode 1)
#+end_src

This will accent the modeline and just the left fringe and in this case be quite a pronounced thick accent.

---

*** Customization

Can be done through the customization interface:

*Selected Window Accent Group group:*

Customization group for the selected-window-accent package.

*Selected Window Accent Custom Color*

Custom accent color for the selected window. Set this variable to change the accent color.

- =None= - color will be using the current =highlight= face
- =Custom Color= - input color name or Hex

*Selected Window Accent Fringe Thickness:* Integer:

The thickness of the fringes in pixels.

*Selected Window Accent Mode*:  =Boolean=: Toggle

Non-nil if Selected-Window-Accent mode is enabled

*Selected Window Accent Mode Style*

Current style for accenting the selected window.

- =default= - just modeline accent
- =tiling= - window border accent
- =subtle= - left and modeline accent

---

*** Minor Mode

The =selected-window-accent-mode= is a global minor mode that you can toggle to enable or disable the accenting of the selected window.

When enabled, it distinguishes the selected window with a special accent color.

---

*** Hooks

Two hooks are used to automatically update the window accents when the window configuration or state changes:

- window-configuration-change-hook
- window-state-change-hook

These are added when the =selected-window-accent-mode= is enabled and removed when disabled.

---

*** BUGS

The current version is pretty rough and probably definitely pre-alpha.

Fix these to get to a tagged Version 0.1.

In order of priority

- *TODO* header-line not shown on window split.
- *TODO* adjust the not selected-window margin to avoid little window navigation. disruption, hence translating a fringe pixel width to a number of margin characters, not quite sure how I am going to do this yet.
- *TODO* Incorporate =mode-line-active= and =mode-line-inactive= somehow as this would make more sense especially in the 'default mode.
- *TODO* excess selected-window disruption in header-line.
- *WATCHING* careful with removing header-line on all windows, for example magit commit window and probably some others may need to add some logic depending on mode.

---

*** ROADMAP
**** 1. add to MELPA
**** 2. define more custom variables:

- accent color saturation adjustment
- accent color darken adjustment
- accent color hue adjustment

**** 3. define which theme face attribute to use as the main accent color

Currently the default is to use the =highlight= face

**** 4. *DOING* implement accent styles

- *DONE* =default= - /bottom/ - full height modeline
- *DOING* =tiling= - /top/right/bottom/left/ - typically a squished modeline and header line to a general accent thickness to provide a typical tiling window manager focussed outline experience
- *DOING* =subtle= - /left/bottom/
- *TODO* =full= - /top/right/bottom/left/ - full height modeline (currently implemented as =tiling= but will be moved when tiling is more "tiling")

* TODO Org-To-Epub :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20240102213958-emacs--Org-To-Epub
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-01-02 21:39>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20240102213958-emacs--Org-To-Epub.jpg
:END:

Now I am using e-ink devices a little more I thought it might be interesting to see if I could export my org files to the =epub= format and as my web sites are single org files generated through =ox-hugo= a clear pathway exists by the org export dispatch mechanism.

#+hugo: more

Firstly install:

#+begin_src
(use-package ox-epub)
#+end_src

I trialled out a =pandoc= workflow but the output was not as consistent as =ox-epub=

This included:

#+begin_src bash
pandoc -o emacs--all-latex.epub emacs--all.tex
pandoc -o emacs--all.epub emacs--all.org
#+end_src

and then export by running:

=(org-export-dispatch)=

It is bound to C-c C-e.

[E] Export to Epub
[e] As Epub file

At the moment I am not too fussy initially some of the images that had:
=#+attr_html: :width 100%=

seemed not to format the images very well, they were generally large and offset and looked messy.

To resolve this I ran =flush-lines= =attr_html: :width 100=

saved the file and then exported, this took care of most of the images.  Of course the width 100% is more for an html export which =org-export-dispatch= is using at the back end but as =#+attr_html: :class emacs-img= seems to work, probably because it doesn't know how to process this as no *css* is applied and is more for html / hugo export.

One fix would be to class css define :width 100% and on this export the image width would be ignored.

* DONE Improvements to Selected Window Accent :window:selected_window_accent_mode:emacs:elisp:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20231230172829-emacs--Selected-Window-Accent-Improvements
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2024-01-01 21:12>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20231221210441-emacs--Selected-Window-Accent.jpg
:END:

Given my previous post regarding accenting the current window:

#+hugo: more

#+begin_export md
[Selected Window Accent]({{< ref
"/emacs/20231221210441-emacs--Selected-Window-Accent.md" >}})
#+end_export

#+begin_quote
"This routine provides a coloured left fringe accent on the selected window to emphasize the current working window."
#+end_quote

I had a little issue with =visual-fill-column-mode= in that :

#+begin_quote
Note that I also had to set the margins to make the window traversal less visually disturbing and it seems to affect =visual-fill-column-mode= in the fact that it doesn't work, but maybe I can just try and not use it or eventually figure it out, but for now this is a starting point and I'm sure I will refine it over time.
#+end_quote

With some trial and error the issue was that my new accent routine applied margins that overrode =visual-fill-column-mode=, causing display issues on window navigation.

So to fix I just re-activated =visual-fill-column-mode= if it was active.

#+begin_src elisp
(defun selected-window-accent ()
  (interactive)
  (set-face-background 'fringe "#77002e")
  (walk-windows
   (lambda (window)
     (if (eq window (selected-window))
         (progn
           (set-window-margins window 1 0)
           (with-selected-window window
             (if (eq visual-fill-column-mode t)
                 (visual-fill-column-mode t)))
           (set-window-fringes window 10 0 t nil))
       (progn
         (set-window-margins window 2 0)
         (with-selected-window window
           (if (eq visual-fill-column-mode t)
               (visual-fill-column-mode t)))
         (set-window-fringes window 0 0 t nil))
       )
     )
   nil t))

(add-hook 'window-configuration-change-hook 'selected-window-accent)
(add-hook 'window-state-change-hook 'selected-window-accent)
#+end_src

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20231221210441-emacs--Selected-Window-Accent-2.jpg]]

* TODO Weight-Extrapolate-Loss :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20231230132734-emacs--Weight-Extrapolate-Loss
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-12-30 13:27>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20231230132734-emacs--Weight-Extrapolate-Loss.jpg
:END:

#+hugo: more

#+begin_src elisp
(defun subtract-weight (weight-str avg-loss)
  "Subtract AVG-LOSS pounds from WEIGHT-STR given in 'stones:pounds' format."
  (let* ((stones-pounds (split-string weight-str ":"))
         (stones (string-to-number (car stones-pounds)))
         (pounds (string-to-number (cadr stones-pounds)))
         (total-pounds (+ pounds (* stones 14)))      ;; Convert stones to pounds
         (new-total-pounds (- total-pounds avg-loss)) ;; Subtract weight loss
         (new-stones (truncate (/ new-total-pounds 14))) ;; Calculate new stones
         (new-pounds (mod new-total-pounds 14)))      ;; Calculate remaining pounds
    (format "%d:%d" new-stones new-pounds)))         ;; Format new weight

(defun extrapolate-weight-loss (num-weeks)
  "Extrapolate weight loss for NUM-WEEKS using the last 'av/pd' value in the org-table."
  (interactive "p")
  (save-excursion
    (let ((last-avg-loss 2.9)
          (last-date "")
          (week 0)
          (next-date ""))
      (print num-weeks)
      (when (org-table-p)
        (goto-char (org-table-end))
        ;; Find the last date and week number
        (search-backward-regexp "|\\s-?\\([0-9]+\\)\\s-?|\\s-?<\\([0-9-]+\\)" nil t)
        (setq week (string-to-number (match-string 1)))
        (setq last-date (match-string 2))
        (setq last-weight "16:10")

        (goto-char (org-table-end))

        ;; Loop for num-weeks to generate new lines
        (dotimes (i num-weeks)
          (setq next-date
                (format-time-string "<%Y-%m-%d %a>"
                                    (time-add (org-time-string-to-time last-date)
                                              (days-to-time (+ (* i 7) 7))))) ;; add 7 days per week
          (setq week (+ week 1))
          (insert (format "| %d | %s | %s | | | | | | |\n"
                          week next-date (subtract-weight last-weight (* (+ i 1) last-avg-loss)))))
        )
      )
    )
  (org-table-align))
#+end_src

* TODO Financial-Subscriptions-Elisp :emacs:2024:
:PROPERTIES:
:EXPORT_FILE_NAME: 20231230132334-emacs--Financial-Subscriptions-Elisp
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-12-30 13:23>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20231230132334-emacs--Financial-Subscriptions-Elisp.jpg
:END:

Description of how I keep track of my subscriptions while using elisp to sum them up, look at *misc-subs.org*

#+hugo: more

#+begin_src elisp
(let ((sum 0))
  (save-excursion
    (goto-char (point-min))
    (while (and (re-search-forward "\\([0-9]+\\.[0-9]+\\)" nil t)
                (not (save-excursion (beginning-of-line) (looking-at-p ": Sum:" ))))
      (setq sum (+ sum (string-to-number (match-string 1))))))
  (message "Sum: %.2f" sum))
#+end_src

* DONE Selected Window Accent :window:selected_window_accent_mode:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20231221210441-emacs--Selected-Window-Accent
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-12-22 20:55>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20231221210441-emacs--Selected-Window-Accent.jpg
:END:

Borrowing from the concept of a tiling window manager I thought that emacs could better indicate the currently selected window by a form of highlight/emphasis like the following:

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20231221210441-emacs--Selected-Window-Accent-2.jpg]]

#+begin_quote
"This routine provides a coloured left fringe accent on the selected window to emphasize the current working window."
#+end_quote

Since I have been using more of an emacs tab-bar based work-flow I found myself spending a second or two looking for my current window when switching tabs.   I would therefore like to more clearly visually identify the current working window (i.e, which window has my cursor in it) by the aid of some kind of accent or emphasis as is often the case in a tiling window manager.   A blinking cursor could help with this, but I tend to prefer a non blinking block and I find =hl-line-mode= too distracting.

I thought I would just cobble together a proof of concept, nothing fancy, programatically inefficient, but hopefully an effective solution that works well enough while adhering to the KISS principle.

---

There are packages out there, for example =pulsar= and =beacon= for pulsing or emphasizing the cursor area when window navigating or =auto-dim-other-buffers= which face dims aspects of the entire window set for emphasis and actually I like its description:

#+begin_quote
The ‘auto-dim-other-buffers-mode’ is a global minor mode which makes windows
without focus less prominent.  With many windows in a frame, the idea is that
this mode helps recognise which is the selected window by providing
a non-intrusive but still noticeable visual indicator.
#+end_quote

which is pretty much what I am looking to achieve but by using an accent rather than dimming.

So the solution?, overlays didn't seem to fit and was more character point font based where I was initially looking to render some form of coloured graphical border overlay which is typically apparent in a standard tiling manager.

After a little investigation I decided on a simple (quick and dirty) solution and that is to utilise the left hand fringe.

I generally don't ever have fringes in my emacs session and in fact set =(set-fringe-mode '(0 . 0))=.

The function =set-fringe-margins= allows a left and right pixel width value to be set for an individual window which is a good starting point.  After a little investigation and trial and error I came up with the following which seemed to work well for me:

#+begin_src elisp
(defun my/selected-window-accent ()
  (interactive)
  (set-face-background 'fringe "#77002e")
  (walk-windows
   (lambda (window)
     (if (eq window (selected-window))
         (progn
           (set-window-margins window 1 0)
           (set-window-fringes window 16 0 t nil))
       (progn
         (set-window-margins window 3 0)
         (set-window-fringes window 0 0 t nil))
       )
     )
   nil t))

(add-hook 'window-state-change-hook 'my/selected-window-accent)
#+end_src

On a window change notification (for example, standard window navigation) all windows are traversed with the current window explicitly displaying the left fringe only to a defined colour.  All the other non selected windows have their fringes removed or in this case the pixel sizes set to zero.

What we end up with here is a window accent on the left hand side of the selected window and when in combination with potentially a sensible mode-line configuration (maybe in the same accent colour) I think will serve as a decent visual window indicator.  The width and colour can be simply modified to taste within the function itself, this is a very simple solution.

Note that I also had to set the margins to make the window traversal less visually disturbing and it seems to affect =visual-fill-column-mode= in the fact that it doesn't work, but maybe I can just try and not use it or eventually figure it out, but for now this is a starting point and I'm sure I will refine it over time.

* DONE Redefining mark-paragraph and mark-word :emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20231209092556-emacs--Redefining-Mark-Paragraph-and-Mark-Word
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-12-09 11:50>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/2023-12-09-10-10-57_t.jpg
:END:

I can't say that I'm completely happy with the way emacs marks some elements, namely :

#+hugo: more

---
#+TOC: headlines 1 local
---

** mark-paragraph

The default mark-paragraph visually selects a paragraph as follows:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20231209092556-emacs--Redefining-Mark-Paragraph-and-Mark-Word/2023-12-09-09-45-35.jpg]]

but I think I would rather have the cursor show at the bottom of the selected paragraph, it just feels more natural to me, so as thus:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20231209092556-emacs--Redefining-Mark-Paragraph-and-Mark-Word/2023-12-09-09-46-26.jpg]]

To achieve this I wrote the following with a rebind to the default =mark-paragraph= keybinding or in =orgs= case the =mark-element=

#+begin_src elisp

(defun my/mark-paragraph ()
  "redefinition of mark-paragraph"
  (interactive)
  (forward-char)
  (backward-paragraph)
  (push-mark)
  (forward-paragraph)
  (setq mark-active t))

(global-set-key (kbd "M-H") 'my/mark-paragraph)

#+end_src

I had to =forward-char= initially to step on to the paragraph if my cursor was just before the paragraph as this felt natural to me so that the =backward-paragraph= won't jump to the previous paragraph.

So just a simple function with a few tweaks here and there to make the paragraph marking feel a little more natural, probably subconsciously taking cues from my time working with many different text editors and as always with emacs it is pretty awesome that this kind of low level finely grained functionality can be modified to such and extent.

** mark-word

Next up is =mark-word=.  I'm finding myself wanting to naturally just mark the current word my cursor is within and currently I feel I'm having to work quite hard to achieve this by a combination of backward/forward-word and marking.

The default =mark-word= =(M-@)= seems to only mark to the end of a word, as thus:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20231209092556-emacs--Redefining-Mark-Paragraph-and-Mark-Word/2023-12-09-10-10-40.jpg]]

I would want something more like:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20231209092556-emacs--Redefining-Mark-Paragraph-and-Mark-Word/2023-12-09-10-10-57.jpg]]

So I created the following function and rebound to the default =mark-word= :

#+begin_src elisp
(defun my/mark-word ()
  "redefinition of mark-word"
  (interactive)
  (backward-to-word 1)
  (forward-to-word 1)
  (push-mark)
  (forward-word)
  (setq mark-active t))

(global-set-key (kbd "M-@") 'my/mark-word)
#+end_src

This was trickier than I first thought as when I manually mark a word through a combination of key-presses I actually apply a little logic in that if the cursor is on the first character I don't backward-word as this would take me to the previous word!

I might be able to work out if the cursor is on the first character of a word?, but the function starts to become unnecessarily complicated.

To solve this I used =backward-to-word= which moves backward until the end of a word.  This will work irrespective of where my cursor is within the current word and then forwarding back on to the current word so my cursor is on the first character.   At this point I can now mark and =forward-word= to select the word.  Yes I have used word many times here, word, word, word, word, WORD!!!! 😀

Now typing all this out I wonder if there is a simple function to just move the cursor to the start of a word, if there is I couldn't seem to find it, but as always I have learnt a lot along the way!

*[Edited : <2023-12-10>]*

Actually it is possible (of course!) to work out if the cursor is on the first character of a word (see comment section), so the amended function would look like:

#+begin_src elisp
(defun my/mark-word ()
  "redefinition of mark-word"
  (interactive)
  (if (not (looking-at "\\<"))
      (backward-word))
  (push-mark)
  (forward-word)
  (setq mark-active t))
#+end_src

I feel like this is a better solution.

* DONE Describe Character / Face Under Cursor :emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230819202723-emacs--Describe-Character-Under-Cursor
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-12-02 09:13>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230819202723-emacs--Describe-Character-Under-Cursor.jpg
:END:

Every now and then I find myself tweaking the look of emacs and have started to build up a list of my own common faces in =custom-set-faces= to suit my needs, for example here is my current setup:
#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230819202723-emacs--Describe-Character-Under-Cursor.jpg]]

#+begin_src elisp
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(cursor ((t (:background "#ffffff" :inverse-video t))))
 '(ediff-current-diff-A ((t (:extend t :background "#b5daeb" :foreground "#000000"))))
 '(ediff-even-diff-A ((t (:background "#bafbba" :foreground "#000000" :extend t))))
 '(ediff-fine-diff-A ((t (:background "#f4bd92" :foreground "#000000" :extend t))))
 '(ediff-odd-diff-A ((t (:background "#b8fbb8" :foreground "#000000" :extend t))))
 '(org-block ((t (:inherit fixed-pitch))))
 '(org-code ((t (:inherit (shadow fixed-pitch)))))
 '(org-date ((t (:inherit fixed-pitch))))
 '(org-document-info ((t (:foreground "#8f4800"))))
 '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
 '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
 '(org-link ((t (:foreground "#5555ff" :underline t))))
 '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
 '(org-tag ((t (:inherit (shadow fixed-pitch) :weight regular :height 0.7))))
 '(widget-button ((t (:inherit fixed-pitch :weight regular))))
 '(window-divider ((t (:foreground "black"))))
 '(vertical-border ((t (:foreground "#000000")))))
#+end_src

To help me work out the name of a certain face I use:

=(describe-char)=

typically accessed through =C-x == (what-cursor-position) with the prefix argument, then accessing customize menu, saving changes, looking up the face changed in the init file and then copy and paste to my custom-set-faces above.

* DONE Quick Search Through Org Headers using Consult Outline :emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20231014134633-emacs--Quick-Search-Through-Org-Headers-Using-Consult-Outline
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-11-18 15:30>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20231014134633-emacs--Quick-Search-Through-Org-Headers-Using-Consult-Outline.jpg
:END:

I've been on the lookout for an efficient way to swiftly scan through org headings exclusively for a specified input string, akin to the functionality of =isearch=. This would enable me to promptly navigate to a past blog post which is typically stored under an org heading.

#+hugo: more

By default, a standard =isearch= examines the entire file, a behaviour that in this case I don't really want. I specifically need to limit the search to org headings only, allowing me to swiftly navigate to an org heading.

The best method I have found is to use =consult-outline= which I have bound to =C-o=

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20231014134633-emacs--Quick-Search-Through-Org-Headers-Using-Consult-Outline.jpg]]

I had a play around with various org filtering options like =org-goto= and =org-agenda= but they didn't really quite do what I wanted.

As it turns out leveraging the built-in =outline-mode= through =consult-outline= also comes with the additional benefit of being applicable to source code files.

Also in combination with =embark-collect= it means I can create a separate outline buffer which can simply be =isearch='d through to refine my search further.

I seem to be using =embark-collect= more often these days so I bound a key to the mini-buffer map so I won't necessarily need to go through the embark despatching mechanism each time I want to redirect the mini-buffer contents to a proper buffer:

#+begin_src elisp
(define-key minibuffer-local-map (kbd "C-c e") 'embark-collect)
#+end_src

I have also added =consult-imenu= to my arsenal of search weapons which I have bound to =M-o=.  For example I have a very clearly defined commenting format in emacs init and sway configuration files so to jump through a file I can use =imenu= with =consult= instead.

* DONE Window Divider Mode :window:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20231006165956-emacs--Divider-Mode
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-11-05 16:01>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20231006165956-emacs--Divider-Mode.jpg
:END:

I was playing around with the look of emacs and thought it might be nice to have more control over the border between windows (I have now learnt that this is referred to as a window divider!)

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20231006165956-emacs--Divider-Mode.jpg]]

Although I could change the colour using =custom-set-faces= =(vertical-border ((t (:foreground "#444444"))))= I wanted the default thin dividing window line to be larger, but initially I couldn't seem to figure out how do change this.

I tried the vertical-border face =:width= =:height= at varying weights and in fact through the custom settings I toggled on and off pretty much everything, but to no avail.

This eventually led me to the built-in =window-divider-mode= which actually specifically handles the cosmetic divider issues, so I set the following:

#+begin_src elisp
(setq window-divider-default-bottom-width 8)
(setq window-divider-default-right-width 8)
(setq window-divider-default-places t)

(window-divider-mode 1)
#+end_src

I decided that if I was going to have a window divider then I might as well have it "around" every window, hence the default-places set to =t= rather than a very specific position,  =right-only= or =bottom-only=

* DONE Digital Art Using Artist Mode #1 :mode:emacs:artist_mode:art:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20231027211128-emacs--Famous-Film-Using-Artist-Mode
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-10-27 21:31>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20231027211128-emacs--Famous-Film-Using-Artist-Mode.jpg
:VIDEO:    EmacsAscii/2023-10-27-art-videos--EmacsAscii-timeLapse-titanic.mp4
:END:

I have been using *ArtRage*, *Krita* and *Infinite Painter* for many years now but I thought I would try that other well known digital art tool... *emacs*!

#+hugo: more

Using the built-in artist-mode now I really can truly live in emacs full time!

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20231027211128-emacs--Famous-Film-Using-Artist-Mode.jpg]]

Here is my emacs time-lapse! : https://youtu.be/1JZ6ljIRGus 😀

#+begin_export md
{{< youtube 1JZ6ljIRGus >}}
#+end_export

* DONE Better Syntax Highlighting Sway Configuration Files :sway:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20231022195943-emacs--Syntax-Highlighting-Of-SwayWM-Configuration-Files
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-10-22 21:20>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/2023-10-22-20-32-51_t.jpg
:END:

I have been delving into the nuts and bolts of the *Sway window manager* lately and especially its fork *SwayFX* which adds a little eye candy in the style of *Hyprland*.

#+hugo: more

This has led to lots of sway config file editing and hence trying to work out the best way in emacs to work with them.

By default a typical sway/config file has its own configuration format and emacs tries its best to figure out which best mode to use and settles on =conf-space-mode=.  This is a basic starter mode for a config that is space separated and gives me a rudimentary level of highlighting, for example :

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20231022195943-emacs--Syntax-Highlighting-Of-SwayWM-Configuration-Files/2023-10-22-20-14-13.jpg]]

I would like indentation to be a little more intelligent and currently this mode applies an ever increasing indent but I shall figure that out at a later date.

I was generally not unhappy with =conf-space-mode= as it gave me a rudimentary keyword form of highlighting and typically as a sway configuration file doesn't need to be particularly structured I wasn't ever really indenting anyway, but lets see if I can improve the syntax highlighting.

The first port of call is =list-packages= and searching for =sway=:
#+begin_src
  sway - Communication with the Sway window manager
  sway-lang-mode - Major mode for sway
#+end_src

Unfortunately both don't suit my use case and in fact the second is for the sway programming language of which this is not!.

Well how about =treesitter=?, a big hard nope for this as well.

Next up is a little ace up my sleeve and one that continues to prove advantageous when working with the Sway tiling manager.  It is the fact that SwayWM is a drop in replacement for i3wm.  Well if the sway config files are of the same format as i3 config files then surely I can use some kind of i3 emacs mode? and so it proved to be the case!

#+begin_src
  i3wm-config-mode - Better syntax highlighting for i3wm's config file
#+end_src

Explicitly running this mode gives me:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20231022195943-emacs--Syntax-Highlighting-Of-SwayWM-Configuration-Files/2023-10-22-20-32-51.jpg]]

Much nicer! and comes with the following =auto-mode-alist= definition:
#+begin_src elisp
("i3/config\\'" . i3wm-config-mode)
#+end_src

which of course requires a little adjustment to auto associate this new i3 mode with my sway files.  I came up with the following:

#+begin_src elisp
(add-to-list 'auto-mode-alist '("/sway/.*config.*/" . i3wm-config-mode))
(add-to-list 'auto-mode-alist '("/sway/config\\'" . i3wm-config-mode))
#+end_src

It took me a little while to figure out the =regex= as there are a few subtleties, for example it is recommended to always use *\\'* rather than *$* to eliminate the confusion around new lines.

Note that I put an extra directory slash at the regex start to stop the mode being applied to any other potential directories that might end in *sway* which I feel might be a more common future occurrence than a config directory containing *i3*.

* DONE More Improvements to Dired Duplicate Here :emacs:elisp:dired:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20231013153639-emacs--More-Flexible-Duplicate-Thing-Function
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-10-13 16:10>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20231013153639-emacs--More-Flexible-Duplicate-Thing-Function.jpg
:END:

On a previous post I created an elisp function to quickly duplicate a file or directory in =dired=, by default it would copy the =dired= item under the cursor to an =old= suffix or append a number based on the universal argument.

#+hugo: more

#+begin_export md
[Dired Duplicate Here Revisited]({{< ref
"/emacs/20230606213531-emacs--Dired-Duplicate-Here-Revisited.md" >}})
#+end_export

#+begin_src elisp
(defun my/dired-duplicate-file (arg)
  "Duplicate the current file in Dired."
  (interactive "p")
  (let ((filename (dired-get-filename)))
    (setq target (concat (file-name-sans-extension filename)
                         "-old"
                         (if (> arg 1) (number-to-string arg))
                         (file-name-extension filename t)))
    (if (file-directory-p filename)
        (copy-directory filename target)
      (copy-file filename target))
    )
  )
#+end_src

This worked well for a while but now I want something a little more robust and after working within Krita for a while I decided that I would like to implement its incremental save naming convention.

It's pretty simple really, just an incremented integer, zero padded to a width of 3, inserted just before the extension:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20231013153639-emacs--More-Flexible-Duplicate-Thing-Function.jpg]]

So I just need to apply a little counter logic but still have the potential to pass in the universal argument and of course avoid overriding any existing backup as it did before.

#+begin_src elisp
(defun my/dired-duplicate-file (arg)
  "Duplicate a file from dired with an incremented number.
  If ARG is provided, it sets the counter."
  (interactive "p")
  (let* ((file (dired-get-file-for-visit))
         (dir (file-name-directory file))
         (name (file-name-nondirectory file))
         (base-name (file-name-sans-extension name))
         (extension (file-name-extension name t))
         (counter (if arg (prefix-numeric-value arg) 1))
         (new-file))
    (while (and (setq new-file
                      (format "%s%s_%03d%s" dir base-name counter extension))
                (file-exists-p new-file))
      (setq counter (1+ counter)))
    (if (file-directory-p file)
        (copy-directory file new-file)
      (copy-file file new-file))
    (dired-revert)))
#+end_src

I can now create any number of dired file/directory backups quickly from =dired= (well up to 100).

* DONE More Improvements To My Weight Loss Org Table :orgtable:org:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20231006172548-emacs--Improving-Weight-Loss-Org-Table
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-10-06 18:59>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20231006172548-emacs--Improving-Weight-Loss-Org-Table.jpg
:END:

More improvements to my weight loss table, this time I have added the following:

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20231006172548-emacs--Improving-Weight-Loss-Org-Table.jpg]]

1. The first column now auto populates an incremental integer
2. Extra column to display the average loss

   #+begin_src org
,#+PLOT: title:"Weight Loss" ind:1 deps:(4) type:2d with:lines set:"yrange [150:220]"
|   | date             |   stn | pnd | lss | tot | bar            | av-loss |
|---+------------------+-------+-----+-----+-----+----------------+---------|
| 0 | <2023-08-18 Fri> |  15:5 | 215 |     |     | WWWWWWWWWWWWWH |         |
| 1 | <2023-08-25 Fri> |  14:9 | 205 | -10 | -10 | WWWWWWWWWWWV   |    10.0 |
| 2 | <2023-09-01 Fri> |  14:2 | 198 |  -7 | -17 | WWWWWWWWWW;    |     8.5 |
| 3 | <2023-09-08 Fri> | 13:11 | 193 |  -5 | -22 | WWWWWWWWW:     |     7.3 |
| 4 | <2023-09-15 Fri> | 13:10 | 192 |  -1 | -23 | WWWWWWWWW      |     5.8 |
| 5 | <2023-09-22 Fri> |  13:9 | 191 |  -1 | -24 | WWWWWWWWV      |     4.8 |
|   |                  |       |     |     |     |                |         |
,#+TBLFM: $1=@#-2::$4='(convert-weight $3)::@3$5..@>$5=$4-@-1$4::@3$6..@>$6=vsum(@$5..@3$5)::$7='(orgtbl-ascii-draw $4 150 220 15)::@3$8..@>$8=abs(vmean(@3$5..@$5));%0.1f
   #+end_src

   1.
      On my last org weight table post a comment pointed out that there was a better way to populate the first integer column, so rather than a key-press =S-RET (org-table-copy-down)= rows can be auto populated using the =$1=@#-2= equation in the =#+TBLFM= line.

   2.
      I thought it might be interesting to plot he average weight loss to gain a more general perspective and to see the average weekly value settle down over a period of time.  For this I added

      =@3$8..@>$8=abs(vmean(@3$5..@$5));%0.1f=

      which leverages the calc functions of =vmean= to average out the previous loss values and then apply an absolute value using the function =abs=.

      I also found that I needed to find a way to display the table value to 1.d.p which was achieved by =%0.1f=

* DONE Recursively Listing Files in Size Order using find-name-dired :find:emacs:dired:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20231001210123-emacs--Dired-Listing-Files-Largest-First
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-10-01 21:31>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20231001210123-emacs--Dired-Listing-Files-Largest-First.jpg
:END:

For a while now I have been looking for a simple method in emacs for trimming down my largest files, usually this means locating those large image files and compressing them as I like keeping my media compressed or deleting any large files I didn't know were lurking around my system.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20231001210123-emacs--Dired-Listing-Files-Largest-First.jpg]]

The obvious choice for this is =find-name-dired= but for me always had the annoying habit of reordering the final result after finishing the recursive search.  Even if I set the =find-ls-option= correctly (not necessarily an easy task) to sort by size the final dired buffer output would always keep resetting to sort by file name.

It took me a while delving into the nuts and bolts of =find-name-dired= but I finally realised that after processing using the =find-ls-option= a function =find-dired-refine-function= is called which by default is set to =find-dired-sort-by-filename= which:

#+begin_quote
Sorts entries in *Find* buffer by file name lexicographically.
#+end_quote

Why this does this I have no idea (perhaps it is because the output of the find command ends up in a dired buffer which would always generally make sense to sort by name?), but as I will only ever want to use =find-name-dired= to list files in size order and then to prune any or compress them using standard =dired= commands then I can just do the following:

#+begin_src elisp
(setq find-dired-refine-function 'nil)
(setq find-ls-option (cons "-exec ls -lSh {} +" "-lSh"))
#+end_src

Which will honour the intended =find-ls-option= to do exactly what it says on the tin and that is to:

#+begin_src
-l : long list as =dired= will always need this form of listing
-S : Sort by file size
-h : Show size in human readable form, which  doesn't seem to affect the sorting
#+end_src

For me this seems to be a more transparent method and of course I guess other standard =ls= options can now be passed through to =dired=, for example for files in order of time, you would pass =-t=

* DONE Plotting Other Org Tables :orgtable:org:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230923092356-emacs--Adding-Row-Number-Column-In-Org-Table
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-09-26 21:30>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230923092356-emacs--Adding-Row-Number-Column-In-Org-Table-thumb.jpg
:END:

I'm currently in the process of learning how to create graphical plots from org tables using =gnuplot=. I've noticed that it's generally more straightforward to extract x-axis data from an org table column with incrementing numbers, as opposed to relying on =gnuplot= to potentially sort out data from an existing column (which may not be plot-friendly)

#+hugo: more

Generally my existing org tables do not have such an incrementing integer column, so how do I quickly create and populate such a column?, well actually it is super easy, barely an inconvenience!

For example take the following table that represents a little flutter on the horses, how would I go about plotting the /Total/ column and therefore clearly visualise the downward sloping line 😀

#+begin_src
| Date   | Horse          | Stk |   Ret |  Prof |  Total |
|--------+----------------+-----+-------+-------+--------|
|        |                |     |       |     0 |  306.9 |
| 27 May | aggagio        |  15 |  7.68 | -7.32 | 299.58 |
|        | red derek      |  15 |     0 |   -15 | 284.58 |
| 03 Jun | dear my friend |  10 |     0 |   -10 | 274.58 |
|        | the foxes      |  10 |    32 |    22 | 296.58 |
|        | sprewell       |  10 |    16 |     6 | 302.58 |
|        | dancing poet   |  15 | 16.73 |  1.73 | 304.31 |
#+end_src

Firstly simply =M-S-<right>= to insert a table column:

#+begin_src
|   | Date   | Horse          | Stk |   Ret |  Prof |  Total |
|---+--------+----------------+-----+-------+-------+--------|
|   |        |                |     |       |     0 |  306.9 |
|   | 27 May | aggagio        |  15 |  7.68 | -7.32 | 299.58 |
|   |        | red derek      |  15 |     0 |   -15 | 284.58 |
|   | 03 Jun | dear my friend |  10 |     0 |   -10 | 274.58 |
|   |        | the foxes      |  10 |    32 |    22 | 296.58 |
|   |        | sprewell       |  10 |    16 |     6 | 302.58 |
|   |        | dancing poet   |  15 | 16.73 |  1.73 | 304.31 |
#+end_src

Now move the cursor to the starting point and put in an initial integer:

#+begin_src
|   | Date   | Horse          | Stk |   Ret |  Prof |  Total |
|---+--------+----------------+-----+-------+-------+--------|
| 1 |        |                |     |       |     0 |  306.9 |
|   | 27 May | aggagio        |  15 |  7.68 | -7.32 | 299.58 |
|   |        | red derek      |  15 |     0 |   -15 | 284.58 |
|   | 03 Jun | dear my friend |  10 |     0 |   -10 | 274.58 |
|   |        | the foxes      |  10 |    32 |    22 | 296.58 |
|   |        | sprewell       |  10 |    16 |     6 | 302.58 |
|   |        | dancing poet   |  15 | 16.73 |  1.73 | 304.31 |
#+end_src

Now just simply =S-Enter (org-table-copy-down)= which will fill an incremented number downwards as far as you want:

#+begin_src
|   | Date   | Horse          | Stk |   Ret |  Prof |  Total |
|---+--------+----------------+-----+-------+-------+--------|
| 1 |        |                |     |       |     0 |  306.9 |
| 2 | 27 May | aggagio        |  15 |  7.68 | -7.32 | 299.58 |
| 3 |        | red derek      |  15 |     0 |   -15 | 284.58 |
| 4 | 03 Jun | dear my friend |  10 |     0 |   -10 | 274.58 |
| 5 |        | the foxes      |  10 |    32 |    22 | 296.58 |
| 6 |        | sprewell       |  10 |    16 |     6 | 302.58 |
| 7 |        | dancing poet   |  15 | 16.73 |  1.73 | 304.31 |
#+end_src

Now I can use a #+PLOT header to reference the first column for the x axis:

#+begin_src
,#+PLOT: title:"Betting" ind:1 deps:(7) type:2d with:lines set:"yrange [250:350]"
|   | Date   | Horse          | Stk |   Ret |  Prof |  Total |
|---+--------+----------------+-----+-------+-------+--------|
| 1 |        |                |     |       |     0 |  306.9 |
| 2 | 27 May | aggagio        |  15 |  7.68 | -7.32 | 299.58 |
| 3 |        | red derek      |  15 |     0 |   -15 | 284.58 |
| 4 | 03 Jun | dear my friend |  10 |     0 |   -10 | 274.58 |
| 5 |        | the foxes      |  10 |    32 |    22 | 296.58 |
| 6 |        | sprewell       |  10 |    16 |     6 | 302.58 |
| 7 |        | dancing poet   |  15 | 16.73 |  1.73 | 304.31 |
#+end_src

which will produce the following plot:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230923092356-emacs--Adding-Row-Number-Column-In-Org-Table.jpg]]

Not such a downward spiral as I first thought!

* DONE Plotting Org Table Weight Loss Using gnuplot :orgtable:org:gnuplot:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230922125005-emacs--Plotting-Org-Table-Weight-Loss
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-09-22 13:40>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230922125005-emacs--Plotting-Org-Table-Weight-Loss.jpg
:END:

Now I have a weight loss org table defined and therefore an easy way to track the total amount of weight loss each week I had an idea for an improvement with some form of a satisfying graphical representation.

#+hugo: more

I have been aware of =gnuplot= for while now and I think this is an opportunity to give it a try through =org-mode=

The first step is a simple =(use-package gnuplot)=

here is the original table:

#+begin_src org
| date             | weight | pounds | loss | total |
|------------------+--------+--------+------+-------|
| <2023-08-18 Fri> |   15:5 |    215 |      |       |
| <2023-08-25 Fri> |   14:9 |    205 |  -10 |   -10 |
| <2023-09-01 Fri> |   14:2 |    198 |   -7 |   -17 |
| <2023-09-08 Fri> |  13:11 |    193 |   -5 |   -22 |
,#+TBLFM: $3='(convert-weight $2)::@3$4..@>$4=$3-@-1$3::@3$5..@>$5=vsum(@$4..@3$4)
#+end_src

and with a little investigation and trial and error I came up with:

#+begin_src org
,#+PLOT: title:"Weight Loss" ind:1 deps:(4) type:2d with:lines set:"yrange [150:220]"
|   | date             |   stn | pnd | lss | tot | bar            |
|---+------------------+-------+-----+-----+-----+----------------|
| 0 | <2023-08-18 Fri> |  15:5 | 215 |     |     | WWWWWWWWWWWWWH |
| 1 | <2023-08-25 Fri> |  14:9 | 205 | -10 | -10 | WWWWWWWWWWWV   |
| 2 | <2023-09-01 Fri> |  14:2 | 198 |  -7 | -17 | WWWWWWWWWW;    |
| 3 | <2023-09-08 Fri> | 13:11 | 193 |  -5 | -22 | WWWWWWWWW:     |
| 4 | <2023-09-15 Fri> | 13:10 | 192 |  -1 | -23 | WWWWWWWWW      |
| 5 | <2023-09-22 Fri> |  13:9 | 191 |  -1 | -24 | WWWWWWWWV      |
,#+TBLFM: $4='(convert-weight $3)::@3$5..@>$5=$4-@-1$4::@3$6..@>$6=vsum(@$5..@3$5)::$7='(orgtbl-ascii-draw $4 150 220 15)
#+end_src

The first thing to point out is that as I was learning more about org tables I came across the =orgtbl-ascii-draw= function which visually is quite self explanatory as shown in the bar column.  The main arguments are the x axis range (150-220) and the span in characters (15)

Now on to the main plotting change and that is defining a =#+PLOT= header setting out all the parameters I want fed into gnuplot from the org table.

Again most of the defines are self explanatory and the only issue I ran into was trying to get plot lines to be rendered based off the original first date column.  The histograms display did work and correctly listed each week with the corresponding bar value but lines only displayed a single vertical line at a 2023 value.

I am guessing in the case of a line display the data is plotted in a more non discrete manner and the date was parsed as best it could and just plucked out the first part of the date string which was the year.  I decided not to investigate this and instead simply added another column with a simple numbering scheme and set my x axis off of that.  I only want to see a plot over a number of weeks so I don't care about the display of the date.

So now lets generate the gnuplot! which can be accomplished by running =C-c " g (org-plot/gnuplot)=:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230922125005-emacs--Plotting-Org-Table-Weight-Loss.jpg]]

* DONE Opening Files Externally from dired :emacs:elisp:dired:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230529112814-emacs--Opening-Files-Externally-Natively
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-09-16 16:43>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230529112814-emacs--Opening-Files-Externally-Natively.jpg
:END:

I have been using *=C-RET=* or *=W=* in =dired= for a while now to open a file externally via =browse-url-of-dired-file=.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230529112814-emacs--Opening-Files-Externally-Natively.jpg]]

I was never quite sure how that worked but it just worked, however now it doesn't work so I need to do something about it.

I suspect that the reason it doesn't work now is that I have been hopping around different window managers / compositors.  My tried and tested workhorse environment is generally kde plasma on arch where the =browse-url-of-dired-file= was working just fine, but now I have switched to *sway / wayland* or *i3 / x11* this functionality seems to be broken.

I have an idea it's probably related to the window manager and the way each one handles default applications through the XDG portal.  I think I need to find a more agnostic opening method.

My first thought was the *=openwith=* package but this had the side effect of opening every single file externally (especially when coming back from a =desktop-save=) which is not something I find desirable.  I prefer the default dired mechanism for opening a file in emacs itself and I want an explicit mechanism to push a file to a native external application.

My next thought was =dired-do-shell-command= which can be activated by =!= or =X= in =dired=.  This brings up a default opening application called =xloadimage= which I'm assuming runs through possibly an XDG default application opening mechanism linked to the running window manager.  Well I don't really want to set a default application for each window manager / environment so I'm not sure that this is right approach either.

My next thought was how does =dired= determine which opening mechanism to use, I mean where does =xloadimage= come from?

Well the answer is twofold, firstly =dired-guess-shell-alist-default= and secondly =dired-guess-shell-alist-user=

The first list includes many lines in an alist format, for example:

#+begin_src elisp
("\\.jpe?g\\'" "xloadimage")
#+end_src

I don't really want to touch the default settings so lets have a look at the user variant which is described as follows:

#+begin_quote
User-defined alist of rules for suggested commands.
These rules take precedence over the predefined rules in the variable
‘dired-guess-shell-alist-default’ (to which they are prepended).
#+end_quote

I therefore appended the prepended list! (even though it was empty anyway)

#+begin_src elisp
(setq dired-guess-shell-alist-user
      (append '(("\\.\\(jpg\\|jpeg\\|png\\|gif\\|bmp\\)$" "gwenview")
                ("\\.\\(mp4\\|mkv\\|avi\\|mov\\|wmv\\|flv\\|mpg\\)$" "mpv"))
              dired-guess-shell-alist-user))
#+end_src

Now to the testing stage...

---

I seem to have an intermittent problem when running =! (dired-do-shell-command)= in that the file isn't always opened in gwenview, however mpv opens every single time!.  I literally have no idea what is going on here but =& (dired-do-async-shell-command)= opens every time! so lets use that then, it might be better to run the file opening asynchronously anyway.

However, another issue presents itself.  By default the async shell window always opens a new buffer / window and is polluting my emacs window layout!!!!.  Well certainly I can't have that so I decide to use the =display-buffer-alist= as follows:

#+begin_src elisp
(defvar go-away-repl-regexp
  (rx bos "*" (or "Async")
      (zero-or-more nonl))
  "Regexp for matching windows to disappear")

(add-to-list 'display-buffer-alist
             `(,go-away-repl-regexp
               display-buffer-no-window
               (inhibit-same-window . t)))
#+end_src

Done.

* DONE Org Table to Calculate Weight Loss :orgtable:org:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230910100202-emacs--Weight-Loss-Tables
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-09-12 Tue 21:11>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230910100202-emacs--Weight-Loss-Tables.jpg
:END:

For a while now I have been using org tables to represent and calculate pieces of data, obviating the need to open up a normal spreadsheet.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230910100202-emacs--Weight-Loss-Tables.jpg]]

Recently I have been wanting to create a table to keep track of weight loss and this is what I came up with (with example weights):

#+begin_src
| date             | weight | pounds | loss | total |
|------------------+--------+--------+------+-------|
| <2023-08-18 Fri> |   15:5 |    215 |      |       |
| <2023-08-25 Fri> |   14:9 |    205 |  -10 |   -10 |
| <2023-09-01 Fri> |   14:2 |    198 |   -7 |   -17 |
| <2023-09-08 Fri> |  13:11 |    193 |   -5 |   -22 |
,#+TBLFM: $3='(convert-weight $2)::@3$4..@>$4=$3-@-1$3::@3$5..@>$5=vsum(@$4..@3$4)
#+end_src

The initial difficulty was my British attachment to the imperial system which means always defining a human weight in stone and pounds.  I had to initially define the following function to parse the weight string value into a numeric total pounds representation.

#+begin_src elisp
(defun convert-weight (weight)
  (let* ((parts (split-string weight ":"))
         (stone (string-to-number (car parts)))
         (pounds (string-to-number (cadr parts))))
    (+ (* stone 14) pounds)))
#+end_src

After the date and weight is inserted the total pounds can be calculated as thus :

#+begin_src
$3='(convert-weight $2)
#+end_src

which is calculated for every data row.

I can now more easily calculate the loss each week with a simple org table equation and hence a total cumulative loss.

I think I can use =calc= in some way in an org table but for me this method seems easier and I have complete control over my weight input string.

The next issue is one I have run across many times with org tables and that is catering for a first line calculation.  This is where I have to start getting my head around cell referencing.

For this I found the =C-} (org-table-toggle-coordinate-overlays)= very useful which explicitly shows the cell reference positions.  The row column identifier often catches me out as the row specification only counts data lines and not things like headline fillers.

Org seems to prefer the @ROWS$COLUMN convention and although this doesn't feel intuitive to me (I prefer it the other way) I thought I would stick with it and just adjust my thinking.

The loss calculation although a simple one needs to only take place on those data rows that have a previous weekly weight value, namely all those data rows not in the first data line.

Therefore I specifiy a range:

#+begin_src
@3$4..@>$4=$3-@-1$3
#+end_src

Note the =@>= which references the last row.

Note: I think I could make this more flexible by specifying an offset from the hline, namely =@I+1=

Finally I need to add in a running cumulative total and again I had to consider not calculating on the first data line:

#+begin_src
@3$5..@>$5=vsum(@$4..@3$4)
#+end_src

So that's just about it for ongoing measurements.  I just need to insert a new row at the bottom of the table, insert a date and current weight and on recalculation all the work is done for me!

* DONE My Evolving Modeline :modeline:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230902114449-emacs--My-Evolving-Modeline
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-09-02 12:32>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230902114449-emacs--My-Evolving-Modeline.jpg
:END:

I am a tinkerer and of course emacs is a perfect vehicle for this mentality.  A prime example of this is my constant evolving modeline.  For many years the default modeline hasn't presented itself as being a problem, but is it optimal for me?, the answer I have now realised is no, and I think I can do better for my use cases.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230902114449-emacs--My-Evolving-Modeline.jpg]]

So after a period of introspection (regarding emacs! 🙂) I think I can now define a clear set of criteria for my perfect modeline:

1. Show the full pathname

   By default, emacs displays the buffer name, but during coding sessions, I often prefer to see the full file path, especially since I sometimes work with multiple copies of files with the same name.

2. Clearly indicate when a file has been modified

   For when I accidentally insert a 'n' or 'p' character in a buffer (I think you can guess how this happens!) it will be immediately apparent and I will be less likely to break my emacs config.

3. Have control over the faces

   Define my own sizing and colouring for an active and inactive buffer modeline to make clearer my current selected buffer.  Otherwise I will be at the whim of my current theme which may not always be optimal.

4. Efficient information display

   Fit as much information in a compact manner as possible, I don't want to be hunting around for buffer information, for example the column number and major modes should always be displayed.

5. Version control menu should be available

   I frequently use git/magit for version control and prefer to keep the menu bar disabled. This choice sometimes leads me to search for built-in VC (Version Control) commands within emacs. For instance, registering a new file in magit can be tricky since untracked files seem to only display top-level directories unless a subdirectory file has been registered. To include all files in a directory, I rely on vc-register, but I don't always remember the key chord. Therefore, having a VC menu in the mode line is immensely helpful.

6. Simplicity

   This includes keeping the modeline elisp definition as simple as possible for easier maintainability / transparency and never allowing extra items to creep in like email or miscellaneous information.

Given all this I have come up with the following:

#+begin_src elisp
(setq-default mode-line-modified
              '(:eval (if (and (buffer-file-name) (buffer-modified-p))
                          (propertize " * Modified " 'face
                                      '(:background "#e20023" :foreground "#ffffff")) "")))
(set-face-attribute 'mode-line-active nil :height 125
                    :background "#ffffff" :foreground "#000000")
(set-face-attribute 'mode-line-inactive nil :height 110
                    :background "#000000" :foreground "#ffffff")
(set-face-attribute 'mode-line nil :height 120)
(set-face-attribute 'mode-line-inactive nil :height 120)

(setq-default mode-line-format
              '("%e"
                mode-line-modified
                (:eval
                 (if (buffer-file-name)
                     (if (mode-line-window-selected-p)
                         (propertize (format "%s " (abbreviate-file-name (buffer-file-name)))
                                     'face '(:background "#6b91c0" :foreground "#ffffff" :inherit bold))
                       (format "%s " (abbreviate-file-name (buffer-file-name)))
                       )
                   )
                 )
                (:eval
                 (if (mode-line-window-selected-p)
                     (propertize "%o %4l %2c %b"
                                 'face '(:background "#b8b8b8" :foreground "#000000"))
                   "%o %4l %2c %b"))
                (vc-mode vc-mode)
                mode-line-modes
                )
              )
(setq mode-line-compact t)
#+end_src

I have tried to use the built-in modeline variables where possible and use =mode-line-compact= which replaces repeating spaces with a single space.

I found the best way to indicate a modified file and for it to clearly stand out on the modeline is by colour and string length, but I still wanted to keep the asterisk convention as this is quite common.

I decided to subtly change the size of the active and inactive modeline for extra emphasis and this can be massively exaggerated to taste.

* TODO Configuring-Ada-In-Emacs :noexport:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230827133556-emacs--Configuring-Ada
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-08-27 13:35>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230827133556-emacs--Configuring-Ada.jpg
:END:

This is a guide to setting up emacs as a software development environment using the programming language Ada and the steps I took to achieve an acceptable solution.

#+hugo: more

** Specs

Linux 6.4.12-arch1-1
swayfx
bash 5.1.16

** Requirements

In very simple terms what I require for any software development environment are as follows:

1. syntax highlighting
2. build system
3. quick xref
4. debugging

** A little history

The original ada-mode that came with emacs has now been removed (emacs version 28?) and you are generally expected to install the elpa ada-mode from AdaCore (version 8.0.5)

However I have never got this to work as it requires extra build steps which I have never got to successfully complete.

At work I use the =old-ada-mode= (version 4.1 - elpa / melpa) which was not the original built-in but a major rewrite of the file packaged with Emacs-20 (assuming it was the one mentioned above) this works well especially regarding xref, it uses its own propriety version, namely =ada-find-references= and uses =gnatfind= from the .ali information files generated by an Ada build.  At work I can get this to work and this may be due to =gnat find= being used which doesn't seem to be present on my arch machine, has the latest version of gnat deprecated gnat find?

On my arch machine installing =gcc-ada= gave me some gnat tools but strangely not gnatfind and not gprbuild (maybe understandable).

** gprbuild

My next step was to install gprbuild, this was a simple build from the AUR of gprbuild-bootstrap which builds gprbuild using gprbuild! (I tried just the gprbuild package but of course I didn't have gprbuild installed to build it!).  So a gprbuild could now build my ada projects but old-ada-mode still didn't work as it couldn't find gnatfind.

After this it is likely that you are going to have to setup the following:

/usr/share:
lrwxrwxrwx 1 30 Sep 30 08:58 gprconfig -> /opt/GNAT/2021/share/gprconfig

now the old-ada-mode works!

** xref

I tried to find gnatfind and gnatxref but this was not easy, the only way was to seemingly download the AdaCore community edition into /home/jdyer/Downloads/gnat-2021-20210519-x86_64-linux-bin from https://www.adacore.com/download although I'm not too sure if they are doing this anymore.  Ironically this also installed gprbuild!, but I would rather use AUR install it.

Even with gnatfind visible the old-ada-mode xref still didn't work as the -P<project name> possibly seems to be deprecated? so how do I know where the included folders are?, well I gave up for now and had another look at etags.

** TAGS

Again I have never got etags to work under emacs for Ada xref (works with C and C++), I run the following:

#+begin_src
(shell-command (concat "etags \"" file "\"g --append -o \"/home/jdyer/examples/TAGS\""))
#+end_src

it can never find any reference even though the inspection of TAGS seems to list the references desired.

Will ctags do any better, well I ran the following command:

#+begin_src
ctags -e -R .
#+end_src

and this did no better.

** Eglot / LSP

Mmmmm, right what's next, I know I am running emacs version 29.1 so what about eglot?

So open up an ada file and M-x eglot.  Aha I have some level of success with xref but it seems to only jump to a reference file that is in the same directory.  There is an error in the eglot events buffer:

:severity 1 :source "project" :message No project found in root directory. Please create a project file and add it to the configuration.")]))

I'm guessing severity 1 is quite serious!

I have a feeling that eglot is only finding a project file if it is in the local directory, so I will add =ede-new= to the project top level which creates a Project.ede file but also updates the ede-project-directories variable which seems pretty important.

(setq-default ede-project-directories '("/home/jdyer/examples/gnat-examples/menace"))

So to get eglot to work for ada we need a Project.ede residing in any one of the ede-project-directories

Unfortunately I have now noticed that emacs gets stuck when starting up and on some trial and error investigation it is related to the contents of .emacs.desktop of an ada file.  On a desktop-create-buffer for an ada file if the major mode is set to ada-mode or even ada-ts-mode then it gets stuck, if I replace it with fundamental-mode or even c-mode emacs loads normally.

** Treesitter

Well lets ignore that for the moment and focus on treesitter, now it is backed into emacs 29.1 I would like to try it out.  old-ada-mode works well enough for me regarding syntax highlightling and anything else I want from it but I want to see if treesitter offers me anything else.

Installing was pretty straightforward, first we need to install the grammar which involves setting:

#+begin_src elisp
(setq treesit-language-source-alist
      '(
        (ada "https://github.com/briot/tree-sitter-ada")
        )
#+end_src

and then running =treesit-install-language-grammar=

the =ada-ts-mode= isn't built into emacs but can be retrived from melpa with:

#+begin_src elisp
(use-package ada-ts-mode)
#+end_src

the next thing to do is to make sure =ada-ts-mode= is activated whenever an Ada file is loaded and this can be achieved by the following:

#+begin_src elisp
(cl-loop for ext in '("\\.gpr$" "\\.ada$" "\\.ads$" "\\.adb$")
         do (add-to-list 'auto-mode-alist (cons ext 'ada-mode)))
#+end_src

Now you will notice I have activated the old ada-mode but I think for the moment this makes more sense for when I might want to return to my tried and tested old-ada-mode but with all things treesitter I can map major modes so for the moment I will map as follows:

#+begin_src elisp
(setq major-mode-remap-alist
      '(
        (ada-mode . ada-ts-mode)
        )
      )
#+end_src

Now when I open an ada source file ada-ts-mode is loaded and I get some nice syntax highlighting!

The only thing at the moment I am not too sure about is the indentation and seems to be using the relative-indent function which is pretty much the default and indents to the next space / indent, but this is probably more about the melpa ada-ts-mode than anything else and of course treesitter and emacs is quite a new thing and I'm sure that things will mature in the future.

** Conclusion

So where does this leave me regarding modifying, building and having an effectively fast ada workflow?, well my plan thus far is...

1. *syntax highlighting* - Use the =old-ada-mode= of which I now have a linked repos as it doesn't really seem to be available anywhere
2. *build system* - Install gprbuild-bootstrap on arch to get gprbuild
3. *quick xref* - Make sure I set up ede projects and emacs variables accordingly and use =eglot= for xref as I can't seem to easily get the old gnatfind related functionality to work
4. *debugging* - Oh and regarding debugging that is pretty easy, just use gdb!

** TO DO

1. Fix the save-desktop ada*-mode issue
   decided to remove the save-desktop functionality so far to see if I can get on with it.

2. Try new ada-mode again from AdaCore
   Tried again, not sure if I need to build anything but doesn't work anyway due to gnatcoll, and the indentation raises an error:
   [server-reply] (id:9) ERROR Mon Aug 28 09:41:12 2023:
   (:jsonrpc "2.0" :id 9 :error
   (:code -32603 :message ""))

   also if elgot isn't running I get:
   jsonrpc-error: jsonrpc-error: "No current JSON-RPC connection", (jsonrpc-error-code . 32603), (jsonrpc-error-message . "No current JSON-RPC connection") [2 times]

   and indentation doesn't work!

3. Going back to =old-ada-mode=

* DONE ahk-mode and Updating To AutoHotKey Version 2 :kmonad:emacs:autohotkey:artrage:art:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230825115829-emacs--Updating-To-AutoHotKey-V2
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-08-25 14:10>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230825115829-emacs--Updating-To-AutoHotKey-V2.jpg
:END:

I have now managed to set up my external USB numeric keypad on Linux using =kmonad= which lets me use any regular plugged-in number keypad as a shortcut tool for my digital art.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230825115829-emacs--Updating-To-AutoHotKey-V2.jpg]]

This comes in very handy when painting in Krita and ArtRage (through Wine) and maybe one day I will expand this functionality to GIMP when version 3.0 comes out!

I would like the same keymapping functionality to be reflected on Windows (as ArtRage is fundamentally a Windows application).  Technically =kmonad= should work but I'm going to use =AutoHotKey= as I'm much more familiar with it.

I have a problem though, my old =autohotkey= scripts don't work with the latest version of =AutoHotKey= (version 2).  On further investigation it seems that /version 2/ is a significant update and includes the simplification and shift of the syntax.

Well I guess I had better update my scripts then!.

On Windows by default an =ahk= extension offers to open *notepad* which initially I did as I thought the changes would be simple enough and actually notepad isn't too bad these days what with the multiple tabs, dark mode and even multiple undos!.  However I quickly became frustrated with the lack of syntax highlighting / indenting e.t.c.  I have used a specific =ahk= editor in the past, something like =SciTE4AutoHotkey= but this time I thought I would break out =emacs= and see what it had to offer.

Initially loading the =ahk= script started fundamental mode and of course had no syntax highlighting.  Running =list-packages= and then a quick search for /AutoHotkey/ brought up the only package available, which was *=ahk-mode=*.  This package seems pretty straightforward and although it was last updated in 2016 (so won't cater too well with the AutoHotkey v2 shift in syntax) the syntax highlighting, commenting and indenting were just fine enough for me.  It also seems to be well integrated with =company-mode= and although I'm not a great fan of =company-mode= in general in this case it might actually be useful.

I was now able to comfortably convert my scripts to AutoHotKey v2, for example:

*version 1*
#+begin_src
#IfWinActive, ahk_class ArtRage 3
NumpadDiv:: ^z
NumpadMult:: ^y
NumpadHome::Shift
NumpadUp:: Alt
NumpadLeft:: Space
NumpadRight::
GetKeyState, state, h
if state = D
    Send {h up}
else
    Send {h down}
return
NumpadEnd:: Control
NumpadPgDn:: RButton
#+end_src

*version 2*
#+begin_src
#HotIf WinActive("ahk_class ArtRage 3")
NumpadDiv:: ^z
NumpadMult:: ^y
NumpadHome::Shift
NumpadUp:: Alt
NumpadLeft:: Space
NumpadRight::
{
if GetKeyState("h")
    Send "{h up}"
else
    Send "{h down}"
}
NumpadEnd:: Control
NumpadPgDn:: RButton
#+end_src

While I was in amongst the scripts I decided to add in something extra and that is to map the *Capslock* key to the *Control* key; a not uncommon mapping for a regular emacs user.

So I added in the following line and plonked the script into the Windows startup folder:

#+begin_src
Capslock::Control
#+end_src

* DONE Reverting Buffers :emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230821125951-emacs--Reverting-Buffers
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-08-21 12:59>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230821125951-emacs--Reverting-Buffers.jpg
:END:

It is not uncommon for me to want to revert my current buffer.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230821125951-emacs--Reverting-Buffers.jpg]]

For a long while I have used =(find-alternate-file)= which by default is bound to =C-x C-v=

Recently I switched to mapping this keybinding to =revert-buffer= but now I have found out about:

#+begin_src
(revert-buffer-quick &optional AUTO-SAVE)

Like ‘revert-buffer’, but asks for less confirmation.
If the current buffer is visiting a file, and the buffer is not
modified, no confirmation is required.
#+end_src

It is bound to =C-x x g= and has the added benefit of not always asking for confirmation!

I will try and add this new command to my muscle memory but shall I just unbind my old =revert-buffer= key-mapping or rebind =C-x C-v= to this new function also?, in other words should I fully commit?

* DONE Fun With Emacs Theming Using Alpha Background on Wayland :wayland:sway:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230819105507-emacs--Fun-With-Emacs-Theming-Using-Alpha-Background-Wayland-Sway
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-08-19 10:55>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/2023-08-15-20-18-36_t.jpg
:END:

Simply put here is me playing around with emacs transparency using =alpha-background= to set up *sway* the way I want it to look - I think there is some kind of well known term for this! (no =neofetch= involved 🙂)

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230819105507-emacs--Fun-With-Emacs-Theming-Using-Alpha-Background-Wayland-Sway/2023-08-14-21-08-41.jpg]]

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230819105507-emacs--Fun-With-Emacs-Theming-Using-Alpha-Background-Wayland-Sway/2023-08-16-14-02-05.jpg]]

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230819105507-emacs--Fun-With-Emacs-Theming-Using-Alpha-Background-Wayland-Sway/2023-08-15-20-18-36.jpg]]

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230819105507-emacs--Fun-With-Emacs-Theming-Using-Alpha-Background-Wayland-Sway/2023-08-15-20-30-04.jpg]]

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230819105507-emacs--Fun-With-Emacs-Theming-Using-Alpha-Background-Wayland-Sway/2023-08-15-20-40-05.jpg]]

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230819105507-emacs--Fun-With-Emacs-Theming-Using-Alpha-Background-Wayland-Sway/2023-08-16-13-01-00.jpg]]

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230819105507-emacs--Fun-With-Emacs-Theming-Using-Alpha-Background-Wayland-Sway/2023-08-16-13-01-39.jpg]]

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230819105507-emacs--Fun-With-Emacs-Theming-Using-Alpha-Background-Wayland-Sway/2023-08-16-20-23-10.jpg]]

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230819105507-emacs--Fun-With-Emacs-Theming-Using-Alpha-Background-Wayland-Sway/2023-08-17-22-00-35.jpg]]

* DONE No Bell For Me :scrolling:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230817170149-emacs--No-Bell-For-Me
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-08-17 17:01>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230817170149-emacs--No-Bell-For-Me.jpg
:END:

Now I have set =(pixel-scroll-precision-mode 1)= which comes with emacs 29 this has led to an unexpected issue in that I now often get the following messages which cause a bell sound to be generated each time:

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230817170149-emacs--No-Bell-For-Me.jpg]]

#+begin_src
pixel-scroll-precision-scroll-up-page: Beginning of buffer [22 times]
pixel-scroll-precision-scroll-down-page: End of buffer [54 times]
#+end_src

I had turned to =(setq visible-bell t)= in the past but this generates an annoying flash each time rather than an annoying bell sound.

There is a solution to this of course and that is =(setq ring-bell-function 'ignore)= in that we are silent when a visual bell is rung, ah pure bliss 🙂🔔

* DONE Emacs 29.1 Transparency Alpha On Sway :sway:emacs_29:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230812141900-emacs--Emacs-29-1-Transparency-Alpha-On-Sway
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-08-12 15:36>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230812141900-emacs--Emacs-29-1-Transparency-Alpha-On-Sway.jpg
:END:

I have just been been going through the new features added to emacs 29.1 and have been trying out the transparency or =alpha-background= on =sway=.

#+hugo: more

#+begin_quote
"=alpha-background= controls the opacity of the text background when running on a
composited display.".
#+end_quote

I was keenly looking for an emacs improvement to the =swaywm= built in compositing method which in the case of emacs would make transparent the whole window including text which of course isn't ideal.

I had defined the following in my =sway= config file:

#+begin_src
for_window [class="Emacs"] opacity 0.92
#+end_src

=0.92= seemed to be the perfect balance between wallpaper visibility and text legibility.

I am now going to compare the emacs =alpha-background= method with an equivalent =sway= emacs compositing opacity.

So for emacs I am going to set something like:

#+begin_src
(set-frame-parameter nil 'alpha-background 70)
(add-to-list 'default-frame-alist '(alpha-background . 70))
#+end_src

See the following images for a comparison (can you guess which is which?) - I would suggest opening each image in separate browser tabs and comparing that way.

Note/Disclaimer: I chose opacity values that displayed an equivalent wallpaper visibility through emacs and as it turned out the opacity values were different which I suspect relates to the way the =sway= compositor is processing its opacity value rather than the way emacs does it but the demonstration fundamentally should still be a valid one.

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230812141900-emacs--Emacs-29-1-Transparency-Alpha-On-Sway-Old.jpg]]

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230812141900-emacs--Emacs-29-1-Transparency-Alpha-On-Sway.jpg]]

and here is a more detailed comparison on a selected screen region:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230812141900-emacs--Emacs-29-1-Transparency-Alpha-On-Sway-Old-s.jpg]]

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230812141900-emacs--Emacs-29-1-Transparency-Alpha-On-Sway-s.jpg]]

Suffice it to say that this is a very nice improvement and certainly something I shall be using from now on.

* DONE Saving My Favourite Wallpapers :sway:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230811043547-emacs--Saving-Favourite-Backgrounds
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-08-11 05:22>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230811043547-emacs--Saving-Favourite-Backgrounds.jpg
:END:

I am using the =styli.sh= script as my wallpaper changer in *sway* and with a little transparency and wallpapers from *unsplash* I can quickly switch randomly through my wallpaper images and get things looking pretty nice.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230811043547-emacs--Saving-Favourite-Backgrounds.jpg]]

I tend to switch a few times before I find one that I like, but that image tends to disappear when I restart my laptop and the wallpaper gets reset.  What I would like to do is to have the ability to send the current wallpaper to a wallpaper favourite folder to build up a chosen set of images.

The first step to achieving this would be to add a couple of lines to the =styli.sh= bash script to copy the current wallpaper image to a defined location.  I am guessing that sway stores this image somewhere but as =styli.sh= handles all the variables and logic I might as well add in the following:

#+begin_src bash
swaymsg output "*" bg "$WALLPAPER" "$MODE"
rm ~/wallpaper-faves*.{jpg,jpeg,png,gif}
cp "$WALLPAPER" ~/wallpaper-faves-${WALLPAPER##*/}
#+end_src

and now for some emacs elisp to move this wallpaper image into a favourite folder :

#+begin_src elisp
(defun my/copy-background-to-faves ()
  "Copy the current sway background to wallpaper faves folder"
  (interactive)
  (let* ((source-folder "/path/to/home/")
         (faves-folder "/path/to/wallpaper/faves/")
         (image-files (directory-files source-folder nil "^wallpaper-faves.*\\.\\(jpg\\|jpeg\\|png\\|gif\\)$" nil nil)))
    (dolist (image-file image-files)
      (rename-file (concat source-folder image-file) (concat faves-folder image-file) t)
      )
    )
  )
#+end_src

Now over time my =faves-folder= will build up with all my cherished wallpapers and I can begin the process again!

* DONE Simplifying My Modeline :emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230806091105-emacs--Simplifying-My-Modeline
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-08-06 09:22>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230806091105-emacs--Simplifying-My-Modeline.jpg
:END:

After watching the latest informative video from Protesilaos Stavrou (Prot):

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230806091105-emacs--Simplifying-My-Modeline.jpg]]

[[https://www.youtube.com/watch?v=Qf_DLPIA9Cs&t=4s][Emacs: write custom mode line]]

I decided to try and create my own simple mode line incorporating the features I regularly glance at throughout a day.  Having =mu4e= and =magit= details on my mode line plus other mysterious characters seems a bit much.

After adapting the examples given in the video I created the following:

#+begin_src elisp
(setq-default mode-line-format
              '("%e"
                " %o "
                "%* "
                my-modeline-buffer-name
                my-modeline-major-mode))

(defvar-local my-modeline-buffer-name
    '(:eval
      (when (mode-line-window-selected-p)
        (propertize (format " %s " (buffer-name))
                    'face '(t :background "#3355bb" :foreground "white" :inherit bold))))
  "Mode line construct to display the buffer name.")

(put 'my-modeline-buffer-name 'risky-local-variable t)

(defvar-local my-modeline-major-mode
    '(:eval
      (list
       (propertize "λ" 'face 'shadow)
       " "
       (propertize (capitalize (symbol-name major-mode)) 'face 'bold)))
  "Mode line construct to display the major mode.")

(put 'my-modeline-major-mode 'risky-local-variable t)
#+end_src

I left in *=%e=* as suggested to show an error message if memory was full.

*=%o=* for how far through the buffer I am.  I have my scroll bars disabled but always find it useful to see where I am in a file especially when coding or within a large org file (for example when applying some repetitive macros seeing 80% through the buffer is quite motivating!)

*=%*=* to indicate if a file has been modified using the asterisk convention which is common in many other programs and has the side-effect of removing all other cryptic characters that I don't understand.  In the future I can always add some back in again but at that point I will (hopefully) understand what I am reintroducing.

Finally it is just the case of adding the buffer name and major mode which comes straight from the examples given in the video.

I especially like the control over the file name colour profile in combination with the use of the =mode-line-window-selected-p= function (introduced as part of emacs 29) which helps to identify the buffer in focus.

As with all these things I will use it and adapt accordingly and hopefully not feel the need to add everything back in again!, I think I like this simplicity for now.

* DONE Showing Org Agenda For The Year :emacs:elisp:agenda:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230722194000-emacs--Showing-Org-Agenda-For-The-Year
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-08-04 06:21>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230722194000-emacs--Showing-Org-Agenda-For-The-Year.jpg
:END:

I am just starting to include more of my org files into =org-agenda=.  By default =C-c a a= gives a show for the next 7 days but I think for now I would like something of a more calendarish overview with a long form look of scheduled and completed tasks.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230722194000-emacs--Showing-Org-Agenda-For-The-Year.jpg]]

I thought I would write an =elisp= function:

#+begin_src elisp
(defun display-year-agenda (&optional year)
  "Display an agenda entry for a whole year."
  (interactive (list (read-string "Enter the year: "
                                  (format-time-string "%Y" (current-time)))))
  (setq year (string-to-number year))
  (org-agenda-list)
  (org-agenda-year-view year)
  (setq this-year (string-to-number (format-time-string "%Y" (current-time))))
  (when (= year this-year)
    (org-agenda-goto-today)
    (recenter-top-bottom 10)))

;; Bind a key for easy access
(global-set-key (kbd "C-c y") 'display-year-agenda)
#+end_src

The default prompt is the current year but with the ability to enter any year desired.  I also thought that if calling up this current year then I would want to highlight today and recenter a little.

As with all things I will give this a go for a while and see if it fits nicely into my workflow.

* DONE Shrinking Media With The Help Of Emacs :emacs:dired:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230730102057-emacs--Shrinking-Media-With-The-Help-Of-Emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-07-30 15:28>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230730102057-emacs--Shrinking-Media-With-The-Help-Of-Emacs.jpg
:END:

Often I find myself refining my collection of photos and family videos, usually with the following process:

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230730102057-emacs--Shrinking-Media-With-The-Help-Of-Emacs.jpg]]

- removing media clutter
- removing any duplicates
- tagging as necessary
- compressing where reasonable
- renaming to a more =denote= format

Emacs and the associated muscle memory greatly helps with this process.

Firstly though I leverage other applications, for example, duplicate removal and tagging takes place through =digikam=, media clutter through =thunar= and =gthumb=

My emacs process is then:

- open media directory in =dired=

- sort by size using =C-u s S= - the big S is setting the ls format by size

- =M-<= =(beginning-of-buffer)= - so I can see the largest files

- if I want to squish a video I will probably want to preview it first in *mpv*, so I do this asynchronously using =&= =(dired-do-async-shell-command)= and relying on my defined =dired-guess-shell-alist-user= setup and then selecting =i= (mpv shortcut) to have a quick peek at the original dimensions.  Typically if the video is 1920x1080 then I like to halve the dimensions which when running through =ffmpeg= saves about 80-90% on disk space.

  I have my own =ffmpeg= bash scripts which I call through =dwim-shell-command= so a command search for something like *dw sh* =my/dwim-video-shrink= will dired execute the file under cursor or over a list of marked files.

- for images I again use =dwim-shell-command= with a quick command search for something like *dw cr* =my/dwim-picture-crush= which isn't always as brutal as it might suggest but a script that I regularly modify when compressing images, setting the compression parameters appropriately.

  If I need to quickly inspect the image then I could open it in emacs but I prefer again to open in gthumb using =&=

- Possibly at the end of a directory compress I might check the directory size by =?= in =dired= which I have mapped to an elisp =my/get-file-size= function that runs the =async-shell-command= =du -=

- and of course my files can be easily renamed through =wdired=

As I am using a tiling window manager all of this can be accomplished keyboard only and on a single screen!

* DONE Defining Categories in Org Files for Hugo :markdown:hugo:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230513130655-emacs--Hugo-Adding-Categories
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-07-21 13:02>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230513130655-emacs--Hugo-Adding-Categories.jpg
:END:

I use Hugo to generate my web site and I made a decision early on to use =ox-hugo= withing emacs and to manage a single large =org= file with each subheading a blog post and each subheading tag representing... well, tags! I was aware of the concept of defining categories but decided to sort that out at a later date until I really understood what I was doing - this is a common thing that I do.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230513130655-emacs--Hugo-Adding-Categories.jpg]]

Well now I think I understand what I'm doing and now I want to create categories for my web site and as it turns out managing my posts within org files means that this can be achieved very easily.

For example, I have the following set up in my org file:

#+begin_src
,* Emacs [0/0] :emacs:linux:
,** DONE Initial focus in Occur Buffer :occur:elisp:2023:
,** DONE Cursor Blinking Rate :2023:
#+end_src

This means that the subheadings / posts under the top level =Emacs= heading inherit the =emacs= and =linux= tags and then define any extra specific to each post as desired.  As these tags are defined at the top level then you could almost say they are defining a more broad definition, lets say a category!

So how do I change these top level tags to categories?, well I define the following:

#+begin_src
,* Emacs [0/0] :@emacs:@linux:
#+end_src

It is just a very slight change to the org tag definition after which I just need to re-export all my blog posts / subheadings using the =ox-hugo= dispatcher.

The generated markdown files now contain the following front matter which Hugo can now process accordingly:

#+begin_example
tags = ["occur", "elisp", "2023"]
categories = ["emacs", "linux"]
#+end_example

Simple! and in fact you can see an example of how the categories are incorporated in this very web site!

* DONE Porting Dolphin Context Sensitive Scripts To Thunar :thunar:org:macros:linux:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230709144332-emacs--Porting-Dolphin-Scripts-To-Thunar
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-07-10 20:03>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230709144332-emacs--Porting-Dolphin-Scripts-To-Thunar.jpg
:END:

I have decided to switch my linux file manager from Dolphin to Thunar and this means transferring the context sensitive menus I have set up through KDE Plasma to using Thunar's custom actions.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230709144332-emacs--Porting-Dolphin-Scripts-To-Thunar.jpg]]

I quickly figured out that I can just modify ~$HOME/.config/Thunar/uca.xml~ to add in new Thunar actions, so all I need to do is to firstly work out how to perform the translation from Dolphin to Thunar actions and then how to set up emacs in such a way that would get me to a quick solution.

Dolphin relies on files within ~$HOME/.local/share/kservices5/ServiceMenus~ to define the context menus and I have separate files for each MIME type:

- AudioMenu.desktop
- PictureMenu.desktop
- VideoMenu.desktop

Each one has an actions list near the top defining a link to multiple script command definitions throughout the file.  So I think all I need to do is to extract out the actions, for example :

#+begin_src
Actions=PictureConvert;PictureInfo;PictureRotateLeft;PictureRotateRight;PictureScale;PictureAutoColour;PictureCrush;PictureMontage;PictureRotateFlip;PictureUpscale;PictureGetText;PictureOrientation;PictureCorrect;Picture2pdf
#+end_src

and apply them to the ~uca.xml~ file using an example I had already created as a prototype :

#+begin_src
<action>
   <icon></icon>
   <name>PictureConvert</name>
   <submenu></submenu>
   <unique-id>1688724015024216-1</unique-id>
   <command>ServiceConsole PictureConvert %F</command>
   <description>PictureConvert</description>
   <range>*</range>
   <patterns>*</patterns>
   <image-files/>
</action>
#+end_src

The ~ServiceConsole~ script is just a wrapper around each bash script and lets me choose the terminal, shell and anything else I would like to wrap around:

#+begin_src bash
#! /bin/bash
konsole -e "/bin/bash -c '$*; echo; echo "Finished"; read input'"
#+end_src

Now I know what needs to be done I think I will create a window in emacs on the left containing the Thunar custom action file (=uca.xml=) and =*scratch*= on the right and then define a macro to step through each action and apply the script names to the =uca.xml= file.

I can now extract the =Actions= list from each file, paste it into the scratch buffer and then =forward-word= copy to the kill ring in turn and for each script name copy and paste to a new copy of the xml example template.

The only other aspect I need to pay attention to is the transfer of the MIME types to =<image-files/> <audio-files/> <video-files/>=

There is a =<unique-id>= set for each action but I think that is more of an internal Thunar Id and I could just copy and paste the existing Id as part of my macro and it still works.

So for a task that I thought would take quite a while and would be convoluted in the end turned out to be pretty trivial and this was mainly due to at first spending some time working out how to translate the configuration files (with a little prototyping) and then applying the transformation using emacs.

These context sensitive menu bash scripts transforming image, video and audio files can also be run off the command line and I can run them in emacs using the *dwim-shell-command* package. This means that I now have a consistent media transformation set of tools across all my file managers!

I will go into more detail on my use of *dwim-shell-command* in a future blog post ;)

* DONE Dired Duplicate Here Revisited :elisp:emacs:dired:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230606213531-emacs--Dired-Duplicate-Here-Revisited
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-07-04 21:13>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230606213531-emacs--Dired-Duplicate-Here-Revisited.jpg
:END:

It is not uncommon for me to want the ability to quickly duplicate a file, especially if I am hacking around and just want a quick snapshot of a working file.

#+hugo: more

Previously I was using =dired= in a slightly convoluted manner, namely:

- open dired
- cursor over the desired item to rename
- =w= (dired-copy-filename-as-kill)
- =C= (dired-do-copy)
- paste from the kill ring (yank)
- modify the filename as desired
- return

But I never actually used this functionality so I think its time for a different approach.

Since I have recently been delving into *elisp* I thought I would write an interactive function:

#+begin_src elisp
(defun my/dired-duplicate-file (arg)
  "Duplicate the current file in Dired."
  (interactive "p")
  (let ((filename (dired-get-filename)))
    (setq target (concat (file-name-sans-extension filename)
                         "-old"
                         (if (> arg 1) (number-to-string arg))
                         (file-name-extension filename t)))
    (if (file-directory-p filename)
        (copy-directory filename target)
      (copy-file filename target))
    )
  )

(define-key dired-mode-map (kbd "C-c d") 'my/dired-duplicate-file)
#+end_src

The function first gets the name of the current file in the Dired buffer using `dired-get-filename`. It then creates a new filename for the duplicated file by appending "-old" to the base filename (i.e., without the extension), followed by the number specified by the `arg` prefix argument, and the original file extension.

For example, if the `arg` argument is 3, and the original filename is "example.txt", the duplicated filename would become "example-old3.txt".

The function then checks if the file is a directory using `file-directory-p`. If the file is a directory, it copies the entire directory to the new target directory. If the file is a regular file, it copies the file to the new target file.

The function is interactive, meaning it can be invoked with a key press or command invocation. The function does not return a value.

---

Could you tell I used ChatGPT to describe this function?, well it was accurate, very precise, but very clinical, possibly useful for the quick documenting of written functions though.

I prefer the following more human approach:

#+begin_quote
By default a quick flick of the fingers would duplicate rename a file or directory via emacs =dired= adding the keyword =old= and potentially a numeric value by means of the universal argument.
#+end_quote

Most of the time I just want a quick single backup but for more duplicates there is the option of a quick C-u (adds a 4) and a C-u C-u (a 16) e.t.c

#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/20230606213531-emacs--Dired-Duplicate-Here-Revisited.jpg]]

That should do me for now, lets see how I get on!

* DONE Cycling Colours in CSS and Other Files :emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230623095629-emacs--Toggle-Colours-CSS
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-06-23 11:04>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230623095629-emacs--Toggle-Colours-CSS.jpg
:END:

I try and keep a simple colour scheme definition for my web site using some CSS variables:

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230623095629-emacs--Toggle-Colours-CSS.jpg]]

#+begin_src
--theme-fg: #2b2d3a;
--theme-bg: #fffbef;
--theme-alt: #ffa500;
#+end_src

=rainbow-mode= of course helps to show the colours in situ, but sometimes if I am changing the colour scheme I use =list-colors-display= and then copy and paste the hex value.  But should I use the name instead?, it is tempting as the colour would be very apparent and readable in the CSS file but then it is difficult to just incrementally tweak a hex value to get the colours to look just right.  I also like to use orange, well I always seem to revert back to it but I can never remember the hex value.

There is an in-built function in emacs which can help me out with all this called =css-cycle-color-format= and is bound to C-c C-f

With the point over the colour, potentially three different CSS color formats are cycled, by name (if possible), hexadecimal, and rgb()/rgba().

For example I could cycle through orange as thus:

#+begin_src
--theme-alt: orange;
--theme-alt: #ffa500;
--theme-alt: rgb(255, 165, 0);
--theme-alt: orange;
#+end_src

What about a colour / hex value in a non CSS file I hear you say, well although =css-cycle-color-format= is bound to =css-mode-map= it can be called for other files and in other modes.  For example in =init.el= calling =css-cycle-color-format= seems to work so I guess it could just be rebound to any =mode-map= as desired.

Also if you have a CSS file with a profusion of hex colour values the =css-cycle-color-format= command could find the name value for you, for example as a test, putting in a colour that is obviously red :

#+begin_src
--theme-alt: #ff0000;
#+end_src

cycles to:

#+begin_src
--theme-alt: red;
#+end_src

* DONE Revert Git Permission Changes On Repository Transfer :magit:emacs:bash:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230617200412-emacs--Revert-Git-Permission-Changes-On-Transfer
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-06-17 20:30>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230617200412-emacs--Revert-Git-Permission-Changes-On-Transfer.jpg
:END:

I recently reinstalled my laptop and copied across my git repositories from an external backup drive.  However most of my repositories were flagged by =magit= as having been /updated/ mainly with the following issue on multiple files:

#+hugo: more

#+begin_src
old mode 100644
new mode 100755
#+end_src

I found a fix for a single repository on =stackoverflow= but I have quite a few repositories now, so I wrote the following bash script borrowing the core git diff command fix and then ran it in =eshell=

#+begin_src bash
#!/bin/bash

LIST="DCIM/Art/Content/ArtAssets
  DCIM/Art/Content/ArtRage
  DCIM/Art/Content/ArtRagePenTool
  DCIM/Art/Content/ArtRageTabletFriend
  DCIM/Art/Content/InfinitePainter
  DCIM/Art/Content/Krita
  DCIM/content
  bin
  publish"

for item in $LIST; do
    echo $item
    cd ~/$item
    git diff -p -R --no-ext-diff --no-color \
        | grep -E "^(diff|(old|new) mode)" --color=never \
        | git apply
done
#+end_src

This is where the integrated nature of emacs can come in useful, although the =stackoverflow= example was the git diff line I wanted to perform this for each of my repositories and to achieve this I just simply grabbed the Path column output of =magit-list-repositories= using =rectangle-mark-mode= and trimmed down using some macros so I could iterate through each repository directory and run the command each time to clean up.

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230617200412-emacs--Revert-Git-Permission-Changes-On-Transfer.jpg]]

* TODO Renaming-My-Media-Using-Dired :noexport:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230608082742-emacs--Renaming-My-Media-Using-Dired
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-06-08>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230608082742-emacs--Renaming-My-Media-Using-Dired.jpg
:END:

#+hugo: more

#+begin_src elisp
(defun my/rename-media ()
  (interactive)
  (setq counter 5000)
  (setq regex-list
        '(
          "/[0-9]\\{14\\}--\\(20[0-9-\.].*\\)__"
          "\\([Ss]creenshot_[0-9_].*\\)__"
          "\\([Ss]creenshot_[0-9_].*\\)\.jpg"
          "\\([Yy]ou[Cc]ut_[0-9_].*\\)__"
          "--\\(VID_[0-9_].*\\)__"
          "--\\(IMG[0-9_\(\)].*\\)__"
          "--\\(IMG-[0-9_\(\)].*\\)-WA"
          )
        )
  (dolist (regex-i regex-list)
    (goto-char (point-min))
    (while (re-search-forward regex-i nil t)
      (setq counter (+ counter 1))
      (replace-match (concat "DSC" (format "%05d" counter)) t t nil 1)
      (message (match-string 1))
      )
    )
  )
#+end_src

* DONE Magit Status To Show Tracked Files :magit:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230604121310-emacs--Magit-Insert-Tracked-Files
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-06-08 11:05>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230604121310-emacs--Magit-Insert-Tracked-Files.jpg
:END:

While currently piecing together my git repositories and figuring out which files to commit I am invariably going to have some *Untracked files* but I also would like to see the *Tracked files* in =magit-status=

#+hugo: more

Well emacs being emacs this can be easily achieved, I added the following to my =use-package magit= declaration.

#+begin_src elisp
:config
(magit-add-section-hook
 'magit-status-sections-hook 'magit-insert-tracked-files nil 'append)
#+end_src

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230604121310-emacs--Magit-Insert-Tracked-Files.jpg]]

* DONE Quickly Deleting Duplicate Blank Lines :emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230603114025-emacs--Quickly-Deleting-Duplicate-Lines
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-06-03 21:38>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230603114025-emacs--Quickly-Deleting-Duplicate-Lines.jpg
:END:

I am currently hacking around with my org files and in fact macro removing quite a few unnecessary lines.  However this has had the side effect of leaving some significant holes in the form of blank lines.  Sometimes just two duplicate blank lines and sometimes more!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230603114025-emacs--Quickly-Deleting-Duplicate-Lines.jpg]]

I found that I can quickly trim them down by using =delete-duplicate-lines= and making sure the identical lines must be adjacent argument is set by passing in a *C-u C-u* prefix.

So the process is:
- open the org file
- =mark-whole-buffer=
- *C-u C-u* =delete-duplicate-lines=

and that's it!, the key here is the prefix argument otherwise all the blank lines will be deleted which is not what I want.

Of course this method would delete all duplicate adjacent lines and not just the blank ones so I guess you would generally need to be a little careful, but I know I don't have any of these and if I am not too sure then I can just inspect a git diff.

* DONE Insert Unique Log Message :emacs:ada:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230523204523-emacs--Insert-Unique-Log-Message
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-05-29 12:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230523204523-emacs--Insert-Unique-Log-Message.jpg
:END:

I had tried to implement a debugging logging/print method myself using macros but hadn't really achieved the level of elegance outlined in https://xenodium.com/sprinkle-me-logs/

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230523204523-emacs--Insert-Unique-Log-Message.jpg]]

I added a couple of programming modes to the function defined in the post above and have now incorporated it into my workflow:

#+begin_src elisp
((equal major-mode 'ada-mode)
 (cons (format "Ada.Text_Io.Put_Line (\"%s: \\([0-9]+\\)\");" word)
       (format "Ada.Text_Io.Put_Line (\"%s: %%s\");" word)))
((equal major-mode 'c++-mode)
 (cons (format "std::cout << \"%s: \\([0-9]+\\)\" << std::endl;" word)
       (format "std::cout << \"%s: %%s\" << std::endl;" word)))
#+end_src

For some reason I always seem to tend to ribald statements within my code, something like *poop* or some other unsavoury variant, I just need to remember to tidy these up later on!

Oh and I added an old fashioned emacs badge to the top of this blog just for fun! as technically it is kinda true as in this web page and of course as in me as a human 😀

* TODO Using visual-fill-column for individual org files :org:noexport:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230520111851-emacs--Using-visual-fill-column
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-05-20 12:50>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230520111851-emacs--screenshot.jpg
:END:

I have been using =visual-fill-column= for a little while now and I think I prefer it to =olivetti=, it is leveraging my =fill-column= variable and is simpler to set up.

#+hugo: more

The only additional config I require is the following:

#+begin_src elisp
(setq-default visual-fill-column-center-text t)
#+end_src

I set =visual-fill-column= typically globally, as it provides a centered appearance for files on a single window and a split window would not change the aesthetics even with the mode enabled.

However after a while I began facing certain problems, particularly while altering source code files, as the limited formatting felt constrictive and I felt the urge to truncate lines in such instances.

For the time being, I have concluded that =visual-fill-column= is only necessary for org files and I simply prefer to manage the =fill-column= for each individual file.

So I decided on a two pronged approach.

All my org files are in a single directory, so firstly I created a =.dir-locals.el= file by running =add-dir-local-variable= selecting =org-mode=, =eval= and the appropriate elisp, to give me:

#+begin_src elisp
((org-mode . ((eval . (visual-fill-column-mode t)))))
#+end_src

org files in a specified directory are now centered in a window based on my =fill-column= setting.

However some org files tend naturally to a smaller width than others and I would like more control over the =fill-column= for each individual file.

To achieve this I set up some file local variables using the snippet below inserted at the bottom of each org file:

#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/20230520111851-emacs--screenshot.jpg]]

or the option is to modify the first line of the org file as thus:

#+begin_src
-*- mode: org; fill-column: 90; -*-
#+end_src

* DONE Initial focus in Occur Buffer :occur:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230503211610-emacs--Isearch-Occur-Advice-Window-Focus
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-05-11 Thu 20:43>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230503211610-emacs--Isearch-Occur-Advice-Window-Focus.jpg
:END:

Just a quick one today!

I am finding =occur= extremely useful, from building an index from my emacs init file to searching through org headers to generally just having my =isearch= all there in a single window.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230503211610-emacs--Isearch-Occur-Advice-Window-Focus.jpg]]

However I would rather the cursor would jump to the =*Occur*= buffer when invoked as it just feels a little more natural, so I added the following:

#+begin_src elisp
(advice-add 'isearch-occur :after
            '(lambda (origin &rest args)
               (isearch-exit)
               (select-window (get-buffer-window "*Occur*"))
               (goto-char (point-min))
               ))
#+end_src

* TODO Aligning Columns In Text Table :noexport:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230503201715-emacs--Aligning-Columns-In-Text-Table
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-05-03>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230503201715-emacs--Aligning-Columns-In-Text-Table.jpg
:END:

#+hugo: more

#+begin_src
(defun rtest ()
  ""
  (interactive)
  (align-regexp
   (region-beginning) (region-end)
   ":\\(\\s-*\\)"
   1 5 nil)
  )

1,2,3
12,13,14
100,101,102

Fred (123) (456-7890
Alice (123)   (456-7890
Mary-Anne (123) (456-7890
Joe (123)  (456-7890

----------------------------------------
-- compiler:    gnat
-- date:  10:10
-- langage:    host
----------------------------------------
#+end_src

* TODO Emacs As Client Server :noexport:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230501110914-emacs--Emacs-As-Client-Server
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-05-01>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230501110914-emacs--Emacs-As-Client-Server.jpg
:END:

Just a reminder on how to set up emacs client server, I have tried this in the past but never really had any success there is usually a conflict somewhere with save.desktop and the fonts / frames e.t.c

#+hugo: more

To run the server :

#+begin_src bash
emacs --daemon
emacs --bg-daemon
emacs --fg-daemon
#+end_src

then connect using

#+begin_src bash
/usr/bin/emacsclient --alternate-editor= --create-frame %F
emacsclient -a -c
#+end_src

On first running up from the command line to connect to the server the font was incredibly small this was due to me using:

=(set-frame-font "Hack Nerd Font Mono 13" nil t)=

so I changed it to:

=(add-to-list 'default-frame-alist '(font . "Hack Nerd Font Mono 13"))=

not sure why this is the case but it works!

I can put =emacs --daemon= in my startup.sh file where all my general startup programs go but I wanted to created a systemd service.

Su as root using =find-file= /sudo:: navigate to /etc/systemd/system and create an emacs.service copying an example from /usr/share/emacs/28.2/etc then run:

#+begin_src bash
sudo systemctl enable emacs.service
sudo systemctl start emacs.service
#+end_src

and the desktop files can be used in this folder too if the operating system hasn't created them correctly in linux, the key is that the =emacs.desktop= has some form of =emacsclient= command.

Couldn't really get it to work with a root emacs.service but there is a user one that comes with emacs as in the article: https://emacsredux.com/blog/2020/07/16/running-emacs-with-systemd/

#+begin_quote
I’ve noticed, however, that Emacs 26.1 bundles a systemd unit, so it’s now trivial to control your Emacs daemon with systemd. It all boils down to running this command:

$ systemctl --user enable --now emacs
Run this command with your regular user (or whatever user account you want to be running Emacs). Don’t run it as root, though! You’ll get a message that the unit file was copied to /usr/lib/systemd/user/emacs.service and you can examine it if you’re curious:

[Unit]
Description=Emacs text editor
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=simple
ExecStart=/usr/bin/emacs --fg-daemon
ExecStop=/usr/bin/emacsclient --eval "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure

[Install]
WantedBy=default.target
Pretty straightforward.

At this point your Emacs daemon is up and you can connect to it using both terminal clients (emacsclient -t) and GUI clients (emacsclient -c). You might also want to create some desktop icon that runs emacsclient -c, instead of emacs. You
#+end_quote

---

To disable the systemd service for Emacs that was enabled by running the command "systemctl --user enable --now emacs", you can run the following command:

systemctl --user disable emacs

This will disable the service from starting automatically at boot time.

You can also stop the service immediately by running the command:

systemctl --user stop emacs

This will stop the service immediately without disabling it from starting at boot time.

* DONE Cursor Blinking Rate :emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230406200632-emacs--Cursor-Blinking-Rate
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-04-28 13:00>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230406200632-emacs--Cursor-Blinking-Rate.jpg
:END:

Sometimes I can find a blinking cursor distracting and somewhat expectant!, so currently I am favouring a solid non blinking cursor while still being able to easily locate my cursor using =hl-line-mode=

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230406200632-emacs--Cursor-Blinking-Rate.jpg]]

I have tried *beacon* and *pulsar* in the past but have found that a simple line highlight nicely serves my purpose.

This however led to a weird issue at work with my emacs setup and although I am not quite sure why it is happening (although I have my theories) I have found a workaround.

As at home I am always tinkering with my emacs init file and I think at some point I decided to turn off cursor blinking.  This coincided with a new virtual machine setup and hence a new emacs install.  At that point I started to notice that sometimes the emacs window wouldn't refresh until I either gave it some keyboard input or strangely I just wiggled my mouse :)

I could reproduce this issue by restarting emacs from a clean start (cleaning out buffers and the desktop file) and switching immediately to a permanent register pointing to a file.  Also I would notice that sometimes when I =dired-jump='d I would have to tap a key to get the emacs window to refresh.

After a period of trial and error I narrowed the culprit down to :

#+begin_src elisp
(blink-cursor-mode -1)
#+end_src

When I turned on a blinking cursor there would be no such emacs refreshing issue.

I came up with a theory that in a setup involving VM Machines/X11/linux window manager/compositor/emacs/host graphics driver/and so on, there may be a graphical optimization that requires a specific event to occur for an emacs window to refresh. It's possible that the reason everything works smoothly with a blinking cursor is because the cursor is constantly disappearing and reappearing, which triggers a refresh event.

So.... the question is how do I preserve a non blinking cursor and still get an emacs window to consistently refresh?, well I dug into the blinking cursor options and set the following:

#+begin_src elisp
(blink-cursor-mode 1)
(setq blink-cursor-interval 0.001)
(setq blink-cursor-blinks 1)
#+end_src

A single initial blink of the cursor would trigger a reliable display refresh but would be imperceptible to the human eye thus providing a perceived non blinking cursor!

Oh and a final thing, has anyone noticed that by default an emacs cursor blinks but 10 times and then stops?, I've got to say it was only when I was digging around the blink-cursor variables and actively scrutinising the cursor blink behaviour that I noticed.  I had assumed that it just kept blinking forever!

* DONE Imenu Indexing My emacs Init File :emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230414111409-emacs--indexing-emacs-init
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-04-14 14:34>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230414111409-emacs--indexing-emacs-init.jpg
:END:

#+hugo: more

After implementing my simple occur indexing in my last post :
#+begin_export md
[Indexing My Emacs Init File]({{< ref
"/emacs/20230308203648-emacs--Indexing-My-Emacs-Init-File.md" >}})
#+end_export

A suggestion was made to put this into an =imenu=.

I thought that was rather a good idea and it would also give me the opportunity to explore =imenu=

I came up with the following to add to the emacs init file :

#+begin_src elisp
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (setq imenu-sort-function 'imenu--sort-by-name)
            (setq imenu-generic-expression
                  '(
                    (nil "^;;[[:space:]]+-> \\(.*\\)$" 1)
                    ("defun" "^.*([[:space:]]*defun[[:space:]]+\\([[:word:]-/]+\\)" 1)
                    ("use-package" "^.*([[:space:]]*use-package[[:space:]]+\\([[:word:]-]+\\)" 1)
                    )
                  )
            (imenu-add-menubar-index)))
#+end_src

which produces the following:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230414111409-emacs--indexing-emacs-init.jpg]]

I thought for good measure I would also add in some menus for =defuns= and =use-package= declarations (just for fun!) with my main defined sections forming the top level due to the MENU-TITLE being set to nil in the =imenu-generic-expression= variable.

This implementation has the added benefit of integrating nicely into the local completion system.  For example I use =vertico= and running =imenu= calls up the defined sections in the mini-buffer and as an extra benefit running =consult-imenu= does its consult thing to quickly step through the sections or of course to complete.  As I have defined section names for =defun= and =use-package= the completion search can search on these too to quickly narrow things down.

I had never looked into =imenu= before and it was quite an interesting learning experience and in fact I went all the way to defining my own =imenu-create-index-function= where I can create my own alist index in any way I want to, that was until I found a more simple method!

* DONE Indexing My Emacs Init File :emacs:elisp:ada:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230308203648-emacs--Indexing-My-Emacs-Init-File
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-04-12 Wed 14:36>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230308203648-emacs--Indexing-My-Emacs-Init-File.jpg
:END:

Since I keep all my emacs configuration in a single =.emacs= file and in a hyper organised manner it means I have my init file split into different sections, for example :

#+hugo: more

- platform
- packages
- mail
- calendar
- completion
- save-desktop
- keys
- modes
- setqs

---

with each section delimited by a comment of the form:
#+begin_src elisp
;;
;; -> platform`
;;
#+end_src

Now I am using =occur= more often, then why not write a function to produce a nice little Occur buffer containing an index of my init file sections, as thus:

#+begin_src elisp
(defun my/index ()
  (interactive)
  (beginning-of-buffer)
  (occur ";;[[:space:]]->"))
#+end_src

I avoided the self index reference by explicitly using the *[:space:]* variant for the occur regex.

and this gives me the following:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/20230308203648-emacs--Indexing-My-Emacs-Init-File.jpg]]

The selection of each item takes me to the relevant section of my emacs configuration and as I have *f8* bound to =next-error= I can easily step through each section if I want to.

* DONE Sorting Org Tags using Org Mode! :org:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230406210733-emacs--More-Sorting-Tags-Options
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-04-07 Fri 16:04>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230406210733-emacs--More-Sorting-Tags-Options.jpg
:END:

Well as always a little more time with emacs a little feedback and then finding more about org I have now figured out (I think) how I can better sort tags in an org file.  In my previous post:

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230406210733-emacs--More-Sorting-Tags-Options.jpg]]

#+begin_export md
[Sorting Org Tags]({{< ref
"/emacs/20230310120116-emacs--Sorting-Org-Tags.md" >}})
#+end_export
I made the following comment:

#+begin_quote
I had assumed that org-mode came with the built-in ability to sort tags but I couldn't find any evidence of this
#+end_quote

Well as it turns out there is evidence of this! and it takes the form of:

#+begin_src elisp
(setq org-tags-sort-function 'org-string-collate-greaterp)
#+end_src

This is tied into =C-c C-q (org-set-tags-command)= of which I hadn't yet discovered but now I think I shall bring into my muscle memory. I had previously just been manually adding tags!

Further interwebs hunting and I came across the following function:

#+begin_src elisp
(defun my/org-sort-tags ()
  "On a heading sort the tags."
  (interactive)
  (when (org-at-heading-p)
    (org-set-tags (sort (org-get-tags) #'string<))))
#+end_src

which more concisely accomplishes my original intention and will work when the cursor is anywhere on an org heading and therefore a macro or presumably an org-* type iterator would neatly take care of the whole file for me.

Although I went down a little rabbit hole I found a few things down there, elisp improvement, digging more around org-mode and bewilderingly wondering where my journey will end.  Of course with emacs it never will, my little head will just peep out at the daylight sun every now and then but my little noggin will be wiser and more proficient 😃

* DONE Sorting Org Tags :org:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230310120116-emacs--Sorting-Org-Tags
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-04-01 Sat 12:55>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230310120116-emacs--Sorting-Org-Tags.jpg
:END:

I use a package called *org-rainbow-tags* which adds random colours to org tags to provide a consistent colour between identical tags.  This helps to identify common tags throughout the file but has the side effect of emphasising the lack of my coherent tag ordering.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230310120116-emacs--Sorting-Org-Tags.jpg]]

I would like to order the tags consistently, just for my own peace of mind! 😀

I had assumed tkhat org-mode came with the built-in ability to sort tags but I couldn't find any evidence of this so I decided to create a method using my own function.  My preferred default method is in descending order as I commonly use a year tag which I would always like to be on the right hand side.

Just select the region containing the tags and run my function passing in the universal argument if you fancy ordering the other way!

#+begin_src elisp
(defun my/sort-org-tags-region (beg end &optional reversed)
  "In active region sort tags alphabetically in descending order.
  With prefix argument REVERSE order."
  (interactive "r\nP")
  (unless (region-active-p) (user-error "No active region to sort!"))
  (let* ((str (s-trim (buffer-substring-no-properties beg end)))
         (wrd (split-string str ":" t " "))
         (new
          (concat
           ":"
           (s-join ":" (sort wrd (if reversed #'string< #'string>)))
           ":")
          )
         )
    (save-excursion
      (goto-char beg)
      (delete-region beg end)
      (insert new)
      )
    )
  )
#+end_src

j

* DONE Trimming ArtRage Playback Scripts using Emacs :emacs:artrage:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230309201924-emacs--Trimming-ArtRage-Playback-Scripts
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-03-21 Tue 14:30>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230309201924-emacs--Trimming-ArtRage-Playback-Scripts.jpg
:END:

Emacs isn't my only obsession, I like to create digital art and for that I use ArtRage.  The interesting thing about ArtRage is that each brush stroke or editing action can be recorded in a text file or script for later playback.  I use this facility for creating time-lapses.

#+hugo: more

The ArtRage manual describes the following:

#+begin_quote
*Script Files*\\
ArtRage scripts are simple Unicode UTF16 text files which can be edited using Notepad, Notepad+++, TextEdit, or any similar program
#+end_quote

"similar program"?! now let me think..... what do I have available :)

For a nice clean time-lapse ArtRage now has the ability to filter out the rest of the UI elements and leave the canvas fixed in the center of the screen.  For the most part this works very smoothly however sometimes the recording hasn't quite registered some strokes properly or some reference files have moved, in this case I may get an error such as:

#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/Screenshot_20230309_203530.jpg]]

At which point it is time to break out emacs and delve into the recorded text script file.  For a typical piece of art the script can get quite large, for my last portrait it was 174M with 605012 lines.  How does emacs handle this?, well it had no problem and opened it in a split second!

I think to resolve this current issue around =ReferenceImageXForm= I am just going to remove all occurrences as for a time-lapse playback I don't usually want to show the references anyway.

First of all lets =isearch= for ReferenceImageXForm, now that I have =isearch-lazy-count= turned on it gives me 1/36 in the minibuffer.  Lets just step through each one and remove the whole line.

Also I think I would like to remove the initial reference image load which starts off as:

#+begin_src
Wait: 33.293s EvType: Command CommandID:
 LoadReferenceImage	Idx: 0	Reference Image: {
#+end_src

and then has many lines of image data and then finishes with an enclosing brace.  Of course this is easy to remove in emacs by leveraging:

#+begin_src
(kill-sexp &optional ARG INTERACTIVE)
Kill the sexp (balanced expression) following point.
#+end_src

now a quick save and playback and the timelapse runs perfectly.

I remember a while ago when I was not quite aware of the capabilities of emacs and I was more Windows bound I had to look for specific text editors that could handle large files and then save them in the requisite Unicode UTF16 format.  They were slow, it was a hassle, I couldn't define any macros e.t.c, but emacs just does this out of the box!

Maybe I should petition the ArtRage team to reference emacs in their documentation!

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230309201924-emacs--Trimming-ArtRage-Playback-Scripts.jpg]]

* DONE Editing org files on an Android device - Part 1 :emacs:android:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230312193655-emacs--Editing-files-on-a-phone-and-tablet
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-03-12 21:08>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230312193655-emacs--Editing-files-on-a-phone-and-tablet-pt1.jpg
:END:

Now that there is a build for emacs on Android I thought I would try and develop an emacs workflow between my Galaxy Note 8 / Galaxy Tab S7+ and my linux laptop.

#+hugo: more

At the moment I am using Markor on my phone and this serves my needs adequately but of course I am missing that org file support.

My current process involves *syncthing* to push my org files around my laptop / phone and tablet.  I also push other things that are regularly backed up and this does include my *.emacs* config file.

So the relevant files are already present on my device the next thing to do is to install emacs from F-Droid and grant emacs file permissions.

My phone is running Android version 9 and my tablet version 13 so the method to get permissions set up for Emacs was slightly different in each case.

On my phone from the settings I selected Apps -> top right menu (App permissions) -> Storage -> Emacs to On

On my tablet from the settings I selected Apps -> top right menu (Special access) -> All files access -> Emacs to On

Next up is to set up my configuration file, in this case I am going to create a symbolic link using =dired=.  First of course is to run up emacs and then navigate to my syncthing'd =.emacs= file which in my case is in the following location:

#+begin_src bash
/storage/emulated/0/DCIM/Linux
#+end_src

The android emacs menu bar is quite responsive and the menu appears in a nice large touch friendly font so I can just *File -> Open Directory...* at which point an on screen keyboard pops up and I can input the path.

Note : Something I discovered early on was that because I have KDE Connect installed across all my devices and Clipboard sync is turned on it means that the clipboard is shared between devices.  This means that anything that is copied from within emacs on my laptop appears on my phone or tablet, so I could just type out the path on my laptop, copy it to the kill ring and it appears on the Samsung Keyboard clipboard field ready to paste into emacs!

Now the path has been input =dired= shows the directory containing all my files including my =.emacs= file.  Now I select the line containing the file *(yes, using my finger!!)* then from the top menu : *Operate -> Simlink to...* and input the following:

#+begin_src bash
/data/data/org.gnu.emacs/files/.emacs
#+end_src

Now restart emacs or maybe *Emacs-Lisp -> Evaluate Buffer*

When I first attempted this my default =.emacs= gave a prodigious number of errors and I realised that for the moment android emacs doesn't have the ability to download packages from melpa or elpa. Not too much of a problem for me though as my default config is tending towards vanilla anyway so for the moment I decided to create a purely android version of my .emacs config by stripping out everything I didn't think I needed with an eye on creating a generic version across not only android but windows too.  Currently I have a few =(when (string-equal system-type "windows-nt")= and for android I just need something similar but with *android* as the defining string.

Technically just setting the storage permissions for emacs on my device would have been enough to open an org file and edit it, but now I have a symbolic link to my .emacs config and it is synched to all my devices it means I now have the ability to modify it anywhere and although I currently have an android specific version it won't be too long before I have a single generic config for all my devices / operating systems.

The next step will be to find an on-screen keyboard to fit a good emacs editing workflow - a sneak peek below of Keyboard Designer but that will be for part 2!

#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/20230312193655-emacs--Editing-files-on-a-phone-and-tablet-pt1.jpg]]

* DONE Replacing deadgrep with consult-ripgrep :ripgrep:grep:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230225134207-emacs--Trying-out-consult-ripgrep-to-replace-deadgrep
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-03-08 Wed 21:08>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230225134207-emacs--Trying-out-consult-ripgrep-to-replace-deadgrep.jpg
:END:

I have been evolving my way through many differing ways of grepping recently from standard built-in greps to a few ripgrep front ends until I finally settled on =deadgrep=

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230225134207-emacs--Trying-out-consult-ripgrep-to-replace-deadgrep.jpg]]

I am currently an *ivy* user but as everyone seems to be talking about
*vertico* and the associated completion stack I thought I would give it a
try and therefore =consult-ripgrep= to see it can improve on my =deadgrep=
setup.

Previously I have created a couple of wrappers around deadgrep:

#+begin_src elisp
(defun my/deadgrep ()
  (interactive)
  (if (equal major-mode 'dired-mode)
      (setq search-term
            (read-from-minibuffer "Search : "))
    (setq search-term
          (read-from-minibuffer "Search : " (thing-at-point 'symbol)))
    )
  (deadgrep search-term home-dir)
  )

(defun my/grep ()
  (interactive)
  (if (equal major-mode 'dired-mode)
      (setq search-term
            (read-from-minibuffer "Search : "))
    (setq search-term
          (read-from-minibuffer "Search : " (thing-at-point 'symbol)))
    )
  (deadgrep search-term)
  )
#+end_src

As a universal argument was passed to deadgrep which had a side effect of initially pausing the search, this meant I split my grepping between =S-f12= and =M-f12= one for a project grep and one for a local directory grep.

As part of trying out =consult-ripgrep= I think I would like to rewrite the functions above and I would want a quick and simple method to revert back to using deadgrep.

I settled on the following:

#+begin_src elisp
(defun my/project-root ()
  (interactive)
  "Guess the project root of the given FILE-PATH."
  (let ((root default-directory)
        (project (project-current)))
    (when project
      (cond ((fboundp 'project-root)
             (setq root (project-root project)))))))

(defun my/grep (arg)
  (interactive "p")
  (if (equal major-mode 'dired-mode)
      (setq search-term
            (read-from-minibuffer "Search : "))
    (setq search-term
          (read-from-minibuffer "Search : " (thing-at-point 'symbol)))
    )
  (if (> arg 1) ;; if C-u has been activated
      (consult-ripgrep default-directory search-term)
    (consult-ripgrep (my/project-root) search-term)))
;;   (progn
;;     (setq current-prefix-arg nil)
;;     (deadgrep search-term default-directory)
;;     )
;; (deadgrep search-term (my/project-root))))
#+end_src

To switch between deadgrep / consult-ripgrep I just need to uncomment / comment in and out the relevant bits and then re-evaluate.

As you can see I created a local function to find the project root directory if one exists and to then pass the result to the deadgrep / consult-ripgrep command meaning that they will both perform identically from a search directory perspective.

Note how I overcame the pass-through of the universal argument to deadgrep by just resetting the =current-prefix-arg= after I had already used the universal argument logic within the function.

I can now free up my original =M-f12= binding which searched from the local =default-directory= as I can =C-u= to the =S-f12= binding.

I'm not too sure about consult-ripgrep yet but the setup above gives me the following benefits:

1. A common local find project root function that might become useful for future functions
2. Flexibility with the universal argument meaning I could pass in multiple
   universal arguments or maybe even a numeric argument for enhanced
   functionality
3. Able to quickly switch between ripgrep implementations by commenting / un-commenting
4. Frees up a keybinding

* DONE Using Macros to Help Code Debugging :macros:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230224195709-emacs--Quick-Debug-Coding-Insert
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-03-02 Thu 20:08>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230224195709-emacs--Quick-Debug-Coding-Insert.jpg
:END:

Often I find myself requiring the most rudimentary of methods of debugging and that is to push text to standard output from within a running executable to indicate the logical structure of a program.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230224195709-emacs--Quick-Debug-Coding-Insert.jpg]]

This situation may come about if I can't debug a dll or generally actually stopping a program to debug creates an *"observer effect"*

Sometimes the logical structure can be somewhat complex consisting of a plethora of =if= statements and nested =for= loops, e.t.c and may take me a tedious while to apply the necessary debug statements.  But emacs macros can speed up this process drastically!

I often code in Ada and the text to =stdout= mechanism is generally something like:

=ada.text_io.put_line("Yes Ada is a language!");=

My macro starts with a simple search for blank lines using =C-M-s= =(isearch-forward-regexp)= for the regex *=^$=*

Next I would like to have a unique string for each debug statement and this can be accomplished by using =(kmacro-insert-counter)= via =C-x C-k C-i=

For example to debug the following dummy code:

#+begin_src
with Ada.Text_Io;

procedure Ada_Main is
   Ftt : Boolean := True;
   Count : Integer := 0;

   procedure Call_Routine is
   begin
      null;
   end Call_Routine;

   procedure Call_Another_Routine is
   begin
      null;
   end Call_Another_Routine;

begin
   Ada.Text_Io.Put_Line("Program Starting");

   if Ftt then
      Call_Routine;
   else
      Call_Another_Routine;
   end if;

   while Count < 3 loop

      Call_Routine;

      Count := Count + 1;

   end loop;

   Ada.Text_Io.Put_Line("Program Finished");

end Ada_Main;
#+end_src

which just outputs the following:

#+begin_src
Program Starting
Program Finished
#+end_src

To debugify this simple program, I can record a macro and perform the following steps:

1. perform *(isearch-forward-regexp)* for =^$=
2. type in my debug output statement - in this case an Ada one
3. insert an incremented counter
4. complete the debug statement.

On a macro repeat I will now have a unique text_io for each blank line giving me an indication of the code path.  I can kick off my macro from any point in the program and stop at any time hence below:

#+begin_src
with Ada.Text_Io;

procedure Ada_Main is
   Ftt : Boolean := True;
   Count : Integer := 0;

   procedure Call_Routine is
   begin
      null;
   end Call_Routine;

   procedure Call_Another_Routine is
   begin
      null;
   end Call_Another_Routine;

begin
   Ada.Text_Io.Put_Line("Program Starting");
Ada.Text_Io.Put_Line("##1");
   if Ftt then
      Call_Routine;
   else
      Call_Another_Routine;
   end if;
Ada.Text_Io.Put_Line("##2");
   while Count < 3 loop
Ada.Text_Io.Put_Line("##3");
      Call_Routine;
Ada.Text_Io.Put_Line("##4");
      Count := Count + 1;
Ada.Text_Io.Put_Line("##5");
   end loop;
Ada.Text_Io.Put_Line("##6");
   Ada.Text_Io.Put_Line("Program Finished");
Ada.Text_Io.Put_Line("##7");
end Ada_Main;
#+end_src

and running now gives me:

#+begin_src
Program Starting
##1
##2
##3
##4
##5
##3
##4
##5
##3
##4
##5
##6
Program Finished
##7
#+end_src

Which may help me to figure out what is going wrong with my program (although in this case nothing was really going wrong!)

For large complicated source code to have such a fast mechanism such as this can be very useful and it is amazing at just how quickly a program fault can be identified by using this simple and almost primordial method.

This of course could be improved in many different ways, for example to not rely on blank lines and possibly force insert debug statements based on semi colons or maybe to decipher the syntactical structure (tree sitter?)  and insert the debug statements in a more coherent and comprehensive manner.  But this is only a rudimentary quick method to roughly locate a programs issues and it is good enough for me.

* DONE Moving Away From Deft :emacs:dired:deft:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230204140603-emacs--Moving-Away-From-Deft
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-02-22 20:33>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/2023-02-04_14-32_t.jpg
:END:

As the title says, it is with a heavy heart that I have decided to move away from *deft*.  There are a few reasons for this:

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230204140603-emacs--Moving-Away-From-Deft/2023-02-04_14-32.jpg]]

- All files I am interested in quickly locating and editing are now orgified (turned into org files)
- All these files are located in a single directory
- All these files have a sensible naming convention indicating the contents
- I am now much more familiar with dired
- I didn't ever use the deft facility for creating new files, I prefer to
  use dired
- I didn't ever need to incrementally filter / search as I can use emacs / dired for this
- Deft took a couple of seconds to initially load
- My deft configuration was becoming a little bloated and I wanted to use
  vanilla emacs where I could; see below for my former deft configuration:

#+begin_src elisp
(use-package deft
  :bind ("C-c d" . deft)
  :commands (deft)
  :config (setq deft-text-mode 'org-mode
                deft-use-filename-as-title nil
                deft-auto-save-interval 0
                deft-use-filter-string-for-filename t
                deft-extensions '("org")
                deft-default-extension "org"
                deft-time-format "%Y-%m-%d %H:%M:%S"
                deft-new-file-format "%Y-%m-%dT%H%M%S"
                deft-strip-summary-regexp "\\([\n]\\|^#\\+.+:.*$\\)"
                deft-recursive t))
#+end_src

It is time to move onto something a little more simple, namely:

#+begin_src elisp
(setq deft-directory (concat home-dir "/DCIM/content"))
(bind-key* (kbd "C-c d") (lambda()(interactive)(dired deft-directory)))
#+end_src

and yes I decided to keep the venerable name of deft in memoriam.

I think this is an example of over time learning that emacs has a lot of what you want already built in and with org mode it gently nudges you to organise files in a more coherent manner leading to a more simple agnostic digital way of life.

* DONE Commenting Un-commenting :emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230215204855-emacs--Commenting-Uncommenting
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-02-15 20:57>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230215204855-emacs--Commenting-Uncommenting.jpg
:END:

After watching an interesting video by [[https://www.youtube.com/watch?v=vTdbb7tsvQc][EmacsElements]] regarding commenting and un-commenting I have to say that I wholeheartedly agree.  I really don't like the way =comment-dwim= works and made me think back to one of the first elisp functions I commandeered from the interwebs :

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230215204855-emacs--Commenting-Uncommenting.jpg]]

#+begin_src elisp
(defun my/comment-or-uncomment ()
  "Comments or uncomments the current line or region."
  (interactive)
  (if (region-active-p)
      (comment-or-uncomment-region
       (region-beginning)(region-end))
    (comment-or-uncomment-region
     (line-beginning-position)(line-end-position))))
#+end_src

and it is a command that I constantly use and had forgotten that it isn't part of the emacs default functionality from a =M-;=

* DONE Simple Flexible Scrolling :scrolling:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230205185836-emacs--Simple-Flexible-Scrolling
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-02-08 Wed 21:21>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230205185836-emacs--Simple-Flexible-Scrolling.jpg
:END:

I have written before about smooth scrolling using *good-scroll* and how I managed to find a semi satisfactory way of centering my cursor after a single scroll which meant I would then have a minimal amount of subsequent line movement to get to the line I want.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230205185836-emacs--Simple-Flexible-Scrolling.jpg]]

However, I have since returned to a simple concept, more of a basic =scroll-[up/down]-command= which in its bare form scrolls a whole page.  Now for me this is too much and I still want to have the ability to control how many lines I scroll which will still indicate to my brain that text is scrolling so I can still take in the overall form of a file.

I initially returned to my simple scrolling functions:

#+begin_src elisp
(defun scroll-up-some ()
  (interactive)
  (scroll-up-command (window-some-height)))

(defun scroll-down-some ()
  (interactive)
  (scroll-down-command (window-some-height)))

(defun window-some-height ()
  (max 1 / (1- (window-height(selected-window))) 4))
#+end_src

which leveraged the number of lines as an argument to the =scroll-[up/down]-command=

I would however really like to simplify and still allow some centering, I therefore created the following bindings:

#+begin_src elisp
(bind-key* (kbd "M-j")
           (lambda()
             (interactive)
             (next-line (/ (window-height) 12))
             (recenter)))

(bind-key* (kbd "M-k")
           (lambda()
             (interactive)
             (previous-line (/ (window-height) 12))
             (recenter)))
#+end_src

The only issue I have with this implementation is that when I move to the end of a file and scroll upwards the first scroll =recenter= is a bit jarring as moving to the =end-of-buffer= is not typically centred and has any number of blank "lines" below it.  Moving to =beginning-of-buffer= has no such issue as the cursor moves right to the top and subsequent scroll down recenters do not activate any scrolling until the cursor is past the center point of the window.

This issue however is easily fixed by:

#+begin_src elisp
(bind-key* (kbd "M->")
           (lambda()(interactive)(end-of-buffer)(recenter)))
#+end_src

which forces an initial =recenter= whenever an =end-of-buffer= keybinding is activated, meaning that the first scroll upwards is now seamless!

* DONE How to Display Google Calendar :emacs:elisp:calendar:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230204115142-emacs--Displaying-A-Calendar
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-02-04 13:20>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/0230204115142-emacs--Displaying-A-Calendar/2023-02-03_12-59.jpg
:END:

Emacs is subsuming me!  I have managed to get email up and running using *mu4e* and rss using *elfeed* and image viewing with *image-dired*

#+hugo: more

Next up is some form of calendar integration!

Although I use Google Calendar I don't rely on any google apps directly; an android app called *Simple Calendar* is adequate for my needs and enables the thing I cherish most of all (except emacs of course!)  and that is the ability to produce an offline copy.  It can export to an =ics= file, and I have developed a habit of exporting to an offline file every time I update my calendar.  This means that I have some exported calendar files lying around, including of course the most recent one.

Initially I attempted to use *org-gcal* which potentially enables a two way communication with Google Calendar through their API, but I got lost in the setup and of course this is Google, at some stage it is likely they will either change their API / remove it / or charge for it.

Anyway, do I really need to modify my calendar from within emacs?, I am quite comfortable using *Simple Calendar* on my phone and if I really need to add calendar entries from my laptop then I always have *Thunderbird* as a backup.

So I may just be in a very fortunate position regarding an adequate level of emacs calendar integration :
1. I only require read only
2. I have an up-to-date =ics= file available

I created the following function which opens up a nicely formatted calendar using the packages *calfw* and *calfw-cal* (and they didn't require any additional setup).

#+begin_src elisp
(defun my/calendar ()
  (interactive)
  (setq tmp-file (concat home-dir "/DCIM/Backup/tmp.org"))
  (delete-file tmp-file)
  (when (get-buffer (file-name-nondirectory tmp-file))
    (kill-buffer (file-name-nondirectory tmp-file)))
  (setq last-ics
        (car (directory-files
              (concat home-dir "/DCIM/Backup")
              'full "\.ics$" #'file-newer-than-file-p)))
  (icalendar-import-file last-ics tmp-file)
  (cfw:open-diary-calendar)
  (when (get-buffer (file-name-nondirectory last-ics))
    (kill-buffer (file-name-nondirectory last-ics))))
#+end_src

and produces a calendar of the form:
#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/0230204115142-emacs--Displaying-A-Calendar/2023-02-03_12-59.jpg]]

I could import everything directly into my =diary-file= but I decided to be a little more flexible and potentially allow for multiple calendars by setting an =include= directive in my diary file as thus:

#+begin_src
#include "~/DCIM/Backup/tmp.org"
#+end_src

The key to the =my/calendar= function is to pull in the most recent =ics= file and call the built in =icalendar-import-file= to convert / import the =ics= data into my diary file.  The *cfw* packages will then take care of the rest.  The other parts of the function are just tidying up various buffers and files to make things a little cleaner.

One little wrinkle I discovered and didn't necessary solve to a satisfactory level was when I first call up =cfw:open-diary-calendar= the calendar didn't resize correctly to fit the window, a second call however seemed to fix this and with no overhead.

One final addition was the following:

#+begin_src elisp
(add-to-list 'display-buffer-alist
             `(,(rx(or "Calendar"))
               display-buffer-in-direction
               (direction . right)
               (dedicated . t)
               (window . root)
               (window-width . 80)))
#+end_src

Which gives me greater control of where the calendar window is opened

* DONE Using ripgrep within Projects :ripgrep:projects:emacs:deadgrep:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230124195440-emacs--My-Tentative-Steps-to-Working-With-Projects
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-01-24 21:07>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230124195440-emacs--My-Tentative-Steps-to-Working-With-Projects.jpg
:END:

Given my recent forays into the world of grepping in emacs using =deadgrep= (and hence ripgrep) and my use of =find-file-rg= which feeds into my current completion system of *ivy* I think the next step is to try to set up a project and to see if I can gain any advantages in my workflow.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img

[[file:static/emacs/20230124195440-emacs--My-Tentative-Steps-to-Working-With-Projects.jpg]]

I am not yet going to dive head first into =projectile= but dangle a tentative pinky into the deep project pools of the built in project system, namely EDE (Emacs Development Environment).

As I have mentioned before I typically would only be working within a single directory hierarchy, hence my previous =deadgrep= enhancement of using a defined =setq home-dir= variable, but I think it might be an enhancement if I could leverage =deadgreps= use of projects; for example, wandering around the deadgrep code I found the following:

#+begin_src elisp
(defun deadgrep--project-root ()
  "Guess the project root of the given FILE-PATH."
  (let ((root default-directory)
        (project (project-current)))
    (when project
      (cond ((fboundp 'project-root)
             ;; This function was defined in Emacs 28.
             (setq root (project-root project)))
            (t
             ;; Older Emacsen.
             (-when-let (roots (project-roots project))
               (setq root (car roots))))))
    (when root
      (deadgrep--lookup-override root))))
#+end_src

as far as I can tell the default-directory is the current directory of the buffer which can be displayed by =M-x pwd= but it is the (project-current) that I am more interested in.

A quick investigation and it seems I need to turn on *global-ede-mode* and then run *ede-new* in the top level directory of my prospective project.  This results in the creation of a Project.ede file containing some project information allowing the setting up of a collection of source files and instructions on how to build them.  For the moment I'm not too interested in building anything, but more on how to trigger =deadgreps= project logic by enabling this directory hierarchy as a project.

As part of creating this project file it seems *ede-project-directories* has also been added to my init file and an extra menu has appeared on the menu bar called *Development*

Is this all I need?, well lets evaluate the following in the top level folder:

#+begin_src elisp
(project-current)
#+end_src

I seem to get a long list of project information, including the project top level directory.  Moving down the directory hierarchy and reevaluating the same expression gives me the same directory!

So I am assuming that in *my/deadgrep* bespoke wrapper, if I now replace:

#+begin_src elisp
(deadgrep search-term home-dir)
#+end_src

with:

#+begin_src elisp
(deadgrep search-term)
#+end_src

if I create a project in my former *home-dir* directory location then my former functionality will have been preserved but with the added flexibility of being able to define other project locations, and also apparently subdirectories!  this is actually pretty neat :)

Now I have defined a rudimentary project and seems to work well with =deadgrep= will it work well with my other favourite =ripgrep= wrapper, namely =find-file-rg=?  Well there does seem to be some code to accommodate projects too, namely:

#+begin_src elisp
(let* ((dir (if current-prefix-arg
                (find-file-rg--read-dir)
              (or (let ((project (project-current)))
                    (when project
                      (if (fboundp 'project-root)
                          (project-root project)
                        (cdr project))))
#+end_src

and yes, it works!, so anywhere I am within the hierarchy of a project I can call up a list of files fed from *ripgrep --files* into *ivy* and complete as normal.

As a bonus =find-file-rg= allows the passing of a universal argument and a *current-prefix-arg* check enables the navigation to any directory.

In summary then, I can now define a project, I can grep throughout the project from any file / directory within that project and I can pull up a list of files within the project all leveraging the power of *ripgrep* through =deadgrep= and =find-file-rg=!

* DONE More flexible grepping with deadgrep :ripgrep:grep:emacs:elisp:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230120181918-emacs--Better-Grepping-with-Deadgrep
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-01-20>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230120181918-emacs--Better-Grepping-with-Deadgrep.jpg
:END:

I seem to be grepping a lot recently and I think the way I use =deadgrep= can be improved a little.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230120181918-emacs--Better-Grepping-with-Deadgrep.jpg]]

Currently =deadgrep= defaults to a recursive =ripgrep= from the =default-directory= which is generally the current directory of the buffer, but I find that by default I tend to mostly want to grep from a top level directory (yes I know, almost like a project!).

I would like to have a typical *Find All References* type of functionality from my grepping and not to rely on =xref= as I will not necessarily ever know if any =xref= functionality is supported for any file that I am working on and for the moment I am not using any connection to an LSP server.  I would like a simple generic process that can be used across all files and I think =deadgdrep= can help me out with this.

I would like to bind to =S-f12= to grep from the "project" top level with the search set to whatever string is under my cursor; this should enable a quick workflow involving jumping around files within the top level directory structure bouncing back and forth between the =deadgrep= buffer.

I have chosen the binding of =S-f12= for consistency across IDEs as I am often required to use VSCode and Visual Studio for work.

In addition I would like to replace my usual local directory grepping where I use =grep= with =deadgrep= for a more unified approach.

So I created the following two functions:

#+begin_src elisp
(defun my/deadgrep ()
  (interactive)
  (if (equal major-mode 'dired-mode)
      (setq search-term
            (read-from-minibuffer "Search : "))
    (setq search-term
          (read-from-minibuffer "Search : " (thing-at-point 'symbol)))
    )
  (deadgrep search-term home-dir)
  )
#+end_src

#+begin_src elisp
(defun my/grep ()
  (interactive)
  (if (equal major-mode 'dired-mode)
      (setq search-term
            (read-from-minibuffer "Search : "))
    (setq search-term
          (read-from-minibuffer "Search : " (thing-at-point 'symbol)))
    )
  (deadgrep search-term)
  )
#+end_src

home-dir as you might guess is where my top level directory resides.

I came to realise that when I am in a =dired= buffer I don't actually ever want to grep with the string under the cursor (which of course would most likely be a file or directory) but only when I am in a file.

I toyed around with the idea of having a single (interactive "p") function so it would accept a prefix command and then perform the following kind of logic:

#+begin_src elisp
((equal current-prefix-arg nil)   ; no C-u
 (do top level grep))
((equal current-prefix-arg '(4))  ; C-u
 (do local grep))
((equal current-prefix-arg 1)     ; C-u 1
 (do some other grepping))
#+end_src

however this had the unintended consequence of pushing through the prefix command to =deadgrep= and therefore it would not start immediately but wait for user interaction.  I couldn't see a way round this so had to split my grepping into both a =S-f12= and =M-f12= for each function call; not much of a big deal.

As I am just running a single deadgrep instance using:

#+begin_src elisp
(setq deadgrep-max-buffers 1)
#+end_src

I also needed to add the following as I will always want to kill the current process if I am starting a new one.

#+begin_src elisp
(setq kill-buffer-query-functions nil)
#+end_src

* DONE Using org-copy-visible in dired :quick:emacs:dired:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230115202613-emacs--Dired-Copy-Just-Directory-List-To-Kill-Ring
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-01-15>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230115202613-emacs--Dired-Copy-Just-Directory-List-To-Kill-Ring.jpg
:END:

Just a quick one.

#+hugo: more

Often it seems I need a copy of a list of files / directories in plain text without any gubbins such as a path, permissions, date and all those shenanigans, basically =basenaming=; for example:
#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230115202613-emacs--Dired-Copy-Just-Directory-List-To-Kill-Ring.jpg]]

So how can I achieve this in emacs? I would really prefer to use =dired= somehow rather than =shell / ls= (which was my first thought)

Below is my typical dired listing:

#+begin_src
drwxr-xr-x  4 4.0K Jan 15 19:35 Backup
drwxr-xr-x  3 4.0K Jan 14 19:33 Camera
drwxr-xr-x 22 4.0K Jan 15 19:01 content
-rw-r--r--  1   65 Dec 31 16:34 .directory
#+end_src

Rectangle marking first came to mind but the paste seems to have a weird format and strangely inserts the text.

So I came up with the following process:

In =dired=, select *'('* =dired-hide-details-mode= which toggles off all the details and gives:

#+begin_src
Backup
Camera
content
.directory
#+end_src

This looks very promising and surely a simple *M-w* (kill-ring-save) will work?.  It doesn't work. It still copies the full details :(

However if org-copy-visible is used it does the same as in org mode in that it only copies the visible parts of the region.  I had no idea that functions from one mode can be used in another!

* DONE Creating Album Art Thumbnails for EMMS :emms:emacs:bash:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230112122044-emacs--Creating-Album-Art-Thumbnails-for-EMMS
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-01-13 Fri>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230112122044-emacs--Creating-Album-Art-Thumbnails-for-EMMS.jpg
:END:

I have been looking for a music player on Linux for a while now but haven't really settled on one; I have simple requirements:

#+hugo: more
- A view showing album art
- An easy way to play random tracks
- A quick method to skip a track

---

To date I have only been considering players with a graphical front end but it always seems a hassle to, open the program, look for some music, figure out how the shuffle and play work; and then what if I don't like the current track playing?, my laptop isn't really set up to quickly skip the track.

Now I am delving further into the integrated environment of emacs I thought I would see what was on offer.

A little research and I settled on *EMMS*

I will go into a deeper review after I have used it for a few months but mainly for this post I wanted to share a quick bash script I created to allow album art to be shown in EMMS.

By default EMMS looks for a *cover.jpg* file in the current music directory.  My collection is neatly split into directories for each album with album art embedded into each mp3 track.  This has given me the opportunity to write a bash script to automate the creation of these cover.jpg files.

The script is as follows:

#+begin_src bash
#!/bin/bash
DIRS=$(find "$HOME/MyMusicLibrary" -type d -printf '%p;')

export IFS=";"

for dir in $DIRS; do cd "$dir" files=(*) if [[ ${files[0]: -4} == ".mp3" ]]; then echo $dir ffmpeg -hide_banner -loglevel panic -stats -y \ -i "${files[0]}" -an -c:v copy "$dir/cover.jpg" convert -resize 120x120 "$dir/cover.jpg" "$dir/cover.jpg" fi done
#+end_src

Of course change the ="$HOME/MyMusicLibrary"= to your music library location and then in the emacs init file add the following:

#+begin_src elisp
(setq emms-browser-covers 'emms-browser-cache-thumbnail-async)
#+end_src

and this is an example of the result (my music collection is larger than this!):

#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/20230112122044-emacs--Creating-Album-Art-Thumbnails-for-EMMS.jpg]]

* DONE Dired Duplicate Here :emacs:dired:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230110115530-emacs--Dired-Quick-Item-Duplication
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-01-10>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230110115530-emacs--Dired-Quick-Item-Duplication.jpg
:END:

=dired= can do most things for me especially now I have my DWIM image conversion scripts working and =image-dired= configured to my liking.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230110115530-emacs--Dired-Quick-Item-Duplication.jpg]]

However sometimes I do just prefer using a GUI file manager; for example, drag and drop, image file preview e.t.c.

I am currently using the Dolphin file manager on KDE and one context menu service that I have enabled and use often is the *Duplicate Here* function.  It is often that I like to back up a file / directory to a quick temporary directory especially when I am hacking around with the original and on windows it is often that I copy and then paste with Windows automatically applying a =Copy= to the original name.  Dolphin does something similar but applies a =(1)= when it suggests a new name.

Enough rambling!, simply I would like to reproduce this functionality in =dired= but with the improvement of not adding in spaces to the new name and being able to define any unique naming convention I like.

So in =dired= to achieve this, simply:

- open dired
- cursor over the desired item to rename
- =w= (dired-copy-filename-as-kill)
- =C= (dired-do-copy)
- paste from the kill ring (yank)
- modify the filename as desired
- return

pretty simple and uses all standard =dired= functionality and of course can be converted to a macro for a certain reproducible naming conventions and then maybe an attachment to a keybinding.

Note that it might be worth adding the following to your emacs init file so no confirmation will be required when copying directories:

#+begin_src elisp
(setq dired-recursive-copies 'always)
#+end_src

* DONE Merging org files for Hugo static site :org:macros:hugo:emacs:2023:
:PROPERTIES:
:EXPORT_FILE_NAME: 20230109113207-emacs--Tidying-Hugo-org-files-using-emacs
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2023-01-09>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20230109113207-emacs--Tidying-Hugo-org-files-using-emacs.jpg
:END:

I have just started the process of reducing the number of org files I maintain for my web site.  I now have a greater understanding of how *Hugo* handles these files and I think can both simplify and make them more flexible.

#+hugo: more

Hugo is my static site generator of choice and although it supports org files directly I prefer to generate to a markdown file as an intermediate step using a file by file evaluation of =org-hugo-auto-export-mode=.  This means that each org subtree I modify automatically generates an *md* file to a defined folder dictated by =#+hugo_section= in the org header.

For example, I have a few org files that generate my art blog; one for videos, finished art, galleries and now AI.  Each org file has a single header =#+hugo_section= defining the destination export folder.  I think now I would like a bit more flexibility with the ability to push a subtree to a folder of my choosing so any extra sections can more easily be added.  Plus, if I merge I would only have to maintain a single org file (although a larger one!).

To achieve this I will have to add an extra property to the existing org drawer for each subtree using =:EXPORT_HUGO_SECTION:= and then to adapt my =org-capture= templates.

Now of course to add the subtree property emacs can certainly help me out.

I would like to insert typically a drawer property line for each subtree such as:

#+begin_src elisp
:EXPORT_HUGO_SECTION: art--all
#+end_src

However of course things are not quite so simple.  It seems that some subtrees already have such property lines even though the destination folder is ultimately the same as =#+hugo_section= in the header (another good reason to tidy up)

So rather than a simple =isearch= to an ever present subtree anchor point (for example =:EXPORT_FILE_NAME:=) and then the insertion of the new line I will need to take into account those subtrees that already have =:EXPORT_HUGO_SECTION:= and not insert a line.

I considered edit mode in =multi-occur= but as far as I can tell it doesn't work too well when new lines are inserted.

=deadgrep= (ripgrep) also has similar functionality and will also show context around the search point which can be also edited in a similar manner to =multi-occur= but all this is starting to feel too fiddly and I am starting to spend too much time investigating this!

The grep/occur to edit buffer approach can work well in certain situations but this is a little more complex involving a small amount of logic.  At this stage the same thought always occurs to me and I really wish it would occur to me earlier.

#+begin_quote
what about macros?
#+end_quote

The =isearch= technique won't quite work (as explained above), but what about =isearch-regexp=?

As the properties are always in the same order I could just insert the =:EXPORT_HUGO_SECTION:= line if I find the following regex:

#+begin_src elisp
:EXPORT_FILE_NAME:.*
:EXPORT_HUGO_LASTMOD:
#+end_src

/Note that the carriage return is achieved by =C-q C-j=/

Incorporate this into a macro and the cursor will only move to a point that doesn't have a =:EXPORT_HUGO_SECTION:= line and hence I can then insert and then repeat until my org file is suitable amended!

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20230109113207-emacs--Tidying-Hugo-org-files-using-emacs.jpg]]

* DONE Quick Bash Scripts Augmenting Org Files :org:emacs:bash:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: 20221221194247-emacs--Bash-Scripts-Augmenting-Org-Files
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-12-21>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/2022-12-21_20-01_t.jpg
:END:

This post isn't strictly about what can be achieved within the emacs ecosystem but what can be achieved outside it while still binding to the workflow principles of org mode.

#+hugo: more

I have yet to convert to any of the internal shells/terminal emulators within emacs, I have continued to Control-Alt-T (C-M-t) term my way around linux; although this is becoming less frequent due to my greater proficiency with *dired*

As my org journey evolves I have now realised that I have two files I rely on for my quick capturing needs.  When an idea pops into my head I am usually emacs bound anyway so *org-capture* is always there for me.  But what if I am alfresco?, and maybe, just maybe I am in a terminal!  Well I could quickly switch to emacs as it is 99% likely to be already running, but what if it is not?!

I could open emacs and then do my thing but emacs now takes a few seconds to load up and then for me just to close it down again afterwards?!  (as if I would) Isn't there another way?, a better way?  Could I idea push to an org file from the terminal with a quick flick of the fingers, could *bash* help me out here?, so many questions...

Well the answer is that yes, bash can help me out.

For me, any new items using org-capture are always put under the headline, hence using =file+headline= in my capture template.  How will this help?, well using the power of bash and the venerable *sed* command I can search and replace the headline but replace with an extra piece of data, namely a string of my choosing, effectively placing my TODO or note at the top of the org file list!

I thus came up with the following =bash= scripts:

** todo

#+begin_src bash
#!/bin/bash
if [[ ! -z $@ ]]; then sed --in-place 's/* Tasks/* Tasks\n** TODO '"$(echo ${@})"'/g' \ "~/DCIM/content/aa--todo.org" fi
#+end_src

** note

#+begin_src bash
#!/bin/bash
if [[ ! -z $@ ]]; then sed --in-place 's/* Notes/* Notes\n** '"$(echo ${@})"'/g' \ "~/DCIM/content/aa--notes.org" fi
#+end_src

Here is my original todo org file:
#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/20221221194247-emacs--Bash-Scripts-Augmenting-Org-Files/2022-12-21_20-01.jpg]]

On the command line I can now enter:

#+begin_src
todo generate art slideshows
#+end_src

and in a flash my org file would now be
:
#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/20221221194247-emacs--Bash-Scripts-Augmenting-Org-Files/2022-12-21_20-01_1.jpg]]

all nice and ready for the next time I open emacs!, and of course now I can also add notes, or anything else of course.

My aim was for the scripts to be very simple, if you pass in no text / arguments no files will be augmented, generally the idea is just to pass in a single string, maybe multiple lines could be passed using =\n= but that isn't the way I wanted to use them.

* DONE RIP ripgrep-regexp, long live deadgrep! :ripgrep:grep:emacs:deadgrep:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: 20221207210603-emacs--RIP-ripgrep-regexp-Long-Live-DeadGrep
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-12-07>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20221207210603-emacs--RIP-ripgrep-regexp-Long-Live-DeadGrep.jpg
:END:

Well this is quite a turn up for the books, I seem to have already quickly moved on from emacs *ripgrep-regexp*!  to something better and that is a package called *deadgrep*

#+hugo: more
#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20221207210603-emacs--RIP-ripgrep-regexp-Long-Live-DeadGrep.jpg]]

Now why is this?  I hear you all ask, your new grepping workflow seemed perfect, a process of file searching that could last the ages. Well as it turns out that age was more of a collection of weeks.

I started to struggle with the compilation-mode output of *ripgrep-regexp* in that a next-error call would only take me to the requisite file if I entered a directory name.  I just wanted to spam F8/next-error my way through all resulted grepped files so I could get a general sense of which files contained my search as I don't always know what I am looking for.  The constant calling up of the directory to input was seriously disrupting my workflow and after some investigation I was struggling to find a way to resolve this.

The main issue seemed to be *compilation-mode*

*compilation-mode* seems to depend on *compilation-search-path* to locate a file automatically in a buffer.  This I suspect is generally ok when compilation-mode is tied into a build project as this path is built up automatically, for example building Ada files typically will parse a gpr file to construct search directories.  Maybe projectile or project.el could help me resolve this, but as mentioned in previous posts currently a project concept doesn't yet fit into my workflow.

Well I guess I could create a list of search directories and add it to the *compilation-search-path*, something like :

#+begin_src elisp
(setq my-search-directories (append '("-/bin" "-/test") '("-/content" "~/content/hugo")))

(setq compilation-search-path my-search-directories)
#+end_src

but this isn't really very flexible, I would have to keep modifying this search directory list as my disk directory hierarchy evolves.

What I need then is an emacs package that doesn't rely on compilation-mode for its output and will just leverage the ripgrep output to directly locate files.

This is where I found *deadgrep* and in fact the package text immediately applied half a pot of emollient to the skin of my current rash of irritations :

#+begin_quote
Perform text searches with the speed of ripgrep and the comfort of Emacs. This is a bespoke mode that does not rely on compilation-mode, but tries to be a perfect fit for ripgrep.
#+end_quote

The out of the box behavior is to search for an input string entered in the minibuffer for all occurrences from the current directory. The output is a ripgrep output grouping grep finds together file by file.

Some options appear on the top of the output buffer to provide some quick configuration ripgrep options, such as:

#+begin_src
Search term: <search string input> change
Search type: string words regexp
Case: smart sensitive ignore

Directory: <search directory>
Files: all type glob
#+end_src

and all the occurrences of the search string are highlighted.

So the next step (pun intended) is to step through these results and see if they open a window/buffer for each search result.

F8/next-error does the trick!, so a continual F8 opens the relevant grepped file result in a window/buffer and without the need to confirm a directory.

So out of the box deadgrep seems to work perfectly for me, it is lightning fast (well I guess it would be). I can step through the results quickly, it respects my *.ignore* file and as a bonus allows a quick changing of ripgrep configuration options!, what more could an emacs user want?!  (don't answer that!)

* DONE RIP grep, long live ripgrep! :ripgrep:grep:emacs:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: 20221130193223-emacs--RIP-Grep-Long-Live-RipGrep
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-11-30>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20221113093223-emacs--RIP-Grep-Long-Live-RipGrep.jpg
:END:

I have come to the realisation that I can be a little more efficient when it comes to searching for text within files, or as it is known in software engineering circles, *grepping*!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20221113093223-emacs--RIP-Grep-Long-Live-RipGrep.jpg]]

I am often looking for a string within a collection of files and mainly for a *Find All References* type of functionality.  Typically I would want to accept a string (could be regex) and a directory and the search to descend through all sub directories. Of course this could be achieved in many different ways :

1. Open up an external terminal and grep -iR
2. dired grepping using find-grep-dired
3. Built in in grep-find function
4. Is there a project.el way to recursively grep?
5. Projectile grepping?

and probably many more that I don't even know about.

Initially I ran grep from an external terminal, examined the scrolling output and then hopped back into emacs.

Not the greatest workflow.

I guess running a shell or terminal emulator from within emacs may help but I still currently prefer to open an external console to interact with the command line.

At times I have grepped within emacs using the built in *grep* function which worked well but unfortunately didn't allow recursive grepping although often I would only want to search in a local directory anyway.

However the calling of this emacs function opened my eyes a little to the possibilities of emacs integrating with a search output, namely the use of *next-error* to step through the file list.

For me F8 is already bound to *next-error* for debugging purposes and it seems that this can also be used to step through the results from an emacs grep call, meaning that I can quickly step through each file search result and open a new window buffer with the cursor resting on the grepped line.

A quick look at the out of the box experience for *find-grep-dired* was subdirectory recursive but just listed the files it found containing the text and not the context so pretty much a no go for me.

The next thing to experiment with is *grep-find* which seems basically to leverage a find command, typically in the following format:

#+begin_src shell
find . -type f -exec grep -ni <string> /dev/null \{\} +
#+end_src

An F8 takes me to the grepped line as it also seems to running in a grep output mode, so this is pretty good. There are however a couple of downsides:

1. the command is non native emacs
2. filtering

Working in a software version control system means that there can be quite a few directories I don't really want to consider in my search query and generally I am just concerned to grep source code. It would be nice if there was a way to filter out files/directories, which not only would clean up the grep output but also speed up the search.

As we know *find* can be very annoying and fiddly when it comes to filtering and generally involves a syntactical nightmare of prunes, logic and parentheses, plus you can't define all these exclusions in a single file like /rsync/ or /tar/ for example.

Ok, so lets carry on, what is next?, it is projects... Now I am going to cheat a little here, I currently don't use any concept of a project or a collection of related files in emacs, I seem to have no need for this functionality at the moment and to be completely honest I have in the past tried to incorporate a project concept into my workflow but it just doesn't seen to work for me, maybe a later date.

Which leaves the elephant in the room (and the one that I have so far deliberately not mentioned to irk those of you who are currently rage typing with great vigour in the comment section), the large awesome skulking grep monster! and that of course is *ripgrep*

I was reluctant at first as it didn't seem to come pre installed in any of my distros and when I ran it I got a whole slew of lines, why do I need lines of context around the search finds?. I don't like this one bit, but hang on!, its fast, really fast, maybe I should open up the man page and spend a bit of time with it.

A little time playing with *ripgrep* I came to the realisation that this tool can be tailored to just show the single line of a grep search result and more than that it can use an exclusion file!, called *.ignore*

Ok so this tool looks pretty promising, so on to the next step, and of course that is to find an emacs package that can give me an integrated emacs ripgrep experience.  So firing up *list-packages* I settled on a package called (surprisingly), *ripgrep* which is just a simple front end to "rg* (the installed ripgrep executable) and comes with a command "ripgrep-regexp* and leverages compilation-mode to display the results. As the output is compilation mode it means that the F8 next-error binding will just work out the box.

After a little playing around I can start to tailor the *.ignore* filter file to trim down the results and make the already lightning fast *ripgrep* to be extra super duper turbo charged, and the results can be navigated by using F8 which currently sits nicely into my workflow.

Now I have bound *ripgrep-regexp* to F8 in emacs the workflow is much improved and I can now stay in emacs for longer when I want to run a *Find All References* type of functionality

* DONE Expanding Text using abbrev and skeletons :skel:emacs:abbrev:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: 20221123131342-emacs--Expanding Text using abbrev
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-11-23>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20221123131342-emacs--Expanding-Text-using-abbrev.jpg
:END:

My next investigation into trying to improve my emacs workflow is expanding entered text for repetitive tasks.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20221123131342-emacs--Expanding-Text-using-abbrev.jpg]]

I'm not yet sure how useful this will be for me as I typically copy and paste my way through the creation of text files, especially org files.  Maybe org-capture could be a help?

As always I want to try built in options to augment my vanilla emacs setup, so the obvious place to look is abbrev.

This facility can be geared towards fixing common spelling /misteaks/ (ha!, see what I did there!)  or expanding acronyms.  I don't really want to be using that aspect however as I read somewhere that you can link abbrevs to skels, my aim is to type a few unique characters which would autofill a common textual structure, for example PROPERTIES in an org file.

What about yasnippet! I all hear you vehemently proclaim!, but of course this is not built in, so no I shall not be considering this option for now.

I am not even familiar with defining a skeleton (skel), so what on earth am I thinking about jumping in like this for potentially a negligible return, well of course the answer is twofold:

1. it is fun, this is of course emacs we are talking about.
2. in the long run it will improve my productivity.

The usual way I approach absorbing something new is to first read around all the options and then to start simple.  By simple I mean setting up some uncomplicated skeletons and elementary abbrevs to initially test my setup.  Then after a while adjusting to this new way of working to gradually start learning the more complex and subtle aspects of the functionality.

Firstly lets try and set up a simple properties skeleton, namely :

#+begin_src elisp
(define-skeleton org-hugo-properties-skel
  "org properties skeleton."
  "\n"
  ":PROPERTIES:\n"
  ":EXPORT_FILE_NAME:\n"
  ":EXPORT_HUGO_LASTMOD: " (format-time-string "%Y-%m-%d") "\n"
  ":EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail\n"
  ":END:\n")
#+end_src

This is a typical setup for inserting a Hugo article into an org file ready for export, in fact this article is written using this framework.

I can call this by defining keybinding such as :

#+begin_src elisp
(global-set-key (kbd "C-c i p") 'org-hugo-properties-skel)
#+end_src

but I suspect my tiny brain is currently full to capacity of emacs keybindings and the ones that are in my head need a little more time to settle in before I commit to any more.

My overall idea is to define a family of common characters that I can insert for expansion as in this case I am talking about inserting a predefined set of text rather than some emacs function, so why commit to another keybinding?

So lets set up *abbrev* for this task, the first thing to do is to set up an *abbrev_defs* file for my abbreviation definitions in my emacs init file as thus:

#+begin_src elisp
(setq abbrev-file-name (concat home-dir "/content/abbrev_defs"))
(setq-default abbrev-mode t)
#+end_src

In this file I can define an elisp definition, by either linking a sequence of characters to a string or a skel, so I define thus :

#+begin_src elisp
(define-abbrev-table 'global-abbrev-table
  '(
    ("hugprop" "" org-hugo-properties-skel)
    ))
#+end_src

There are commands to insert, edit and perform various different operations on this file but really all I want for now is a simple text file that I edit in emacs to add in any new definitions.

So typing *hugprop* <space> gives me:

#+begin_src elisp
:PROPERTIES:
:EXPORT_FILE_NAME:
:EXPORT_HUGO_LASTMOD: <2022-12-11>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail
:END:
,#+hugo: more
#+end_src

In the *define-abbrev-table* I can also define a mapping to a simple string, for example:

#+begin_src elisp
(define-abbrev-table 'global-abbrev-table
  '(
    ("hugprop" "" org-hugo-properties-skel)
    ("btw" "by the way" nil)
    ))
#+end_src

So now I have figured this out I am ready to go!

After a little while of using this method I was starting to struggle with updating the abbrev_defs and seeing its effects immediately in emacs.  When I update to a new abbrev it means that I pretty much want to use it now!

I couldn't really figure out an easy method of instantly making the newly added abbrev command available (except restarting emacs of course).  There will be a way but it wasn't quickly apparent to me and I suspect it was related to the fact that I am not adding to the abbrev_defs using an emacs function.

Before my investigations consumed too much time however I thought I would try something!.

I am not a great fan of configuration files cluttering up my system and certainly with emacs configuration I really am aiming with my vanilla-ish emacs setup to keep everything in one init file and as concise as possible.  So why can't I move the *define-abbrev-table* straight into my *.emacs* file?  and just reevaluate an updated abbrev table?

Well the answer is that I can!

Problem solved.  So if I feel the need to add more skeletons they can now be defined next to the abbreviation table and I can update immediately with a reevaluation in my emacs init file.

Next on my expanding text journey I think might take a look at *dabbrev* and *hippie-expand*

* DONE Revisiting Window Cut / Copy Files with DWIM :emacs:dwim:dired:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: 20221116103757-emacs--some-dwim-target-stuff
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-11-16>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20221116103757-emacs--some-dwim-target-stuff.jpg
:END:

I previously wrote about wanting the ability in emacs to copy and paste files from one window to another just like a linux GUI file manager and after a little hunting around and experimentation I settled on putting together some elisp:

#+hugo: more

#+begin_export md
[Cut / Copy Files from Window to Window using Dired Buffers ]({{< ref
"/emacs/emacs--cut-copy-files-using-dired-buffers__emacs_linux.md" >}})
#+end_export

This worked pretty well for a while although there were a couple of side effects that I hadn't bargained for!

The first was the bypassing of the trash/wastebasket, of course this can be easily remedied by for example installing trash-put as part of my copy but that is starting to add more lines to the elisp and I didn't want to complicate things too much.

Also the single rename functionality in *dired* now didn't work as I essentially remapped the basic functionality of the *R* key to set up a flag for a paste operation and I have come to realise that I use the rename often as I would do in a GUI file explorer.

All I want to do is to copy/move files from one emacs window to another, is that too much to ask?, and no, no it isn't, as there is a much simpler way to achieve this without any of the foibles listed above.

It is:
#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/20221116103757-emacs--some-dwim-target-stuff.jpg]]

~Dired tries to guess a default target directory~

Yay!

So just open a couple of dired windows, mark and operate and the directory dired suggests is the second or destination window dired directory.

Now you may think my previous efforts were wasted but I would disagree with this assumption, I have started to get to grips with elisp, managed to get some elisp working and continued reconsidering my general emacs workflow which as we know will save me time in the long run.

Oh and another thing, the power of writing a blog and trying to articulate what I think I know means that I have read further into the *Help* for *dired-dwim-target*.  This helps to clarify a few things as sometimes I get a little muddled with renaming files and which window/buffer dired is actually being used, here is a Help snippet:

#+begin_src
You can customize it to prefer either the next window with a Dired
buffer, or the most recently used window with a Dired buffer, or to
use any other function.  When the value is a function, it will be
called with no arguments and is expected to return a list of
directories which will be used as defaults (i.e. default target and
"future history") (though, ‘dired-dwim-target-defaults’ might modify
it a bit).
The value t prefers the next windows on the same frame.
#+end_src

This is very much something I shall be looking into at a future date, but for now I have something that works and reduces the size of my *.emacs* file.

* DONE Dired Ordering by Size :emacs:dired:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--dired-ordering-by-size__emacs_linux_dired
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-11-09 Wed>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/emacs--dired-ordering-by-size__emacs_linux_dired/2022-11-23_16-15.jpg
:END:

By default =dired= orders its files in alphanumeric order and when *s* is selected it sorts by date according to :

#+hugo: more

#+begin_src elisp
(dired-sort-toggle-or-edit &optional ARG)
#+end_src

But recently I wanted to list files according to their size, which of course is a very common thing to do especially when you are undertaking a nice spring clean up.

The solution is to modify the =dired-listing-switches= to add in an *S* argument which can be found by passing in the universal argument to *s*, hence : =C-u s=

This presents the user with something like: =-al= at which point you can just tack =S= on the end to show =-alS=

as the ls man page states the following:

#+begin_src
  -S     sort by file size, largest first
#+end_src

and this is what we get:
#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/emacs--dired-ordering-by-size__emacs_linux_dired/2022-11-23_16-15.jpg]]

a nice ordered listing, it is not something I do often and generally the standard dired sort toggle is all I need, but it is nice to know that this is available.

* DONE Tidying up Dired Further :emacs:dired:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--tidying-up-dired_further__emacs_linux_dired
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-11-03 Thu>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/emacs--tidying-up-dired_further__emacs_linux_dired/montage.jpg
:END:

Something is still bugging me with my dired tidy up and I think it is wanting to add the ability to remove dot files.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/emacs--tidying-up-dired_further__emacs_linux_dired/montage.jpg]]

I am currently using the Dolphin file manager on linux and by default I tend not to show the dot files for a cleaner output, generally the only dot file of course I really care about are the emacs ones and I know where they are!

With some hunting around I copy pasted the following and it works perfectly:

#+begin_src elisp
;; hide dotfiles and firefox.tmp
;; Toggle Hidden Files in Emacs dired with C-x M-o
(setq dired-omit-files
      (concat dired-omit-files "\\|^\\..+$\\|firefox.tmp$"))

;; dired omit
(add-hook 'dired-mode-hook (lambda () (dired-omit-mode 1)))
#+end_src

I just now need to muscle memorise the key combination to toggle enable them again, hence:

#+begin_src elisp
C-x M-o

(dired-omit-mode &optional ARG)

Toggle omission of uninteresting files in Dired (Dired-Omit mode).
#+end_src

* DONE Tidying up Dired :emacs:elisp:dired:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--tidying-up-dired__emacs_linux_dired
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-10-23>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/emacs--tidying-up-dired__emacs_linux_dired/2022-11-23_15-23.jpg
:END:

Bit by bit I am getting to grips with =dired= and using this for more operations on my files.

#+hugo: more

The next step is to reduce the listing width so that a listing fits better in a smaller window.

Here is the format of my current listing:
#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/emacs--tidying-up-dired__emacs_linux_dired/2022-11-23_15-32.jpg]]

By default =dired= uses =-al=, which gives a standard long listing.  Unfortunately for my work within emacs this is actually now too long, and also not just in emacs but in my terminal too.

After much hunting around the man page including potentially formatting the output and selecting the listing fields manually, I came to the conclusion that it is mainly the /group/ and /user/ I want to remove for the moment, and fortunately there are a couple of arguments that can do this for me:

#+begin_src
  -g     like -l, but do not list owner
  -G, --no-group
         in a long listing, don't print group names
#+end_src

and while scrolling through the man page I also thought that making the sizes human readable would also be useful, so I have come up with the following in my =.emacs=

#+begin_src elisp
(setq dired-listing-switches "-lGgha")
#+end_src

to give me the following dired output:
#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/emacs--tidying-up-dired__emacs_linux_dired/2022-11-23_15-24.jpg]]

This is much better, but can I now go further?

Well this is emacs, and you betcha!!!!

I know of the command =(= which when in dired mode hides the details and shows just the files.  Wouldn't it be great to have this enabled by default?

A quick =describe-key= gives me the following function:

#+begin_src elisp
(dired-hide-details-mode &optional ARG)
#+end_src

But it is not clear how I can set this by default, there is nothing obvious in =customize-group= for dired, so now to the interwebs...

It looks as though I will need to add to the =dired-mode-hook= and set the details to be hidden when dired mode is activated as follows:

#+begin_src elisp
;; dired hide long listing by default
(defun my-dired-mode-setup ()
  "show less information in dired buffers"
  (dired-hide-details-mode 1))
(add-hook 'dired-mode-hook 'my-dired-mode-setup)
#+end_src

Which now gives me:
#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/emacs--tidying-up-dired__emacs_linux_dired/2022-11-23_15-23.jpg]]

and now if I want show the details I just select =(= so effectively generally showing details rather than hiding them.

This makes more sense for my workflow in emacs, especially now my buffers and windows are getting a little more numerous and I am still really focussing on trying to use a single emacs frame on a laptop.

* DONE Centering the Cursor After a Scroll :scrolling:emacs:elisp:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--centering-cursor-after-scroll__emacs_linux
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-10-11>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/emacs--centering-cursor-after-scroll__emacs_linux.jpg
:END:

Something has been nagging at me for a while now, I seem to spend a lot of time moving the cursor to the next or previous line within a window, spamming =C-n= and =C-p= to get where I want to within a file.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/emacs--centering-cursor-after-scroll__emacs_linux.jpg]]

Why is this?

Well I am scrolling quite often using =C-v= and =M-v= and this has a side effect on the cursor by pushing it to the top or bottom of the window. After I scroll eyeball a file to the desired location I would like my cursor to be vaguely in the center of the window as this is naturally where my eye would have been to identify the file location.

Although I have upgraded the default emacs scrolling to smooth scrolling by using good-scroll I am still having this issue.

One solution is to use =M-r=

#+begin_src elisp
(move-to-window-line-top-bottom &optional ARG)
Position point relative to window.
#+end_src

which moves the cursor first to the middle then the top and then to the bottom of the window. So after a scroll I can just muscle memory =M-r=?  Well I am scrolling quite a lot and the key combination is a little awkward to get to and I want to limit my key presses as much as possible.

Another possible solution is to use *recenter-top-bottom* but this will just add an extra scroll and the cursor position will be in the wrong place anyway.

There may also be packages out there that will help but I am choosing to ignore this option for the moment due to wanting to keep vanilla emacs as much as possible (yes I know I keep banging on about this!)

Lets see what I can do with some elisp.

Before I discovered the wonder of emacs smooth scrolling using good-scroll I was using some elisp to have greater control over the number of lines the basic *scroll-*-command* would scroll, so I had something like this:

#+begin_src elisp
(defun window-some-height () (max 1 / (1- (window-height
                                           (selected-window))) 4)))

(defun scroll-up-some ()
  (interactive)
  (scroll-up-command (window-some-height))
  )

(defun scroll-down-some ()
  (interactive)
  (scroll-down-command (window-some-height))
  )
#+end_src

with the scroll-some functions bound to the standard scroll bindings.

Now good-scroll is enabled it morphed into the following:

#+begin_src elisp
(defun scroll-up-some ()
  (interactive)
  (good-scroll-up)
  )

(defun scroll-down-some ()
  (interactive)
  (good-scroll-down)
  )
#+end_src

as the scroll amount is defined by good-scroll.

My idea here is to modify the scroll functions to add some post scroll cursor centering commands.  Maybe I could use (move-to-window-line-top-bottom)!. Well I tried it, but it just didn't seem to make any difference, I tried some delays, e.t.c.  I suspect that the problem here is that good-scroll has a certain method to achieve its smooth scrolling which is incompatible with the function calls I am initially trying.

Well I decided to keep throwing ideas at the scroll functions to see if I could somehow accidentally force a roughly consistent cursor centering after a scroll and see if something sticks (there may be a better term for this!)

Scroll lock didn't work!, margins didn't work!

Eventually I managed to find a function call that seemed to make a difference to the cursor position after a scroll but didn't seem to position the cursor where I thought it should do given the documentation. The function is:

#+begin_src
  (move-to-window-Line ARG)

  Position point relative to window.
  ARG nil means position point at center of window.
  Else, ARG specifies vertical position within the window;
  zero means top of window, negative means relative to bottom
  of window, -1 meaning the last fully visible display line
  of the window.

  Value is the screen line of the window point moved to, counting
  from the top of the window.
#+end_src

Passing in a 'nil parameter was close but the cursor was too skewed to either end (but at least had a consistent effect on the position of the cursor), however it had little or no effect for half height windows after a horizontal split.

However, passing in different arguments to the *move-to-window-line* function have me differing post scroll cursor locations giving me a licence to that well known tried and tested foolproof method of trial and error!

Of course for a full height window I now had the perfect setup but what about those pesky half height and maybe smaller windows?. There is a valid argument that might say that smaller windows are generally so small that even if the cursor gets pushed to the top or bottom then it won't take too much effort to reposition the cursor. I would say to an extent that is true but for a half height window I would still want to have a centering cursor option after a scroll.

So again elisp to the rescue!, I modified my scroll functions as thus:

#+begin_src elisp
(defun scroll-up-some ()
  (interactive)
  (good-scroll-up)
  (if (< 50 (window-body-height))
      (move-to-window-Line -14)
    (move-to-window-Line -3)
    )
  )
(defun scroll-down-some ()
  (interactive)
  (good-scroll-down)
  (if (<50 (window-body-height))
      (move-to-window-Line 14)
    (move-to-window-Line 8)
    >
#+end_src

The value of 50 was a window line height less than a full window height with a little taken off, but not too much to make it smaller than half height!

Once I have the move-to-window-line values tweaked accordingly for my setup then in theory I have a decent functioning cursor centering solution. Of course there are some foibles, like what happens if I go full-screen with emacs, e.t.c but this seems to work well for me for the moment and I am now moving the cursor around less often within a buffer.

As with all these things and especially emacs I'm sure a better simpler, probably built-in solution will present itself, but that may be for another day...

* DONE Do You Remember? :remember:emacs:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--do-you-remember__emacs_linux
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-10-10>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/emacs--do-you-remember__emacs_linux.jpg
:END:

I am currently keeping all my textual notes in a separate org file called appropriately, *notes.org*.  This is pretty much just a random rambling set of text containing bits and bobs that I don't want to forget.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/emacs--do-you-remember__emacs_linux.jpg]]

If I am mobile and want to jot something down I use an android app called *Markor*, just open up the notes.org as a text file and add something in. *Syncthing* means that this file is present on my laptop when I open it up in emacs.

In emacs, I can open the file, edit it and save it, but it all seems a little too clunky to me. If I want to just register a thought or idea isn't there a better way to accomplish this in emacs?, the answer of course as we all know is... YES!

I will add a note right now that am vaguely aware of org-capture but I get a sense that this might be too much in terms of functionality.  I really just want a quick method to record some keystrokes in whatever form I see fit.

I will again double down on my main requirement for introducing a new workflow in emacs and that is to use vanilla emacs where I can and that would involve either built-in functionality or maybe a little elisp.

Lets list some packages and search through the *built-in* emacs packages... The following seems to present itself! :

#+begin_src
  remember 2.0 built-in a mode for quickly jotting down things to remember
#+end_src

This seems to be nice and simple and the Help file is quite informative. It is based around the concept of quickly recording something to remember and then organise at a later date. As it says:

#+begin_quote
the initial "just remember this" impulse should be as close to simply throwing the data at Emacs as possible.
#+end_quote

and as we know, emacs is very good at handling data.

Out of the box, running =M-x remember= brings up a blank *Remember* window buffer encouraging you to =C-c C-c to remember the data=, You can enter anything you want and with =C-c C-c= the window disappears with your input appended to a text file. Perfect!

By default a *notes* file is stored in .emacs.d/ and I think I might just want to change this to point to my own *notes.org*.  By default the following is a typical entry appended to the bottom of a notes file:

#+begin_src
  ,**Mon Oct 10 15:25:29 2022 (test)

  test
#+end_src

This initial form can be tweaked to conform to whatever notes format text file you have, in my case I added the following to my .emacs:

#+begin_src elisp
'(remember-annotation-functions nil)
'(remember-data-file "/home/usr/content/notes.org")
'(remember-leader-text "**")
'(remember-notes-initial-major-mode 'org-mode)
'(remember-time-format "")
(global-set-key (kbd "C-c n") 'remember)
#+end_src

Now if a thought occurs and I don't trust my aging brain to remember, a quick =C-c n, text input, C-c C-c= flick of the fingers will record that information. The window is transitory and doesn't disrupt my emacs session and the text org file will be updated and then synced to my phone for a later potential recall.

There are other aspects of remember that I could explore, like what is a diary file?, but I don't care too much about that, this works perfectly and is another example of the simple out-of-the-box amazingness of emacs!

* DONE Dired folder size :emacs:elisp:dired:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--dired-folder-size__emacs_linux
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-10-08>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/emacs--dired-folder-size__emacs_linux.jpg
:END:

My =dired= replacement of Dolphin / linux terminal continues.  The next thing is something useful to me but uncommon and something that dired didn't seem to be able to do out of the box.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/emacs--dired-folder-size__emacs_linux.jpg]]

That is to be able to recursively display the size of a folder / files.

Every now and again I like to keep my files and data under control especially as I am using syncthing to backup my core data to my phone.

It is very easy to let a large download or maybe an emacs exported large file sneak through.  My tools of choice have generally been the following and in time order:

- Terminal using =du -h --max-depth 1 <folder>=
- Gnome Disk Usage Analyser (boabab)
- Filelight - now I have moved to KDE

So how do I achieve this?

I could perhaps try something from emacs packages but as you already know my first port of call is to try and preserve vanilla emacs where possible which might mean in this case finding / or writing some elisp.

The =www.emacswiki.org= comes to the rescue once again! with yet another elisp snippet as thus:

#+begin_src elisp
(defun dired-get-size ()
  (interactive)
  (let ((files (dired-get-marked-files)))
    (with-temp-buffer
      (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
      (message "Size of all marked files: %s"
               (progn
                 (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
                 (match-string 1))))))

(define-key dired-mode-map (kbd "?") 'dired-get-size)
#+end_src

I don't need anything too fancy here, for example a full dired integration like Solid Explorer on android but just showing the total size in the minibuffer is fine and why not leverage the existing operating system commands rather than completely depending on elisp!

* DONE Dired going Up Directories :macros:emacs:dired:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--dired-going-up-directories__emacs_linux
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-09-28>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/2022-09-28_20-35.jpg
:END:

Now =dired= is becoming more ingrained into my muscle memory, navigating efficiently through the folder structure is becoming more prominent in my mind and it still doesn't feel natural enough.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/2022-09-28_20-35.jpg]]

I now don't even think about using =C-x d= and the /Enter/ key is fine for either opening a file or traversing into a directory.  But what about moving up a directory!, also a very common action.

The default defined key is =^= and actually isn't too bad and almost feels quite natural, /almost/...

Currently to traverse windows and buffers I am using the =M= key with comfortable key navigation hand positions as I am using these all the time.  I feel like traversing up a directory should have the same feeling, and now I think about it, getting a feel for a hand position and hence an instinctual interaction with the keyboard is almost what emacs is all about (apart from the idea of extension by macros).  Anyways, I digress...

What I would like to achieve is a quick command, no more than I am currently using for my window/buffer navigation, so a quick =M= and another key, one that makes sense and is sensible.  So that is why I think I will have to discount the default =^= as it involves the shift key and actually trying to reach the tilda/6 key doesn't feel that comfortable.

Hence I present the following:

#+begin_src elisp
(define-key dired-mode-map (kbd "M-u") 'dired-up-directory)
#+end_src

The hand position is very comfortable, it fits in with the rest of my window navigation keys and =u= could very well mean *up!*

But there is something left, something that doesn't feel right, or natural... and that is switching to =dired= from a file.  Now I have this new defined key to traverse up a directory I have a general feeling that I should be using the same defined key to show =dired= from when I am visiting a file in a buffer.  It is very odd... I can't explain it, it just feels natural.

If it feels right then I am just going to go ahead and do it, I think the best method is probably to define a macro as thus:

#+begin_src elisp
(global-set-key (kbd "M-u") 'file-up-dir)

(fset 'file-up-dir
      (kmacro-lambda-form [?\C-x ?d return ] 0 "%d"))
#+end_src

The macro is just calling =dired= and then *return* to action the current directory.  That is all I really want to do and for some reason in my own mind I seem to have extrapolated a file to be floating above / or below a directory so it almost makes sense to "go up" a directory to show the directory and hence =dired=

* DONE Cut / Copy between Windows using Dired Buffers :emacs:elisp:dired:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--cut-copy-files-using-dired-buffers__emacs_linux
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-09-26>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/2022-09-26_13-39.jpg
:END:

The next step in my emacs journey is to move files around a little more easily, in fact more like a regular file explorer using the concept of file / folder selection copy and paste.  That concept seems a little more natural to me than =dired= file marking, renaming / copying and then entering the path of the destination address.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/2022-09-26_13-39.jpg]]

After a little research the following options present themselves:

1. Vanilla Dired
   - copy target directory to kill ring using =0 w=
   - mark source files
   - copy or rename files and at the directory destination prompt paste in from
     the kill ring
2. package Dired+
3. Own lisp implementation
4. package Ranger like
5. DWIM

One main criteria I have for this functionality is that if possible I want to avoid installing any additional packages as I always initially try and look for a way using vanilla emacs.

I have emacs on windows, at work and of course on Manjaro, all slightly different versions and I find relying on third party packages can cause a few problems especially on my work emacs where I have installed potentially incompatible versions of MELPA and emacs.  I always like to keep a common as possible initialisation file if possible across all my emacs.

So the choice is between options 1,3 or
5.

Trying number 1 worked well enough but still felt a little clunky and I really wanted to avoid copying and pasting directory names.  The number 5 *do what I mean* concept seems decent enough but seems to mainly rely on opening a window side by side which restricts me as I am a serial window chopper!.  Also I have in the back of my mind to explore the whole DWIM concept in the future, especially when related to running commands on selected files.

Therefore the winner is number 3.  "my own" lisp implementation.  Of course the quotes mean that I am going to borrow and then modify an answer I found on the internet!

The original lisp is as follows

#+begin_src elisp
(defvar your-dired-copy-list nil)

(defun your-dired-copy ()
  (interactive)
  (setq your-dired-copy-list (dired-get-marked-files)))

(defun your-dired-paste ()
  (interactive)
  (when your-dired-copy-list
    (shell-command
     (mapconcat
      #'shell-quote-argument
      `("cp" "-r" ,@your-dired-copy-list ,default-directory)
      " "))
    (setq your-dired-copy-list nil)))
#+end_src

and then to =define-key= add to the =dired-mode-map=

I feel that my emacs journey is creeping ever onwards and my eyes and heart are opening up to creating my own lisp functions that do things that I want emacs to do.  This is a bit of an opportunity to poke a gentle toe into the clear crystal waters of lisp programming.

I have already been exposed to lisp at university although at almost 30 years ago now.  It maybe that it will be more of the 25 years of software engineering experience that will help me now!

I think I understand the initial implementation, and I like the concept of leveraging a shell command and hence the functionality of the underlying operating system.  But I also wish to move files and directories and not just copy them, so I need some form of flag on the *dired* marked files action and inform the paste routine which command I wish to perform.  So I created / modified my first lisp code as thus:

#+begin_src elisp
(defvar my-dired-copy-list nil)

(defun my-dired-copy ()
  (interactive)
  (setq my-move-flag nil)
  (setq my-dired-copy-list (dired-get-marked-files)))

(defun my-dired-move ()
  (interactive)
  (setq my-move-flag t)
  (setq my-dired-copy-list (dired-get-marked-files)))

(defun my-dired-paste ()
  (interactive)
  (when my-dired-copy-list
    (if my-move-flag
        (shell-command
         (mapconcat
          #'shell-quote-argument
          `("mv" "-f" ,@my-dired-copy-list ,default-directory)
          " ")
         )
      (shell-command
       (mapconcat
        #'shell-quote-argument
        `("cp" "-r" ,@my-dired-copy-list ,default-directory)
        " "))
      )
    (setq my-dired-copy-list nil)
    )
  )
#+end_src

and with the following key defines:

#+begin_src elisp
(define-key dired-mode-map "C" 'my-dired-copy)
(define-key dired-mode-map "R" 'my-dired-move)
(define-key dired-mode-map "Y" 'my-dired-paste)
#+end_src

So I just set a simple flag depending on if the file is to be moved or not and then IF'd my way to the relevant functionality.  Using =M= to move a file felt more natural but I kept the =dired= renaming notation of =R= for consistency and to avoid confusion with changing the marked files mode.

This implementation has the side effect of removing the simple *dired* single file rename functionality, but as I generally use =wdired= anyway I don't think this is too much of a problem.

* DONE Trimming Text With Macros :macros:emacs:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--trimming-text-with-macros__emacs_linux
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-09-25>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/emacs--trimming-text-with-macros__emacs_linux.jpg
:END:

I am having a bet!, it is one of my few vices, and it shall be on the horses.  I don't often have a bet and in fact I generally only ever have a bet on a special occasion, like the grand national or a random parallel bet with my dad.

#+hugo: more

Today is a parallel bet, yesterday my dad won over £650 and I have decided to leverage his expert equine knowledge to have a little flutter.  But wait, I'm not going to do that, I am going to leverage my old javascript horse racing prediction program, the algorithm of which was based on something I wrote on my Amstrad CPC in the mid 80s.

Now what has all this twaddle got to do with emacs I hear you say?, well my javascript program requires a very specific format of horse data and it is in fact a very simple one: =number form horsename=

My general aim in the past was to pretty much find a website displaying horse data for the chosen race and copy and paste into a web text input field which my javascript would parse and perform its magic.

SportingLife looks like a good one (top of my startpage search).  The data though of course is in the wrong order and there is a lot of it for each horse.

My first thought with all these things is how can emacs help me out with this?  Well a paste into the *scratch* buffer gives me something like this:

#+begin_src
   1
  (5)
  Horse silk
  Saratoga Goldb27
  Age: 4|  Weight: 10-2| J: Owen Lewis(5)| T: C Hills| OR:  85| CD
  15/8
  Has taken his form up a notch
  Form: 556811|Timeform
  2
  (6)
  Horse silk
  Sword Beachb24
  Age: 5|  Weight: 9-13| J: George Bass| T: A King| OR:  82
  28/1
  Dual Windsor scorer in 2021
  Form: 71165-0|Timeform
#+end_src

I think the best way to approach this is to open a new window along side the scratch buffer and use this as my formatted output window, I will just create a random blank new file for now called /tmp.txt/

Then using a macro I can search around extracting each piece of relevant data for each horse and then just copy to the right hand pane.

Once I have a procedure that works for a single horse then I can just end the macro and then =C-x e= repeat the last keyboard macro and then spam =e= until all the horses are parsed.
#+attr_org: :width 300px
#+attr_html: :width 300px
[[file:static/emacs/emacs--trimming-text-with-macros__emacs_linux.jpg]]

At which point I can copy the text from *tmp.txt*, paste into the html text input and press *Find Winner*, lets see if my old algorithm still holds up!

* DONE Finding Files With RipGrep :ripgrep:emacs:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--finding-files-with-ripgrep__emacs_linux
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-09-21>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/emacs--finding-files-with-ripgrep__emacs_linux.jpg
:END:

Now I am appreciating the power and simplicity of ripgrep and have it available on all my systems I was hunting around emacs to see the best way to leverage this tool for quick file searching.

#+hugo: more

Working on a code base that is familiar to me is fine when locating files within emacs as of course I know where to go and when I am not I would typically open up a terminal and use =find=

As we know, =find= can be a little picky and fiddly to use and it is not a straightforward process to define the files and folders I am not interested in when returning an efficient search.

Now I have defined an *.ignore* file to define which files and directories I am not interested in for a regular ripgrep I was wondering if I could also use this somehow to search for files within a project hierarchy and from within emacs.

I have heard good things about projectile and in combination with a completion system it can bring up a searchable file list. This seems like a good solution but unfortunately I have never really found it fits in with my simple workflow, I have always failed to set it up properly and generally I don't require the ability to switch between projects.

After running =list-packages= and literally searching for ripgrep, I came across a package called *find-file-rg*, which leverages the =rg --files= command to list all files in the directory defined but excluding from the ripgrep defined .ignore file.

Fed into Ivy it means a list of potential files can be displayed and located using its completion system and all I need to define is the following:

#+begin_src elisp
(global-set-key [f4] 'find-file-rg)
#+end_src

and hey presto!
#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/emacs--finding-files-with-ripgrep__emacs_linux/2022-09-21_21-11.jpg]]

* DONE Putting to Trash :wastebasket:trash:emacs:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--putting-to-trash__emacs_linux
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-09-15>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/emacs--putting-to-trash__emacs_linux.jpg
:END:

I was recently reading a post about deleting files from within emacs and pushing them to the local Trash, this seems like a good idea especially now I am using dired more often.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/emacs--putting-to-trash__emacs_linux.jpg]]

After using =describe-function= and typing */trash/* there was a single completion, namely =move-file-to-trash= from this I figured out I should add the following my .emacs:

#+begin_src elisp
(setq trash-directory "~/.local/share/Trash/files")
(setq delete-by-moving-to-trash t)
#+end_src

I am running this on OpenSuse so the location of the Trash folder may vary from system to system.

For a more bespoke copying mechanism there is potentially the ability to define system-move-file-to-trash accepting */file/* as an argument, but currently I don't need anything to be that sophisticated.

* DONE Efficient Deletion and Insertion :emacs:elisp:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--efficient-deletion-and-insertion__emacs_linux
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-09-10>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/emacs--efficient-deletion__emacs_linux.jpg
:END:

As my emacs keybindings journey continues to evolve and to delete more efficiently with delete word it has lead to an interesting issue for me.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/emacs--efficient-deletion__emacs_linux.jpg]]

Typically, especially in my coding life I will typically copy a string to the clipboard, then go in and delete the target area and insert from the clipboard/kill-ring.  Now I have moved from deleting with the delete key to the the M-delete-word concept it seems that deleting words automatically puts this to the clipboard/kill-ring, so when I paste in my original copy it pastes back in the last killed words.

Generally I only ever use kill-line when I want a kill to be copied to the kill-ring and I only ever use the word deletion to just delete in preparation for a yank.

A bit of hunting around on the Interwebs lead to the definition of two new functions to be remapped to avoid the kill-ring.

#+begin_src elisp
(defun delete-word-back (arg)
  "Delete characters backward until encountering the beginning of a word.
     With argument ARG, do this that many times."
  (interactive "p")
  (delete-region (point) (progn (backward-word arg) (point))))

(defun delete-word-forward (arg)
  "Delete characters forward until encountering the end of a word.
     With argument ARG, do this that many times."
  (interactive "p")
  (delete-region (point) (progn (forward-word arg) (point))))
#+end_src

* DONE Images to Blog Posts :hugo:emacs:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--images-to-blog-posts__emacs_linux
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-08-28>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/emacs--images-to-blog-posts-cover__emacs_linux.jpg
:END:

I am just playing around with writing some sort of "techy" blog, trying to focus on a couple of my favourite things in the world, namely linux and emacs, so I thought I would do the best productive thing in the world and just start to type.

#+hugo: more

I have set up this blog in a certain way using a static web site generator called Hugo, but more on that later down the road.

For now I want to just focus on describing what I am tinkering around with at the moment regarding emacs, as yes, I am always tinkering, like a good 'ol emacs user.  Yes I am old, but more on that later down the road...

I am writing this post in org mode and am trying to figure out how to insert an image, of course the first point of call would be *org-download*, I have tried this package a few times in the past but never quite got off the ground.  I understand the concept and would love to be able to drag and drop an image straight into an org file.

This of course can be accomplished using org-download but for publishing my blog it doesn't quite cut the mustard.  Hugo uses org files natively and rather than defining a *[[file:* type org link it omits the file reference and forward slash starts a reference to the /org-hugo-base-dir/ which would be where my static image files reside.

I had a bit of a hunt around and although I could define which directory the image would be dumped when draggging the file from the file explorer I would probably need to change this for each new post and even then I would need to remove the *file:* from the link reference.

So I found a simple method:

- In emacs dired the directory I want to drag the image
- Drag the image, the file is dropped nicely
- Use my favourite dired command at the moment *0 w* to get the full path of the
  file name
- yank the filename that is on the clipboard into the blog org, "M-d" the start of the path up to the Hugo base directory
- Wrap the link in double brackets

Although I said simple, the list of steps looks less simple but as part of the emacs workflow and my emacs muscle memory kicking in I think this provides at present a decent solution.

Here is an image of me using the technique so there!:
#+attr_org: :width 300px
#+attr_html: :width 100%
[[file:static/emacs/emacs--images-to-blog-posts-cover__emacs_linux/james.jpg]]

It took me about 10 seconds!, not too shabby

Next step, I might look to a good spellchecker, flycheck, aspell, hunspell and all that!

* DONE Profiling and Accidental Learning :profiling:esup:emacs:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: emacs--profiling-and-accidental-learning__emacs_linux
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-08-20>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/emacs--profiling-and-accidental-learning__emacs_linux.jpg
:END:

My sacred emacs is taking 13 seconds to start up!

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/emacs--profiling-and-accidental-learning__emacs_linux.jpg]]

This is not good, I have read somewhere about a built in profiler, and indeed when I *ivy* complete for a function *profiler* I find a plethora of options.  *profiler-start* looks good, and with a little intersearching it all seems simple enough, except it looks as though it probably won't solve my start up problems but will profile any commands I execute in emacs, so would solve for example an issue I had in the past with *deft* starting up.

I found a good option in *esup*, added the following to my .emacs :

#+begin_src elisp
(use-package esup
  :ensure t
  ;; To use MELPA Stable use ":pin melpa-stable",
  :pin melpa)
#+end_src

initially it didn't work and gave me the following:

#+begin_src
  error in process sentinel: Wrong type argument: (or eieio-object class), nil, obj
#+end_src

but with a little research I managed to fix it with adding the following to my .emacs :

#+begin_src elisp
;; Work around a bug where esup tries to step into the byte-compiled
;; version of `cl-lib', and fails horribly.
(setq esup-depth 0)
#+end_src

and on running *esup* I get a nice report generated with the top offenders in my /.emacs/ *org-download* was at the top:

#+begin_src elisp
.emacs:36  0.264sec   22%
(use-package org-download)
#+end_src

I like the way it runs up a separate child emacs session to test out the timing on the init file and then generated a report.

But overall the total time was /1.166sec/ there must be something else going on here.  At which point I twigged and remembered that as I have *(desktop-save-mode 1)* set it means that all my buffers are reloaded on a new emacs startup, once I cleaned all these out, which I do from time to time it only took a couple of second to run up!

I think my lesson from this exercise is the amazing possibilities of learning through investigation and trying to fix issues and emacs is so configurable and so much fun to play around with I find myself learning more and more!

* DONE Download Local Emacs Packages :org:melpa:emacs:elpa:2022:
:PROPERTIES:
:EXPORT_FILE_NAME: 20220715142225-emacs--Download-Local-Emacs-Packages
:EXPORT_HUGO_SECTION: emacs
:EXPORT_HUGO_LASTMOD: <2022-07-15>
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :thumbnail /emacs/20220715142225-emacs--Download-Local-Emacs-Packages.jpg
:END:

Steps to locally download emacs packages for offline installation.

#+hugo: more

#+attr_org: :width 300px
#+attr_html: :class emacs-img
[[file:static/emacs/20220715142225-emacs--Download-Local-Emacs-Packages.jpg]]

--- TOC
#+TOC: headlines 1 local
---

** Local ELPA MELPA ORG

#+begin_src shell
cd ~ mkdir -p emacs-pkgs/melpa mkdir -p emacs-pkgs/elpa

# mirror the melpa emacs archive
echo
echo "updating MELPA..."
echo
rsync -avz --delete --progress rsync://melpa.org/packages/ ~/emacs-pkgs/melpa/.

# elpa
echo
echo "updating ELPA..."
echo
rsync -avz --delete --progress elpa.gnu.org::elpa/. ~/emacs-pkgs/elpa

# org (currently no rsync support)
echo
echo "updating ORG..."
echo
cd ~/emacs-pkgs
git clone https://git.savannah.gnu.org/git/emacs/org-mode.git
#+end_src

I then copy the emacs-pkgs directory to the offline target machine and change the default package manager archives to point to these packages.

Modify *.emacs* in the following manner commenting out the online package communication:

#+begin_src elisp
;; (setq package-archives '(("melpa" . "https://melpa.org/packages/")
;;                          ("org" . "https://orgmode.org/elpa/")
;;                          ("elpa" . "https://elpa.gnu.org/packages/")))

(setq package-archives '(("melpa". "~/emacs-pkgs/melpa")
                         ("org" . "~/emacs-pkgs/elpa")
                         ("elpa" . "~/emacs-pkgs/org-mode/lisp")))
#+end_src

** Local from Mirror

First, you need to clone this repository.

#+begin_src bash
git clone --depth 1 git@gitlab.com:d12frosted/elpa-mirror.git ~/.elpa-mirror
#+end_src

And then setup package-archives in your init.el file.

#+begin_src elisp
(setq package-archives
      `(("melpa" . ,(concat user-home-directory ".elpa-mirror/melpa/"))
        ("org"   . ,(concat user-home-directory ".elpa-mirror/org/"))
        ("gnu"   . ,(concat user-home-directory ".elpa-mirror/gnu/"))))
#+end_src

https://github.com/d12frosted/elpa-mirror

** Extra
*** ada-mode

ada-mode.el version 4.0 before AdaCore

#+begin_src elisp
(add-to-list 'load-path "~/emacs-pkgs/old/ada-mode-4.1")
(require 'ada-mode)
#+end_src

* TODO Emacs email mu4e :noexport:emacs:

mu init --maildir=/home/jdyer/Maildir --my-address='james@dyerdwelling.family'

Also run the above command if mu has upgraded

mbsync -c ~/.mbsyncrc -a gpg2 -c captainflasmr.acc

As a note if I ever get some kind of defvar-1 error when opening mu4e then the install of mu is probably incorrect so from the linux package manager just uninstall and then reinstall!

** lock file issues

if you get the following error:
#+begin_src
error in process sentinel: mu4e--server-sentinel: mu database is locked by another process
error in process sentinel: mu database is locked by another process
#+end_src

Then remove ~/.cache and run the init command above.

or :

[AI]: The mu database is locked by another process error in emacs mu4e can occur if another process is using the mu database. To resolve this error, you can follow these steps:

1. Close all mu4e buffers and restart the mu4e server by typing M-x mu4e-quit and then M-x mu4e.

2. If the error persists, you can try killing the process that is using the mu database. To do this, type M-x list-processes, find the process with the mu command and then type M-x kill-process.

3. Another option is to manually delete the lock file that is causing the issue. To do this, go to your mu database folder (e.g. ~/.mu) and delete the file named ".mu/xapianlock".

4. Finally, if none of the above steps work, you can try rebuilding your mu database by typing M-x mu4e-update-index. This will recreate the database from scratch and should resolve any lock-related issues.
   mu init --maildir=/home/jdyer/Maildir --my-address='james@dyerdwelling.family'
error: Unable to get write lock on /home/jdyer/.cache/mu/xapian: already locked
Perhaps mu is already running?
I removed : /home/jdyer/.cache/mu/xapian/flintlock
well what worked for me was the following:
lsof 2>/dev/null | grep xapian
mu        1617                jdyer  mem       REG              259,5    2033720  539122749 /usr/lib/libxapian.so.30.12.3
mu        1617                jdyer    4w      REG              259,5          0  367982026 /home/jdyer/.cache/mu/xapian/flintlock
mu        1617                jdyer    5u      REG              259,5     352256  365231823 /home/jdyer/.cache/mu/xapian/docdata.glass
mu        1617                jdyer    6u      REG              259,5    1449984  367982028 /home/jdyer/.cache/mu/xapian/termlist.glass
mu        1617                jdyer    7u      REG              259,5   10919936  365231824 /home/jdyer/.cache/mu/xapian/position.glass
mu        1617                jdyer    8u      REG              259,5    4554752  367982029 /home/jdyer/.cache/mu/xapian/postlist.glass
and then kill the process
kill -9 1617
and restart emacs

* TODO Emacs Theme Editor

https://emacsfodder.github.io/emacs-theme-editor/

